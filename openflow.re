= OpenFlow の仕組み

== コントロールとデータを分離する
=== 分離していないと？
=== コントローラの仕事

== OpenFlow プロトコル
=== 未知のパケット (packet-in)
=== フローを更新する (flowmod)

== フローの中身
=== マッチングルール

フローの構成要素の一つにマッチングルールがあります。マッチングルールとは、OpenFlow スイッチがパケットを受け取ったときにアクションを起こすかどうかを決める条件です。たとえば「パケットの宛先が http サーバだったら」とか「パケットの送信元がローカルネットワークだったら」などという条件に適合したパケットにだけ、スイッチがアクションを起こすというわけです。

OpenFlow 1.0 では、@<table>{matching_rules} の 12 種類の条件が使えます。これらの条件はイーサネットや TCP/UDP でよく使われる値です。これらの条件をネットワークレイヤの視点で整理すると、レイヤ 1 からレイヤ 4 までの情報を使えることがわかります。

//table[matching_rules][マッチングルールで指定できる 12 種類の条件]{
名前			説明				レイヤ
--------------------------------------------------------------
Ingress Port		スイッチの物理ポート番号	L1
Ether src		送信元 MAC アドレス		L2
Ether dst		宛先 MAC アドレス		L2
Ether type		イーサネットの種別		L2
VLAN id			VLAN ID				L2
VLAN priority		VLAN PCP の値 (CoS)		L2
IP src			送信元 IP アドレス		L3
IP dst			宛先 IP アドレス		L3
IP proto		IP のプロトコル種別		L3
IP ToS bits		IP の ToS 情報			L3
TCP/UDP src port	TCP/UDP の送信元ポート番号	L4
TCP/UDP dst port	TCP/UDP の宛先ポート番号	L4
//}

OpenFlow の世界では、マッチングルールで指定できる条件を自由に組み合わせて通信を制御します。つまり、レイヤや宛先のような従来の枠組みではなく、たとえば、

 * スイッチの物理ポート 1 番から届く、宛先が TCP 80 番 (= HTTP) のパケットを書き換える
 * MAC アドレスが 02:27:e4:fd:a3:5d で宛先の IP アドレスが 192.168.0.0/24 のものは遮断する
   
というふうに自由に複数の条件を組み合わせることができるのです。

これに対して従来のネットワーク機器では、ネットワークの各レイヤに対応した個々のネットワーク機器が、そのレイヤで処理を行うのが当然でした。たとえばレイヤ 2 スイッチは宛先の MAC アドレスを用いてスイッチが転送先の物理ポートを特定し、そのポートにパケットを送ります。レイヤ 3 スイッチであれば、宛先の IP アドレスを使って同様の動きをします。こうした制限を無くし、ひとつのレイヤにとらわれない制御をするのが OpenFlow の特徴の一つと言えます。

===[column] 取間先生曰く: OSI ネットワークモデルが壊れる？

あるネットワークの経験豊富な若者がこんな事を言っていた「OpenFlow のようにレイヤをまたがって自由に何でもできるようになると、OSI ネットワークモデルが壊れるんじゃないか？」

その心配は無用じゃ。OSI ネットワークモデルは正確に言うと「OSI 参照モデル」と言って、通信プロトコルを分類して見通しを良くするために定義した "参照用" の階層モデルじゃ。たとえば自分が xyz プロトコルというのを作ったけど人に説明したいというときに、どう説明するか考えてみてほしい。「これはレイヤ 3 のプロトコルで、…」という風に階層を指して (参照して) 説明を始めれば相手に通りがいいじゃろ。つまり、OSI ネットワークモデルはネットワーク屋同士で通じる「語彙」として使える、まことに便利なものじゃ。

でも、これはあくまで「参照」であって「規約」ではないので、すべてのネットワークプロトコル、ネットワーク機器がこれに従わなきゃならん、というものではないぞ。さっき言ったように「この ○○ は、仮に OSI で言うとレイヤ4 にあたる」のように使うのが正しいのじゃ。

そして、OpenFlow はたまたまいくつものレイヤの情報が使える、ただそれだけのことじゃ。

===[/column]

=== 統計情報

フローの構成要素の一つに統計情報があります。統計情報はスイッチに実装されたカウンタの一種で、パケットの転送数やエラー数などを数えてくれます。コントローラはこのカウンタの値を使うことによってたとえば、

 * ネットワーク情報の可視化
 * エラーの通知や警告、予測
 * トラフィックの大小に応じたユーザごとの帯域制御
 * トラフィックの傾向に応じた転送パスの切り替えやスイッチの ON/OFF 制御

などを行うことができます。

==== 統計情報の利用例

ひとつ具体的な実装例をお見せしましょう。Trema のサンプルアプリケーションのひとつ、トラフィックモニタがこの統計情報を利用しています。これは、普通のレイヤ 2 スイッチとして動作しますが、ユーザごと (MAC アドレスごと) の転送パケット数とバイト数を統計情報を利用して表示してくれます。

トラフィックモニタの実行例は次のようになります。パケットを送信したホストの MAC  アドレスごとに、スイッチが転送したパケットの数とバイト数を定期的に更新して表示します。

//emlist{
% cd src/examples/traffic_monitor/
% trema run ./traffic-monitor.rb -c ./traffic-monitor.conf
……
00:00:00:00:00:01 10 packets (640 bytes)
……
00:00:00:00:00:02 10 packets (640 bytes)
……
//}

トラフィックモニタの実装は第 II 部の @<chap>{traffic_monitor} で詳しく解説します。統計情報の利用例として参考にしてみてください。

==== カウンタの種類

OpenFlow 1.0 ではカウンタはスイッチの次の 4  箇所にセットされています。取得したい情報の種類や粒度に応じて使い分けることができます。

 * フローテーブルごと
 * フローごと
 * ポートごと
 * キューごと

少し細かいですが、以下にそれぞれで定義されている統計情報をまとめます。

===== フローテーブルごと

 * 有効なエントリの数
 * パケットのルックアップ数
 * パケットのマッチ数

===== フローごと

 * 受信パケット数
 * 受信バイト数
 * フローが作られてからの経過時間 (秒)
 * フローが作られてからの経過時間 (ナノ秒)

===== ポートごと

 * 受信パケット数
 * 転送パケット数
 * 受信バイト数
 * 転送バイト数
 * 受信ドロップ数
 * 転送ドロップ数
 * 受信エラー数
 * 転送エラー数
 * フレームアライメントエラー数
 * 受信オーバーランエラー数
 * 受信 CRC エラー数
 * コリジョン数

===== キューごと

 * 転送パケット数
 * 転送バイト数
 * 転送オーバーランエラー数

さて、この節ではフローの統計情報の中身と利用例を紹介しました。スイッチからのフィードバック情報である統計情報をうまく使うことによって、ネットワークの制御や可視化の精度を上げることができます。

=== アクション

フローの構成要素の一つにアクションがあります。アクションとは、スイッチに入ってきたパケットをどう料理するか、という@<em>{動詞}にあたる部分です。よく「OpenFlow でパケットを書き換えて曲げる」などと言いますが、これらはすべてこのアクションで実現できることです。それでは、OpenFlow 1.0 ではどんなアクションが定義されているか見てみましょう。

==== アクションの種類

アクションは大きく分けて次の 4 種類があります。

 * Forward: パケットを指定したポートから出力する
 * Modify-Field: パケットの中身を書き換える
 * Drop: パケットを捨てる
 * Enqueue: ポートごとに指定されたスイッチのキューに入れる。QoS 用。
 
アクションは動詞と同じく指定した順番に実行されます。「ごはんを作って、食べて、片付ける」といったふうに。たとえば、パケットを書き換えて指定したポートに出したいときには、

//emlist{
[Modify-Field, Forward]
//}

というアクションのリストを指定します。ここで、アクションは指定された順番に実行されることに注意してください。アクションの順番を変えてしまうと、違う結果が起こります。たとえば「ごはんを食べてから、ごはんを作る」と最後にごはんが残ってしまいます。同様に先ほどの例を逆にしてしまうと、先にパケットがフォワードされてしまうので Modify-Field は実行されなくなります。

//emlist{
# パケットを書き換える前にフォワードされてしまう。
[Forward, Modify-Field]
//}

同じ動詞を複数指定することもできます。

//emlist{
[Modify-Field A, Modify-Field B, Forward A, Forward B]
//}

この場合は、フィールド A と B を書き換えて、ポート A と B へフォワードする、と読めます。このように、複数の箇所を書き換えたり複数のポートからパケットを出したい場合には、アクションを複数連ねて指定します。

Drop は特殊なアクションで、実際には Drop アクションというものが具体的に定義されているわけではありません。アクションのリストに Forward アクションをひとつも入れなかった場合、そのパケットはどこにもフォワードされずに捨てられます。これを Drop アクションと呼んでいるわけです。

それでは、最もよく使われる Forward アクションと Modify-Field アクションで具体的に何が指定できるか見て行きましょう。

===== Forward アクション

Forward アクションでは指定した出力ポートにパケットを転送します。出力ポートはポート番号で指定することもできますが、いくつか論理的なポートが定義されています。

 * ポート番号: パケットを指定した番号のポートに出す。
 * IN_PORT: パケットを入ってきたポートに出す。
 * ALL: パケットを入ってきたポート以外のすべてのポートに出す。
 * FLOOD: パケットをスイッチの作ったスパニングツリーに沿って出す。スイッチが複数台ある場合にはループが起こらないので ALL よりも安全。
 * CONTROLLER: パケットをコントローラに明示的に送り、Packet In を起こす。
 * NORMAL: パケットをスイッチの機能を使って転送する。従来のスイッチの動作と同じ。
 * LOCAL: パケットをスイッチのローカルポートに出す。ローカルポートを監視するアプリケーションに特殊な処理をさせたい場合に使う。あまり使われない。

===== Modify-Field アクション

Modify-Field アクションではパケットの様々な部分を変更することができます。

 * VLAN ヘッダの除去: VLAN のヘッダを除去する。
 * VLAN ID の書き換え: 指定された VLAN ID をセットする、または既存のものがあれば書き換える。
 * VLAN プライオリティの書き換え: 指定された VLAN プライオリティをセットする、または既存のものがあれば書き換える。VLAN ID はゼロになる。
 * 送信元 MAC アドレスの書き換え: 送信元の MAC アドレスを書き換える。
 * 宛先 MAC アドレスの書き換え: 宛先の MAC アドレスを書き換える。
 * 送信元 IP アドレスの書き換え: 送信元の IP アドレスを書き換える。
 * 宛先 IP アドレスの書き換え: 宛先の IP アドレスを書き換える。
 * TCP/UDP 送信元ポートの書き換え: TCP/UDP の送信元ポート番号を書き換える。
 * TCP/UDP 宛先ポートの書き換え: TCP/UDP の宛先ポート番号を書き換える。
 * ToS フィールドの書き換え: IP の ToS フィールドを書き換える。

それぞれのアクションでできることと、代表的な使い途を順番に見ていきましょう。

====== VLAN 系の書き換え

OpenFlow はネットワーク仮想化の手段の一つである VLAN のパケットを扱うことができます。VLAN (仮想 LAN) は一枚のネットワーク (ブロードキャストが届く範囲) を薄くスライスして何枚かの仮想的な層に分離するための仕組みです。OpenFlow では仮想ネットワークを作る手段としてこの VLAN の仕組みをそのまま使うことができます。あるいは VLAN を使わずに別のネットワーク仮想化方式を使う場合でも、既存のネットワークから流れてくるかもしれない VLAN パケットをいったん素のパケットに戻す必要があります。いずれの場合でも OpenFlow スイッチは VLAN パケットを書き換える必要があります。Modify-Field アクションはこうした処理に必要なアクションを 3 種類用意しています。

//image[strip_vlan][VLAN 情報を書き換えるアクションの使い途][scale=0.3]

: VLAN ヘッダの除去
  VLAN を流れる VLAN ヘッダ付きパケットを普通のパケットに戻すアクションです。これによって、たとえば VLAN から流れてきたパケットを普通の仮想化されていないネットワークに流したり、別の方式で作った仮想ネットワークに流すための前処理として使えます。

: VLAN ID の書き換え
  VLAN パケットが属する仮想 LAN の ID を書き換えます。たとえば仮想 LAN 1 番 (ID = 1 番) を流れるパケットを仮想 LAN 3 番に流すときなどに使います。

: VLAN プライオリティの書き換え
  VLAN 上でのパケットを転送する優先度を変更します。このプライオリティはトラフィックの種類 (データ、音声、動画など) に応じて指定することができます。指定できる値は 0 (最低) から 7 (最高) までです。

====== MAC アドレスの書き換え

MAC アドレス書き換えの代表的な例がルータです。OpenFlow はルータの実装に必要な、送信元と宛先 MAC アドレスの書き換えアクションをサポートしています。

//image[rewrite_mac][ルータでの送信元と宛先 MAC アドレスの書き換え][scale=0.3]

ルータは 2 つのネットワークの間で動作し、ネットワーク間で行き交うパケットの交通整理を行います。ホスト A が異なるネットワークに属するホスト B にパケットを送ると、ルータはそのパケットを受け取りその宛先 IP アドレスから転送先のネットワークを決定します。そして、パケットに記述された宛先 MAC アドレスを次に送るべきホストの MAC アドレスに、送信元を自分の MAC アドレスに書き換えてデータを転送します。

====== IP アドレスの書き換え

IP アドレス書き換えの代表的な例が NAT (Network Address Transition) です。OpenFlow は NAT の実装に必要な、送信元と宛先 IP アドレスの書き換えアクションをサポートしています。

//image[rewrite_ip_address][NAT での送信元と宛先 IP アドレスの書き換え][scale=0.3]

ゲートウェイなどのインターネットと接続するルータでは、プライベート/グローバルネットワーク間での通信を通すために IP アドレスを次のように変換します。プライベートネットワーク内のクライアントホストからインターネット上のサーバに通信をする場合、ゲートウェイはプライベートネットワークから届いたパケットの送信元 IP アドレスを自分のグローバルな IP アドレスに変換して送信します。逆にサーバからの返信は逆の書き換えを行うことによりプライベートネットワーク内のクライアントホストに届けます。

====== TCP/UDP ポート番号の書き換え

TCP/UDP ポート番号書き換えの代表的な例が IP マスカレードです。OpenFlow は IP マスカレードの実装に必要な、送信元と宛先の TCP/UDP ポート番号の書き換えアクションをサポートしています。

//image[rewrite_port][IP マスカレードでの送信元と宛先 TCP/UDP ポート番号の書き換え][scale=0.3]

ブロードバンドルータなど 1 つのグローバルアドレスで複数のホストが同時に通信を行う環境では、NAT だけだと TCP/UDP のポート番号が重複する可能性があります。そこで、IP マスカレードではプライベートネットワーク側のポート番号をホストごとに適当に割り当て、通信のつどポート番号を変換することで解決します。

====== ToS フィールドの書き換え

ToS フィールドは通信のサービス品質 (QoS) を制御する目的でパケットを受け取ったルーターに対して処理の優先度を指定するために使われます。OpenFlow はこの ToS フィールドの書き換えアクションをサポートしています。

== まとめ/参考文献
