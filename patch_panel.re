= インテリジェントなパッチパネル

//lead{
実際のネットワーク管理に役立ち、さらに SDN の入門にもなるのがこの OpenFlow で作ったパッチパネルです。その上ソースコードも簡単とくれば、試さない手はありません。
//}

== 便利なインテリジェント・パッチパネル

スイッチやサーバが増えてくると、ネットワークケーブルの配線は悲惨なまでにごちゃごちゃになります。からみあったケーブルのせいで見通しが悪くなるのはもちろん、気にせずさらに増築を続けると、最悪の場合は配線のやり直しとなります。こうなってしまう一番の原因は、スイッチやサーバ同士をケーブルで直接つないでしまうことです。これでは、つなぐデバイスを増やせば増やすほどごちゃごちゃになるのは当然です。

これを解消するのがパッチパネルという装置です (@<img>{patch_panel})。パッチパネルの仕組みはシンプルで、ケーブルを挿すためのコネクタがずらり並んでいるだけです。これによって配線をいったんパッチパネルで中継できるので、配線がすっきりし拡張性が向上します。また、うまく設計すると配線の変更をパッチパネルの前面だけで行えるようになるので、メンテナンス性も向上します。

//image[patch_panel][ごちゃごちゃした配線をパッチパネルで中継してすっきりと][scale=0.5]

このパッチパネルを改善し、ネットワーク経由で操作できるようにしたのがいわゆるインテリジェント・パッチパネルです。パッチパネルでメンテナンス性が向上できるとしても、配線を変更するたびにサーバ室まで足を運ぶのはちょっと面倒です。そこで、パッチパネルの配線をネットワーク経由で変更できるようにすることで、さらにメンテナンス性が上がります。

== OpenFlow 版インテリンジェント・パッチパネル

こうしたインテリジェント・パッチパネルは OpenFlow を使うと簡単に実装できます。パッチパネルでの中継のように、パケットをコネクタからコネクタへ転送するというのは、フローが得意とすることの一つだからです。

OpenFlow で実装したパッチパネルは@<img>{openflow_patch_panel} のようになります。コントローラにパッチパネルの機能を実装し、接続を中継したいデバイス (ホストまたはスイッチ) を OpenFlow スイッチにつなげます。コントローラは OpenFlow スイッチにパケット転送のルールをフローエントリとして書き込むことで、仮想的なパッチを作ります。

//image[openflow_patch_panel][OpenFlow で実現したパッチパネルの仕組み][scale=0.5]

たとえば、@<img>{openflow_patch_panel} の OpenFlow スイッチについて、ポート 1 番と 4 番につなげたデバイス同士をパッチングしたい場合を考えてください。この場合、必要なフローエントリは次の 2 つです。

 * ポート 1 番に入力したパケットを、ポート 4 番に出力する。
 * ポート 4 番に入力したパケットを、ポート 1 番に出力する。

//noindent
フローエントリを構成する要素には、「こういうパケットが届いたとき」というマッチングルールと、「こうする」というアクションがあるのでした。この場合「ポート x 番に入力」がマッチングルールで、「ポート y 番に出力」がアクションです。

それでは仕組みが分かったところで、さっそくコントローラの実装に進みましょう。

== PatchPanel コントローラ

今回もまずはパッチパネルのソースコード (@<list>{patch-panel.rb}) をざっと眺めることから始めましょう。このソースコードは Trema のサンプルアプリに付属する、@<tt>{patch_panel/patch-panel.rb} でも読むことができます。

#@warn(Trema のサンプルに patch_panel/ を追加)

//list[patch-panel.rb][パッチパネル (@<tt>{patch-panel.rb}) のソースコード]{
class PatchPanel < Controller
  def start
    @patch = []
    File.open( "./patch-panel.conf" ).each_line do | each |
      if /^(\d+)\s+(\d+)$/=~ each
        @patch << [ $1.to_i, $2.to_i ]
      end
    end
  end


  def switch_ready datapath_id
    @patch.each do | port_a, port_b |
      make_patch datapath_id, port_a, port_b
    end
  end


  ##############################################################################
  private
  ##############################################################################


  def make_patch datapath_id, port_a, port_b
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_b ),
      :actions => SendOutPort.new( port_a )
    )
  end
end
//}

今までに学んだ知識で、まずはこの Ruby ソースコードをできるところまで解読してみましょう。

 * パッチパネルの本体は @<tt>{PatchPanel} という名前の小さなクラスです。
 * そして@<chap>{switch_monitoring_tool}で学んだ @<tt>{switch_ready} ハンドラの中で @<tt>{make_patch} というプライベートメソッドを呼んでいます。どうやらこれがパッチング処理の本体のようです。
 * @<tt>{make_patch} の中では @<tt>{send_flow_mod_add} という Flow Mod メッセージに関連ありそうなメソッドを 2 回呼んでいます。ひとつのパッチは 2 つのフローエントリに対応するので、2 回呼んでいるのだろうと推測できます。

//noindent
ここまで分かればしめたものです。あらかじめ仕組みが分かっていれば、ソースコードを読むのは簡単ですね。

それでは詳しくソースコードの中身を見る前に、実際に動かして動作イメージをつかんでみましょう。

=== 実行してみよう

パッチパネルは物理的なケーブリングを整理するためのものなので、今回は仮想ネットワークではなく、実機の OpenFlow スイッチを使います。もし実機を持っていない場合には (そういう読者が大半でしょう)、@<chap>{diy_switch}を参考に OpenFlow スイッチの自作に挑戦してみてください。

このパッチパネルでは、どのポートとどのポートをパッチングするかを設定ファイル (@<tt>{patch-panel.conf}) で指定します。たとえば、ポート 1 番と 10 番、およびポート 2 番と 11 番をパッチングする場合には、次の設定ファイルをコントローラのファイル (@<tt>{patch-panel.rb}) と同じディレクトリに置いてください。

//emlist{
1 10
2 11
//}

@<tt>{PatchPanel} コントローラを実行すると、この設定ファイルを読み込み仮想パッチを OpenFlow スイッチに反映します。今回のように実機の OpenFlow スイッチとコントローラを接続するのも、@<tt>{trema run} コマンドできます。実機の場合には @<tt>{-c} オプションなしでコントローラを実行します。起動したコントローラに実機の OpenFlow スイッチが接続します。

//cmd{
% trema run ./patch-panel.rb
//}

うまく動きましたか？パッチングの設定を変更するには、設定ファイルを書き換え、Ctrl-C でいったん停止させてからふたたび起動してください。とても素朴なツールですが、ちょっとしたネットワーク管理には便利なツールです。

== 即席 Ruby 入門

それでは、いつものようにパッチパネルのソースコード (@<list>{patch-panel.rb}) で新しく登場した Ruby の文法を覚えましょう。

=== イテレータ

配列などの要素それぞれに対して、ひとつの処理を繰り返すときに使うのがイテレータです。「繰り返す」という動作から分かるように、要はループの一種です。Ruby プログラマは @<tt>{each} という名前で始まるイテレータをたくさん使います。@<tt>{each} つまり「それぞれ」についてある処理を繰り返す、と理解すれば覚えやすいでしょう。

次の例は配列 @<tt>{members} の中身をそれぞれ出力するという、イテレータの代表的な使い方です。

//emlist{
members = [ "友太郎", "青井", "宮坂主任" ]
members.each do | name |
  puts name
end

(出力)
友太郎
青井
宮坂主任
//}

//noindent
このコードは、3 つの名前が入った配列に対してイテレータ @<tt>{each} を呼び、それぞれの名前を出力します。@<tt>{do} の右側の @<tt>{| name |} は仮引数で、配列の各要素である名前が入ります。そして字下げされたブロックの中の @<tt>{puts} で、この名前を標準出力に出します。

このコードは、次の C コードと意味が同じです。

//emlist{
for ( i = 0; i < 3; i++ ) {
  puts members[ i ];
}
//}

//noindent
C のコードでは、名前の入った配列 @<tt>{members} の要素を順に処理するために、ループ用の変数 @<tt>{i} を使いました。@<tt>{for} で @<tt>{i = 0, 1, 2} とループを回すことで、@<tt>{members} の要素を順に取り出したのです。

Ruby のイテレータは、このループ用変数を使いません。仮引数に順に要素がセットされるので、プログラマはループ変数の初期化やインクリメントを気にせずにループを書けるのです。このようにループをちょっとだけ抽象化したものがイテレータである、と覚えましょう。

=== 正規表現

Ruby の正規表現は Perl や他の言語の正規表現とほとんど同じです。スラッシュ (@<tt>{/}) ではさまれた文字列が正規表現で、その中に正規表現のパターンを書きます。正規表現に文字列をマッチさせるには @<tt>{=~} に続いて文字列を渡します。もしマッチしなかった場合には @<tt>{nil} が返るので、次のように @<tt>{if} の条件に指定することでマッチしたかどうかを判定できます。

//emlist{
if /taura/=~ "restaurant"
  puts "restaurant は taura にマッチ"
end

(出力)
restaurant は taura にマッチ
//}

正規表現で文字列のある部分を取り出したいときには、かっこ @<tt>{()} と変数 @<tt>{$1}、@<tt>{$2}、… を使います。

//emlist{
if /(\d+)\s+Monkeys\s+(\d+)\s+Bananas/=~ "12 Monkeys 1 Bananas"
  puts "猿は #{ $1 } 匹、バナナは #{ $2 } 本"
end

(出力)
猿は 12 匹、バナナは 1 本
//}

このように正規表現がマッチした場合、かっこで囲われた部分にマッチした文字列が先頭から順に @<tt>{$1}、@<tt>{$2}、… にセットされます。このあたりも、他の言語とほとんど同じです。

== PatchPanel コントローラのソースコード解説

それでは、パッチパネルのソースコードを詳しく見ていきましょう。

=== 設定ファイル (@<tt>{patch-panel.conf}) の読み込み

@<tt>{start} ハンドラでは、設定ファイル (@<tt>{patch-panel.conf}) を読み込み設定情報をインタンス変数 @<tt>{@patch} にセットします。

//emlist{
class PatchPanel < Controller
  def start
    @patch = []
    File.open( "./patch-panel.conf" ).each_line do | each |
      if /^(\d+)\s+(\d+)$/=~ each
        @patch << [ $1.to_i, $2.to_i ]
      end
    end
  end

  # ...
//}

 * @<tt>{@patch} は設定ファイルから読み込んだパッチング情報を入れておくインスタンス変数です。パッチでつなぐポートのペアを要素に持つ配列からなる配列となります。たとえばポート 1 番と 10 番、および 2 番と 11 番をパッチングする設定は @<tt>{[[1,10],[2,11]]} となります。
 * @<tt>{File.open("ファイル名")} はファイルを読み込むメソッドで、続く @<tt>{each_line} は読み込んだファイルの一行一行に対してループ処理するためのイテレータです。つまり、ここでは設定ファイルを一行ずつループで処理しています。一時変数 @<tt>{each} にそれぞれの行の内容が文字列として入ります。
 * 正規表現で設定ファイルの各行 @<tt>{each} をパースします。パッチでつなぐポートのペアを @<tt>{$1} と @<tt>{$2} で取り出し、設定情報 @<tt>{@patch} に @<tt>{<<} で追加していきます。

=== @<tt>{switch_ready} ハンドラ (パッチング)

@<tt>{switch_ready} ハンドラでは、起動してきたスイッチに対してパッチングの設定を書き込みます。

//emlist{
  # ...

  def switch_ready datapath_id
    @patch.each do | port_a, port_b |
      make_patch datapath_id, port_a, port_b
    end
  end

  # ...
//}

 * @<tt>{@patch.each} は @<tt>{start} ハンドラで読み込んだパッチング設定をひとつずつ処理するイテレータです。仮引数は @<tt>{port_a} と @<tt>{port_b} の 2 つで、それぞれに配列の第一と第二要素、つまりパッチでつなぐポート番号がひとつずつ入ります。
 * プライベートメソッド @<tt>{make_patch} がパッチング処理の本体です。起動してきたスイッチの Datapath ID、およびパッチングするポート番号 2 つを引数に取ります。

====[column] 取間先生いわく: イテレータの仮引数はどう名付ける？

イテレータを回すとき、仮引数の名前には何を使うのがいいだろうか？律儀な人は次のように、要素の種類に応じて名前を変えているじゃろう。

//emlist{
# pages に対するイテレータなので、仮引数は page
pages.each do | page |
  page.save
end

# servers に対するイテレータなので、仮引数は server
servers.each do | server |
  server.shutdown!
end
//}

しかし適切な名前付けは、いつもやっかいな問題じゃ。そこでわしは、いつも迷わず @<tt>{each} を使うことにしておる。

//emlist{
pages.each do | each |
  each.save
end

servers.each do | each |
  each.shutdown!
end
//}

実はこれは、Ruby の先祖にあたる古い言語、Smalltalk での流儀なのじゃ。Smalltalk には Ruby に取り入れられることになったイテレータの機能があるが、Smalltalk の達人プログラマは昔から仮引数に @<tt>{each} を使うようにしてきた。これによって名前をあれこれ悩まなくなるし、@<tt>{each.save} などというコードの断片を見ただけで「これはイテレータで回している配列の要素に対する呼び出しだな」と分かる。

こういう Ruby のイディオム、いわゆるベスト・プラクティスは Ruby の先祖となった言語からたくさん学べる。Smalltalk のベスト・プラクティスについては、「Smalltalk ベストプラクティス (ケント・ベック著、ピアソン・エデュケーション)」という本がおすすめじゃ。

====[/column]

=== @<tt>{make_patch} メソッド (Flow Mod)

@<tt>{make_patch} メソッドではパッチング情報をフローエントリとしてスイッチに書き込みます。最初に説明したように、ひとつのパッチングは 2 つのフローエントリになります。つまり、たとえばポート 1 番と 10 番をパッチングしたのであれば、

 1. ポート 1 番へ上がってきたパケットをポート 10 番へ出力する。
 2. ポート 10 番へ上がってきたパケットをポート 1 番へ出力する。

//noindent
の 2 つのフローエントリがスイッチに書き込まれます。

//emlist{
  # ...

  def make_patch datapath_id, port_a, port_b
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_b ),
      :actions => SendOutPort.new( port_a )
    )
  end

  # ...
//}

この @<tt>{make_patch} の中で 2 回呼び出している、@<tt>{send_flow_mod_add} がフローエントリを書き込むためのメソッドです。@<tt>{send_flow_mod_add} メソッドは次の 2 つの引数を取ります。

//emlist{
send_flow_mod_add( datapath_id, options )
//}

それぞれの引数の意味は次の通りです。

 * @<tt>{datapath_id}: Flow Mod メッセージの届け先となるスイッチの Datapath ID です。
 * @<tt>{options}: Flow Mod メッセージの中身を決めるためのオプションで、フローエントリの構成要素であるマッチングルールとアクションに加え、フローエントリの寿命や優先度といった属性を指定します。各オプションにはデフォルト値があるので、必要な属性のみを指定すればいいようになっています。

最初の @<tt>{send_flow_mod_add} を見てみましょう。ここでは、ポート @<tt>{port_a} 番へ上がってきたパケットをポート @<tt>{port_b} 番へ出力するためのフローエントリを書き込んでいます。

//emlist{
  # ...

  def make_patch datapath_id, port_a, port_b
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )

    # ...
//}

 * @<tt>{:match} オプションにはマッチングルールを指定します。ここでは、「入力ポート (@<tt>{:in_port}) が @<tt>{port_a} であった場合」、というマッチングルールを指定した @<tt>{Match} オブジェクトを渡しています。
 * @<tt>{:actions} オプションにはアクションを指定します。ここでは、「ポート @<tt>{port_b} 番へ出力する」という Forward アクションを作る、@<tt>{SendOutPort} オブジェクトを作って指定しています。

このようにフローエントリを追加するには、フローエントリを作るのに必要な要素であるマッチングルールとアクションを指定できます。それぞれの詳しい API を見て行きましょう。

==== マッチングルール

マッチングルールには、@<tt>{:in_port} 以外にも@<chap>{openflow} で紹介した次の 12 種類の条件を指定できます。

#@warn(アクションに関係するクラスの名前に合わせて、以下のオプション名も変更)

: @<tt>{:in_port}
  スイッチの物理ポート番号
: @<tt>{:dl_src}
  送信元 MAC アドレス
: @<tt>{:dl_dst}
  宛先 MAC アドレス
: @<tt>{:dl_type}
  イーサネットの種別
: @<tt>{:nw_src}
  送信元 IP アドレス
: @<tt>{:nw_dst}
  宛先 IP アドレス
: @<tt>{:nw_proto}
  IP のプロトコル種別
: @<tt>{:nw_tos}
  IP の ToS フィールド
: @<tt>{:tp_src}
  TCP/UDP の送信元ポート番号
: @<tt>{:tp_dst}
  TCP/UDP の宛先ポート番号
: @<tt>{:dl_vlan}
  VLAN ID の値
: @<tt>{:dl_vlan_pcp}
  VLAN のプライオティ

それぞれの利用方法は、続くいくつかの章で具体的な使い方を見て行きます。詳しいドキュメントは Trema Ruby API を参照してください。

==== アクション

アクションには @<tt>{SendOutPort} 以外にも、@<chap>{openflow} で紹介した次の 12 種類のアクションを指定できます。

: SendOutPort
  指定したスイッチのポートにパケットを出力します。ポートにはポート番号か、または OpenFlow で規定されている論理ポート (→ @<chap>{openflow}) を指定できます。
: SetEthSrcAddr
  送信元 MAC アドレスを指定した値に書き換えます。
: SetEthDstAddr
  宛先 MAC アドレスを指定した値に書き換えます。
: SetIpSrcAddr
  送信元の IP アドレスを指定した値に書き換えます。
: SetIpDstAddr
  宛先の IP アドレスを指定した値に書き換えます。
: SetIpTos
  IP の ToS フィールドを書き換えます。
: SetTransportSrcPort
  TCP/UDP の送信元ポート番号を書き換えます。
: SetTransportDstPort
  TCP/UDP の宛先ポート番号を書き換えます。
: StripVlanHeader
  VLAN のヘッダを除去します。
: SetVlanVid
  指定された VLAN ID をセットする、または既存のものがあれば書き換えます。
: SetVlanPriority
  指定された VLAN プライオリティをセットする、または既存のものがあれば書き換えます。
: VendorAction
  ベンダ定義のアクションを実行します。

これらの利用方法も、続くいくつかの章で具体的な使い方を見て行きます。詳しいドキュメントは Trema Ruby API を参照してください。

==== @<tt>{send_flow_mod_add} のオプション一覧

マッチングルールとアクションのほか、@<tt>{send_flow_mod_add} では次のオプションを指定できます。

: @<tt>{:idle_timeout}
  フローエントリが一定時間参照されなかった場合に破棄されるまでの秒数を指定します。デフォルトは 0 秒で、この場合フローエントリは破棄されません。
: @<tt>{:hard_timeout}
  フローエントリの寿命を秒数で指定します。デフォルトは 0 秒で、この場合フローエントリは破棄されません。
: @<tt>{:priority}
  フローエントリの優先度 (符号なし 16 ビット、大きいほど優先度高) です。Packet In メッセージはこの優先度順にフローエントリのマッチングルールと照らし合わされます。デフォルトでは 0xffff (最高優先度) です。
: @<tt>{:send_flow_rem}
  タイムアウトでフローエントリが消えるときに、Flow Removed メッセージをコントローラに送るかどうかを指定します。デフォルトで true です。
: @<tt>{:check_overlap}
  true にセットすると、フローテーブルの中に同じ優先度で競合するものがあった場合、フローエントリを追加せずにエラーを起こします。デフォルトは false です。
: @<tt>{:emerg}
  この値を true にセットすると、フローエントリを緊急エントリとして追加します。緊急エントリはスイッチが何らかの障害でコントローラと切断したときにのみ有効となります。デフォルトは false です。
: @<tt>{:cookie}
  任意の用途に使える 64 ビットの整数です。使い道としては、同じクッキー値を持つフローエントリ同士をまとめて管理するなどといった用途があります。

このように Flow Mod にはたくさんのパラメータがありますので、必要なときに立ち戻って参照してください。

== まとめ

フローを使ってパケットを転送する方法の入門編として、OpenFlow で実装したインテリジェントなパッチパネルを書きました。

 * Trema で作ったコントローラを実機の OpenFlow スイッチと接続しました。
 * Ruby プログラミングで多用するイテレータや正規表現を学びました。
 * フローエントリを追加するための @<tt>{send_flow_mod_add} を使って、スイッチのフローテーブルを書き換えました。
 * マッチングルールの作りかたを学びました。
 * Forward アクションによるパケットの転送と、その他のアクションを見ました。

実は、今回作った OpenFlow 版パッチパネルは SDN の一種です。なぜならば、パッチパネルはネットワークの構成をソフトウェアで自由に変更できるツールだからです。@<chap>{openflow_usecases}で紹介したように、パッチパネルを使えばホストの所属するネットワークをソフトウェア的に切り替えられます。これは、物理ネットワークの上にそれぞれ独立したネットワークをいくつも作れるという意味で、最も単純なネットワーク仮想化に他なりません。より高度な仮想化については、@<chap>{sliceable_switch}および@<chap>{datacenter}でも紹介します。

続く章では、Flow Mod に並んで重要な OpenFlow メッセージである、Packet In と Packet Out を使ってみましょう。
