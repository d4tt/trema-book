= インテリジェントなパッチパネル

//lead{
日々のネットワーク管理に役立ち、さらに SDN の入門にもなるのがこの OpenFlow で作るパッチパネルです。その上ソースコードも簡単とくれば、試さない手はありません。
//}

== 便利なインテリジェント・パッチパネル

スイッチやサーバが増えてくると、ネットワークケーブルの配線は悲惨なまでにごちゃごちゃになります。からみあったケーブルのせいで見通しが悪くなるのはもちろん、そのままさらに増築を続けると、最悪の場合は配線のやり直しとなります。こうなってしまう一番の原因は、スイッチやサーバ同士をケーブルで直接つないでしまうことです。これでは、つなぐデバイスを増やせば増やすほどごちゃごちゃになっていくのは当然です。

これを解消するのがパッチパネルという装置です。パッチパネルの仕組みはシンプルで、ケーブルを挿すためのコネクタがずらりと並んでいるだけです。これによって配線をいったんパッチパネルで中継できるので、配線がすっきりし拡張性が向上します (@<img>{patch_panel})。また、うまく設計すると配線の変更をパッチパネルの前面だけで行えるようになるので、メンテナンス性も向上します。

//image[patch_panel][ごちゃごちゃした配線をパッチパネルで中継してすっきりと][scale=0.5]

このパッチパネルを改善し、ネットワーク経由で操作できるようにしたのがいわゆるインテリジェント・パッチパネルです。パッチパネルでメンテナンス性が向上できるとしても、配線を変更するたびにサーバ室まで足を運ぶのはちょっと面倒です。そこで、パッチパネルの配線をネットワーク経由で変更できるようにすることで、さらにメンテナンス性が上がります。

== OpenFlow 版インテリンジェント・パッチパネル

インテリジェント・パッチパネルは OpenFlow を使うと簡単に実装できます。パッチパネルでの中継のように、パケットをコネクタからコネクタへ転送するというのは、フローの代表的な使い方の一つだからです。

OpenFlow で実装したパッチパネルは@<img>{openflow_patch_panel} のようになります。OpenFlow スイッチをパッチパネルに見たてて、接続を中継したいデバイス (ホストまたはスイッチ) をつなげます。コントローラはパケット転送のルールをフローエントリとして OpenFlow スイッチに書き込むことで、仮想的なパッチを作ります。

//image[openflow_patch_panel][OpenFlow で実現したパッチパネルの仕組み][scale=0.5]

たとえば @<img>{openflow_patch_panel} について、ポート 1 番と 4 番につなげたデバイス同士をパッチングしたい場合を考えてください。この場合、必要なフローエントリは次の 2 つです。

 * ポート 1 番に入力したパケットを、ポート 4 番に出力する。
 * ポート 4 番に入力したパケットを、ポート 1 番に出力する。

//noindent
フローエントリを構成する要素には、「こういうパケットが届いたとき」というマッチングルールと、「こうする」というアクションがあるのでした。この場合「ポート x 番に入力」がマッチングルールで、「ポート y 番に出力」がアクションです。

それでは仕組みが分かったところで、さっそくコントローラの実装に進みましょう。

== PatchPanel コントローラ

今回もまずはパッチパネルのソースコード (@<list>{patch-panel.rb}) をざっと眺めることから始めましょう。このソースコードは Trema のサンプルアプリに付属する、@<tt>{patch_panel/patch-panel.rb} でも読めます。

#@warn(Trema のサンプルに patch_panel/ を追加)

//list[patch-panel.rb][パッチパネル (@<tt>{patch-panel.rb}) のソースコード]{
class PatchPanel < Controller
  def start
    @patch = []
    File.open( "./patch-panel.conf" ).each_line do | each |
      if /^(\d+)\s+(\d+)$/=~ each
        @patch << [ $1.to_i, $2.to_i ]
      end
    end
  end


  def switch_ready datapath_id
    @patch.each do | port_a, port_b |
      make_patch datapath_id, port_a, port_b
    end
  end


  ##############################################################################
  private
  ##############################################################################


  def make_patch datapath_id, port_a, port_b
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_b ),
      :actions => SendOutPort.new( port_a )
    )
  end
end
//}

今までに学んだ知識で、まずはこの Ruby ソースコードをできるところまで解読してみましょう。

 * パッチパネルの本体は @<tt>{PatchPanel} という名前の小さなクラスです。
 * このクラスには @<chap>{switch_monitoring_tool}で学んだ @<tt>{switch_ready} ハンドラが定義されており、この中で @<tt>{make_patch} というプライベートメソッドを呼んでいます。どうやらこれがパッチング処理の本体のようです。
 * @<tt>{make_patch} メソッドでは @<tt>{send_flow_mod_add} という Flow Mod メッセージに関連ありそうなメソッドを 2 回呼んでいます。ひとつのパッチは 2 つのフローエントリに対応するので、2 回呼んでいるのだろうと推測できます。

//noindent
ここまで分かればしめたものです。あらかじめパッチパネルの仕組みは分かっていたので、ソースコードを読むのは簡単ですね。

それでは実際に動かして動作イメージをつかんでみましょう。

=== 実行してみよう

パッチパネルは物理的なケーブリングを整理するためのものなので、今回は仮想ネットワークではなく、実機の OpenFlow スイッチを使います。もし実機を持っていない場合には (そういう読者が大半でしょう)、@<chap>{diy_switch}を参考に OpenFlow スイッチの自作に挑戦してみてください。

このパッチパネルでは、どのポート同士をパッチングするかを設定ファイル (@<tt>{patch-panel.conf}) で指定します。たとえば、ポート 1 番と 10 番、およびポート 2 番と 11 番をパッチングする場合には、次の設定ファイルをコントローラのファイル (@<tt>{patch-panel.rb}) と同じディレクトリに置いてください。

//emlist{
1 10
2 11
//}

@<tt>{PatchPanel} コントローラを実行すると、この設定ファイルを読み込み仮想パッチを OpenFlow スイッチに反映します。今回のように実機の OpenFlow スイッチとコントローラを接続するには、次のように @<tt>{-c} オプションなしでコントローラを実行します。これによって、起動したコントローラに実機の OpenFlow スイッチが接続します。

//cmd{
% trema run ./patch-panel.rb
//}

うまく動きましたか？パッチングの設定を変更するには、設定ファイルを書き換え、Ctrl-C でいったん停止させてからふたたび起動してください。とても素朴なツールですが、ちょっとしたネットワークの管理に重宝します。

== 即席 Ruby 入門

それでは、いつものようにパッチパネルのソースコード (@<list>{patch-panel.rb}) で新しく登場した Ruby の文法を覚えましょう。

=== イテレータ

配列などの要素それぞれに対して、ひとつの処理を繰り返すときに使うのがイテレータです。「繰り返す」という動作から分かるように、イテレータはループの一種です。Ruby プログラマは @<tt>{each} という名前で始まるイテレータをたくさん使います。@<tt>{each} つまり「それぞれ」についてある処理を繰り返すのがイテレータだ、と理解すれば覚えやすいでしょう。

次の例は配列 @<tt>{members} の中身をそれぞれ出力するという、イテレータの代表的な使い方です。

//emlist{
members = [ "友太郎", "青井", "宮坂主任" ]
members.each do | name |
  puts name
end

(出力)
友太郎
青井
宮坂主任
//}

//noindent
このコードは、3 つの名前が入った配列に対してイテレータ @<tt>{each} を呼び、それぞれの名前を出力します。@<tt>{do} から @<tt>{end} までの字下げされたブロックが、イテレータで繰り返す処理の中身です。@<tt>{do} の右側の @<tt>{| name |} はこのブロックに渡る仮引数で、配列の各要素である名前が入ります。そしてブロックの中の @<tt>{puts} で、この名前を標準出力に出します。

このコードは、次の C コードと意味が同じです。

//emlist{
for ( i = 0; i < 3; i++ ) {
  puts members[ i ];
}
//}

//noindent
C のコードでは、名前の入った配列 @<tt>{members} の要素を順に処理するために、ループ用の変数 @<tt>{i} を使います。@<tt>{for} で @<tt>{i = 0, 1, 2} とループを回すことで、@<tt>{members} の要素を順に取り出すのです。

Ruby のイテレータは、このループ用変数を使いません。仮引数に順に要素がセットされるので、プログラマはループ変数の初期化やインクリメントを気にせずにループを書けるのです。このようにループをちょっとだけ抽象化したものがイテレータであるとも言えます。

=== 正規表現

Ruby の正規表現は Perl や他の言語の正規表現とほとんど同じで、@<tt>{/pattern/} のようにスラッシュ (@<tt>{/}) でパターンをはさみます。正規表現に文字列をマッチさせるには @<tt>{=~} に続いて文字列を渡します。もしマッチしなかった場合には @<tt>{nil} が返るので、次のように @<tt>{if} の条件に指定することでマッチしたかどうかを判定できます。

//emlist{
if /taura/=~ "restaurant"
  puts "restaurant は taura にマッチ"
end

(出力)
restaurant は taura にマッチ
//}

正規表現で文字列のある部分を取り出したいときには、かっこ @<tt>{()} と変数 @<tt>{$1}、@<tt>{$2}、… を使います。

//emlist{
if /(\d+)\s+Monkeys\s+(\d+)\s+Bananas/=~ "12 Monkeys 1 Bananas"
  puts "猿は #{ $1 } 匹、バナナは #{ $2 } 本"
end

(出力)
猿は 12 匹、バナナは 1 本
//}

このように正規表現がマッチした場合、かっこで囲われた部分にマッチした文字列が先頭から順に @<tt>{$1}、@<tt>{$2}、… にセットされます。このあたりも、他の言語とほとんど同じです。

== PatchPanel コントローラのソースコード解説

新しい Ruby の文法が頭に入ったところで、パッチパネルのソースコードを詳しく見ていきましょう。

=== 設定ファイル (@<tt>{patch-panel.conf}) の読み込み

@<tt>{start} ハンドラでは、設定ファイル (@<tt>{patch-panel.conf}) を読み込み設定情報をインタンス変数 @<tt>{@patch} にセットします。

//emlist{
class PatchPanel < Controller
  def start
    @patch = []
    File.open( "./patch-panel.conf" ).each_line do | each |
      if /^(\d+)\s+(\d+)$/=~ each
        @patch << [ $1.to_i, $2.to_i ]
      end
    end
  end

  # ...
//}

 * @<tt>{@patch} は設定ファイルから読み込んだパッチング情報を入れておくインスタンス変数です。たとえばポート 1 番と 10 番、および 2 番と 11 番をパッチングする場合、この中身は @<tt>{[[1,10],[2,11]]} となります。このように、@<tt>{@patch} はパッチでつなぐポートのペアを要素に持つ配列からなる配列です。
 * @<tt>{File.open("ファイル名")} はファイルを読み込むメソッドで、続く @<tt>{each_line} は読み込んだファイルの一行一行に対してループ処理するためのイテレータです。ここでは設定ファイルの一行ずつ、つまり @<tt>{"1 10"} のようなそれぞれのパッチング設定の文字列を仮引数 @<tt>{each} にセットします。
 * 正規表現で設定ファイルの各行 @<tt>{each} をパースします。パッチでつなぐポートのペアを @<tt>{$1} と @<tt>{$2} で取り出し、@<tt>{[1, 10]} のような配列を作ります。そして、設定情報を持つ配列である @<tt>{@patch} に @<tt>{<<} で追加します。

=== @<tt>{switch_ready} ハンドラ (パッチング)

@<tt>{switch_ready} ハンドラでは、起動してきたスイッチに対してパッチング用のフローエントリを書き込みます。

//emlist{
  # ...

  def switch_ready datapath_id
    @patch.each do | port_a, port_b |
      make_patch datapath_id, port_a, port_b
    end
  end

  # ...
//}

 * @<tt>{@patch.each} は @<tt>{start} ハンドラで読み込んだパッチング設定をひとつずつ処理するイテレータです。仮引数は @<tt>{port_a} と @<tt>{port_b} の 2 つで、それぞれに配列の第一と第二要素、つまりパッチでつなぐポート番号がひとつずつ入ります。
 * プライベートメソッド @<tt>{make_patch} がパッチング処理の本体です。起動してきたスイッチの Datapath ID、およびパッチングするポート番号 2 つを引数に取ります。

====[column] 取間先生いわく: イテレータの仮引数はどう名付ける？

イテレータを回すとき、仮引数の名前には何を使うのがいいだろうか？律義なプログラマは次のように、要素の種類に応じて名前を変えるじゃろう。

//emlist{
# pages に対するイテレータなので、仮引数は page
pages.each do | page |
  page.save
end

# servers に対するイテレータなので、仮引数は server
servers.each do | server |
  server.shutdown!
end
//}

しかし適切な名前付けは、やっかいな問題じゃ。そこでわしは、いつも迷わず @<tt>{each} を使うことにしておる。

//emlist{
pages.each do | each |
  each.save
end

servers.each do | each |
  each.shutdown!
end
//}

実はこれは、Ruby の先祖にあたる古い言語、Smalltalk での流儀なのじゃ。Smalltalk には Ruby に取り入れられることになったイテレータの機能があり、Smalltalk の達人プログラマは昔から仮引数に @<tt>{each} を使うようにしてきた。これによって名前をあれこれ悩まなくなるし、@<tt>{each.save} などというコードの断片を見ただけで「これはイテレータで回している配列の要素に対する呼び出しだな」と分かる。

こういう Ruby のイディオム、いわゆるベスト・プラクティスは Ruby の先祖となった言語からたくさん学べる。Smalltalk のベスト・プラクティスについては、「Smalltalk ベストプラクティス (ケント・ベック著、ピアソン・エデュケーション)」という本がおすすめじゃ。

====[/column]

=== @<tt>{make_patch} メソッド (Flow Mod)

@<tt>{make_patch} メソッドではパッチング情報をフローエントリとしてスイッチに書き込みます。

//emlist{
  # ...

  def make_patch datapath_id, port_a, port_b
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_b ),
      :actions => SendOutPort.new( port_a )
    )
  end

  # ...
//}

最初に説明したように、ひとつのパッチは 2 つのフローエントリになります。@<tt>{make_patch} の中で 2 回呼び出している、@<tt>{send_flow_mod_add} がフローエントリを書き込むためのメソッドです。@<tt>{send_flow_mod_add} メソッドは次の 2 つの引数を取ります。

//emlist{
send_flow_mod_add( datapath_id, options )
//}

それぞれの引数の意味は次の通りです。

 * @<tt>{datapath_id}: Flow Mod メッセージの届け先となるスイッチの Datapath ID です。
 * @<tt>{options}: Flow Mod メッセージの中身を決めるためのオプションです。各オプションにはデフォルト値があるので、必要な属性のみを指定すればいいようになっています。

最初の @<tt>{send_flow_mod_add} の呼び出し部分を見てみましょう。

//emlist{
  # ...

  def make_patch datapath_id, port_a, port_b
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )

    # ...
//}

//noindent
ここでは、ポート @<tt>{port_a} 番へ上がってきたパケットをポート @<tt>{port_b} 番へ出力するためのフローエントリを書き込んでいます。このためには次の 2 つのオプションが必要です。

 * @<tt>{:match} オプションにはマッチングルールを指定します。ここでは、「入力ポート (@<tt>{:in_port}) が @<tt>{port_a} であった場合」、というマッチングルールを指定した @<tt>{Match} オブジェクトを渡しています。
 * @<tt>{:actions} オプションにはアクションを指定します。ここでは、「ポート @<tt>{port_b} 番へ出力する」という Forward アクションを、@<tt>{SendOutPort} クラスで作って指定しています。

このようにフローエントリを追加するには、フローエントリに必要な要素であるマッチングルールとアクションを指定します。それぞれの詳しい API を紹介します。

=== マッチングルール

マッチングルールには、@<tt>{:in_port} 以外にも@<chap>{openflow}で紹介した次の 12 種類の条件を指定できます。

#@warn(アクションに関係するクラスの名前に合わせて、以下のオプション名も変更)

: @<tt>{:in_port}
  スイッチの物理ポート番号
: @<tt>{:dl_src}
  送信元 MAC アドレス
: @<tt>{:dl_dst}
  宛先 MAC アドレス
: @<tt>{:dl_type}
  イーサネットの種別
: @<tt>{:nw_src}
  送信元 IP アドレス
: @<tt>{:nw_dst}
  宛先 IP アドレス
: @<tt>{:nw_proto}
  IP のプロトコル種別
: @<tt>{:nw_tos}
  IP の ToS フィールド
: @<tt>{:tp_src}
  TCP/UDP の送信元ポート番号
: @<tt>{:tp_dst}
  TCP/UDP の宛先ポート番号
: @<tt>{:dl_vlan}
  VLAN ID の値
: @<tt>{:dl_vlan_pcp}
  VLAN のプライオティ

それぞれの利用方法は、続くいくつかの章で具体的な使い方を見て行きます。

=== アクション

アクションには、@<tt>{SendOutPort} 以外にも@<chap>{openflow}で紹介した次の 12 種類のアクションを指定できます。

#@warn(enqueue とかのは？)

: SendOutPort
  指定したスイッチのポートにパケットを出力します。ポートにはポート番号か、または OpenFlow で規定されている論理ポート (→ @<chap>{openflow}) を指定できます。
: SetEthSrcAddr
  送信元 MAC アドレスを指定した値に書き換えます。
: SetEthDstAddr
  宛先 MAC アドレスを指定した値に書き換えます。
: SetIpSrcAddr
  送信元の IP アドレスを指定した値に書き換えます。
: SetIpDstAddr
  宛先の IP アドレスを指定した値に書き換えます。
: SetIpTos
  IP の ToS フィールドを書き換えます。
: SetTransportSrcPort
  TCP/UDP の送信元ポート番号を書き換えます。
: SetTransportDstPort
  TCP/UDP の宛先ポート番号を書き換えます。
: StripVlanHeader
  VLAN のヘッダを除去します。
: SetVlanVid
  指定された VLAN ID をセットする、または既存のものがあれば書き換えます。
: SetVlanPriority
  指定された VLAN プライオリティをセットする、または既存のものがあれば書き換えます。
: VendorAction
  ベンダ定義のアクションを実行します。

まだ使っていないアクションについては、続くいくつかの章で具体的な使い方を見て行きます。

=== @<tt>{send_flow_mod_add} のオプション一覧

最後に捕捉として、@<tt>{send_flow_mod_add} で指定できるすべてのオプションを紹介しておきます。Flow Mod には次のようにたくさんのパラメータがあります。

: @<tt>{:idle_timeout}
  フローエントリが一定時間参照されなかった場合に破棄されるまでの秒数を指定します。デフォルトは 0 秒で、この場合フローエントリは破棄されません。
: @<tt>{:hard_timeout}
  フローエントリの寿命を秒数で指定します。デフォルトは 0 秒で、この場合フローエントリは破棄されません。
: @<tt>{:priority}
  フローエントリの優先度 (符号なし 16 ビット、大きいほど優先度高) です。Packet In メッセージはこの優先度順にフローエントリのマッチングルールと照らし合わされます。デフォルトでは 0xffff (最高優先度) です。
: @<tt>{:send_flow_rem}
  タイムアウトでフローエントリが消えるときに、Flow Removed メッセージをコントローラに送るかどうかを指定します。デフォルトで true です。
: @<tt>{:check_overlap}
  true にセットすると、フローテーブルの中に同じ優先度で競合するものがあった場合、フローエントリを追加せずにエラーを起こします。デフォルトは false です。
: @<tt>{:emerg}
  この値を true にセットすると、フローエントリを緊急エントリとして追加します。緊急エントリはスイッチが何らかの障害でコントローラと切断したときにのみ有効となります。デフォルトは false です。
: @<tt>{:cookie}
  任意の用途に使える 64 ビットの整数です。使い道としては、同じクッキー値を持つフローエントリ同士をまとめて管理するなどといった用途があります。

こうしたオプションも、続くいくつかの章で具体的な使い方を見て行きます。

== まとめ

フローを使ってパケットを転送する方法の入門編として、OpenFlow で実現するインテリジェントなパッチパネルを書きました。

 * Trema で作ったコントローラを、実機の OpenFlow スイッチと接続しました。
 * Ruby プログラミングで多用する、イテレータや正規表現を学びました。
 * フローエントリを追加するための @<tt>{send_flow_mod_add} を使って、スイッチのフローテーブルを書き換えました。
 * マッチングルールの作りかたと、指定できるルールを見ました。
 * Forward アクションによるパケットの転送と、その他のアクションを見ました。

実は、今回作った OpenFlow 版パッチパネルは SDN の一種です。なぜならば、パッチパネルはネットワークの構成をソフトウェアで自由に変更できるツールだからです。@<chap>{openflow_usecases}で紹介したように、パッチパネルを使えばホストの所属するネットワークをソフトウェア的に切り替えられます。これは、物理ネットワークの上にそれぞれ独立したネットワークをいくつも作れるという意味で、最も単純なネットワーク仮想化に他なりません。より高度な仮想化については、@<chap>{sliceable_switch}および@<chap>{datacenter}でも紹介します。

続く章では、Flow Mod に並んで重要な OpenFlow メッセージである、Packet In と Packet Out を使ってみましょう。
