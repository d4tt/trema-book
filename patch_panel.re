= インテリジェントなパッチパネル

//lead{
日々のネットワーク管理に役立ち、さらに SDN の入門にもなるのがこの OpenFlow で作るパッチパネルです。その上ソースコードも簡単とくれば、試さない手はありません。
//}

//indepimage[cables][][width=10cm]

== 便利なインテリジェント・パッチパネル

無計画にスイッチやサーバを増やしてしまうと、ネットワークケーブルの配線は悲惨なまでにごちゃごちゃになります。からみあったケーブルのせいで見通しが悪くなるのはもちろん、そのままさらに増築を続けると、最悪の場合は配線のやり直しとなります。こうなってしまう一番の原因は、スイッチやサーバ同士をケーブルで直接つないでしまうことです。これでは、つなぐデバイスを増やせば増やすほどごちゃごちゃになっていくのは当然です。

これを解消するのがパッチパネルという装置です。パッチパネルの仕組みはシンプルで、ケーブルを挿すためのコネクタがずらりと並んでいるだけです。これによって配線をいったんパッチパネルで中継できるので、配線がすっきりし拡張性が向上します(@<img>{patch_panel})。また、うまく設計すると配線の変更をパッチパネルの前面だけで行えるようになるので、メンテナンス性も向上します。

//image[patch_panel][ごちゃごちゃした配線をパッチパネルで中継してすっきりと][width=12cm]

このパッチパネルを改善し、ネットワーク経由で操作できるようにしたのがいわゆるインテリジェント・パッチパネルです。パッチパネルでメンテナンス性が向上できるとしても、配線を変更するたびにサーバ室まで足を運ぶのはちょっと面倒です。そこで、パッチパネルの配線をネットワーク経由で変更できるようにすることで、さらにメンテナンス性が上がります。

== OpenFlow版インテリンジェント・パッチパネル

インテリジェント・パッチパネルはOpenFlowを使うと簡単に実装できます。パッチパネルでの中継のように、パケットをコネクタからコネクタへ転送するというのは、フローの代表的な使い方の一つだからです。

OpenFlowで実装したパッチパネルは@<img>{openflow_patch_panel}のようになります。OpenFlowスイッチをパッチパネルに見たてて、接続を中継したいデバイス(ホストまたはスイッチ)をつなげます。コントローラはパケット転送のルールをフローエントリとしてOpenFlowスイッチに書き込むことで、仮想的なパッチを作ります。

//image[openflow_patch_panel][OpenFlowで実現したパッチパネルの仕組み][width=12cm]

たとえば@<img>{openflow_patch_panel}について、ポート1番と4番につなげたデバイス同士をパッチングしたい場合を考えてください。この場合、必要なフローエントリは次の2つです。

 * ポート1番に入力したパケットを、ポート4番に出力する
 * ポート4番に入力したパケットを、ポート1番に出力する

//noindent
フローエントリを構成する要素には、「こういうパケットが届いたとき」というマッチングルールと、「こうする」というアクションがあるのでした。この場合「ポートx番に入力」がマッチングルールで、「ポートy番に出力」がアクションです。

それでは仕組みが分かったところで、さっそくコントローラの実装に進みましょう。

== PatchPanelコントローラ

今回もまずはパッチパネルのソースコード(@<list>{patch-panel.rb})をざっと眺めることから始めましょう。このソースコードはTremaのサンプルアプリに付属する、@<tt>{patch_panel/patch-panel.rb}でも読めます。

#@warn(Trema のサンプルに patch_panel/ を追加)

//list[patch-panel.rb][パッチパネル(@<tt>{patch-panel.rb})のソースコード]{
class PatchPanel < Controller
  def start
    @patch = []
    File.open( "./patch-panel.conf" ).each_line do | each |
      if /^(\d+)\s+(\d+)$/=~ each
        @patch << [ $1.to_i, $2.to_i ]
      end
    end
  end


  def switch_ready( datapath_id )
    @patch.each do | port_a, port_b |
      make_patch datapath_id, port_a, port_b
    end
  end


  private


  def make_patch( datapath_id, port_a, port_b )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_b ),
      :actions => SendOutPort.new( port_a )
    )
  end
end
//}

今までに学んだ知識で、まずはこのRubyソースコードをできるところまで解読してみましょう。

 * パッチパネルの本体は@<tt>{PatchPanel}という名前の小さなクラスである
 * このクラスには@<chap>{switch_monitoring_tool}で学んだ@<tt>{switch_ready}ハンドラが定義されており、この中で@<tt>{make_patch}というプライベートメソッドを呼んでいる。どうやらこれがパッチング処理の本体と推測できる
 * @<tt>{make_patch}メソッドでは@<tt>{send_flow_mod_add}というFlow Modメッセージに関連ありそうなメソッドを2回呼んでいる。1つのパッチは2つのフローエントリに対応するので、2回呼んでいるのだろうと推測できる

//noindent
ここまで分かればしめたものです。あらかじめパッチパネルの仕組みは分かっていたので、ソースコードを読むのは簡単ですね。

それでは実際に動かして動作イメージをつかんでみましょう。

=== 実行してみよう

パッチパネルは物理的なケーブリングを整理するためのものなので、今回は仮想ネットワークではなく、実機のOpenFlowスイッチを使います。もし実機を持っていない場合には(そういう読者が大半でしょう)、@<chap>{diy_switch}を参考にOpenFlowスイッチの自作に挑戦してみてください。

このパッチパネルでは、どのポート同士をパッチングするかを設定ファイル(@<tt>{patch-panel.conf})で指定します。たとえば、ポート1番と10番、およびポート2番と11番をパッチングする場合には、次の設定ファイルをコントローラのファイル(@<tt>{patch-panel.rb})と同じディレクトリに置いてください。

//emlist{
1 10
2 11
//}

@<tt>{PatchPanel}コントローラを実行すると、この設定ファイルを読み込み仮想パッチをOpenFlowスイッチに反映します。今回は実機のOpenFlowスイッチを使うので、仮想ネットワーク機能は使いません。そのため、次のように@<tt>{-c}オプションなしでコントローラを実行します。これによって、コントローラだけが起動し、実機のOpenFlowスイッチが接続するのを待ちます。なおスイッチの設定は、Tremaを実行するホストのポート6633番に接続するようにしておいてください。

//cmd{
% trema run ./patch-panel.rb
//}

うまく動きましたか？パッチングの設定を変更するには、設定ファイルを書き換え、Ctrl-Cでいったん停止させてからふたたび起動してください。とても素朴なツールですが、ちょっとしたネットワークの管理に重宝します。

== 即席Ruby入門

それでは、いつものようにパッチパネルのソースコード(@<list>{patch-panel.rb})で新しく登場したRubyの文法を覚えましょう。

=== イテレータ

配列などの要素それぞれに対して、1つの処理を繰り返すときに使うのがイテレータです。「繰り返す」という動作から分かるように、イテレータはループの一種です。Rubyプログラマは@<tt>{each}という名前で始まるイテレータをたくさん使います。@<tt>{each}つまり「それぞれ」についてある処理を繰り返すのがイテレータだ、と理解すれば覚えやすいでしょう。

次の例は配列@<tt>{members}の中身をそれぞれ出力するという、イテレータの代表的な使い方です。

//emlist{
members = [ "友太郎", "青井", "宮坂主任" ]
members.each do | name |
  puts name
end

(出力)
友太郎
青井
宮坂主任
//}

//noindent
このコードは、3つの名前が入った配列に対してイテレータ@<tt>{each}を呼び、それぞれの名前を出力します。@<tt>{do}から@<tt>{end}までの字下げされたブロックが、イテレータで繰り返す処理の中身です。@<tt>{do}の右側の@<tt>{| name |}はこのブロックに渡る仮引数で、配列の各要素である名前が入ります。そしてブロックの中の@<tt>{puts}で、この名前を標準出力に出します。

このコードは、次のCコードと意味が同じです。

//emlist{
for ( i = 0; i < 3; i++ ) {
  puts members[ i ];
}
//}

//noindent
Cのコードでは、名前の入った配列@<tt>{members}の要素を順に処理するために、ループ用の変数@<tt>{i}を使います。@<tt>{for}で@<tt>{i = 0, 1, 2}とループを回すことで、@<tt>{members}の要素を順に取り出すのです。

Rubyのイテレータは、このループ用変数を使いません。仮引数に順に要素がセットされるので、プログラマはループ変数の初期化やインクリメントを気にせずにループを書けるのです。このようにループをちょっとだけ抽象化したものがイテレータであるとも言えます。

=== 正規表現

Rubyの正規表現はPerlや他の言語の正規表現とほとんど同じで、@<tt>{/pattern/}のようにスラッシュ(@<tt>{/})でパターンをはさみます。正規表現に文字列をマッチさせるには@<tt>{=~}に続いて文字列を渡します。もしマッチしなかった場合には@<tt>{nil}が返るので、次のように@<tt>{if}の条件に指定することでマッチしたかどうかを判定できます。

//emlist{
if /taura/=~ "restaurant"
  puts "restaurantはtauraにマッチ"
end

(出力)
restaurantはtauraにマッチ
//}

正規表現で文字列のある部分を取り出したいときには、かっこ@<tt>{()}と変数@<tt>{$1}、@<tt>{$2}、…を使います。

//emlist{
if /(\d+)\s+Monkeys\s+(\d+)\s+Bananas/=~ "12 Monkeys 1 Bananas"
  puts "猿は#{ $1 }匹、バナナは#{ $2 }本"
end

(出力)
猿は12匹、バナナは1本
//}

このように正規表現がマッチした場合、かっこで囲われた部分にマッチした文字列が先頭から順に @<tt>{$1}、@<tt>{$2}、… にセットされます。このあたりも、他の言語とほとんど同じです。

== PatchPanel コントローラのソースコード

新しいRubyの文法が頭に入ったところで、パッチパネルのソースコードを詳しく見ていきましょう。

=== 設定ファイル(@<tt>{patch-panel.conf})の読み込み

@<tt>{start}ハンドラでは、設定ファイル(@<tt>{patch-panel.conf})を読み込み設定情報をインタンス変数@<tt>{@patch}にセットします。

//emlist{
class PatchPanel < Controller
  def start
    @patch = []
    File.open( "./patch-panel.conf" ).each_line do | each |
      if /^(\d+)\s+(\d+)$/=~ each
        @patch << [ $1.to_i, $2.to_i ]
      end
    end
  end

  # ...
//}

 * @<tt>{@patch}は設定ファイルから読み込んだパッチング情報を入れておくインスタンス変数。たとえばポート1番と10番、および2番と11番をパッチングする場合、この中身は@<tt>{[[1,10],[2,11]]}となる。このように、@<tt>{@patch}はパッチでつなぐポートのペアを要素に持つ配列からなる配列である
 * @<tt>{File.open("ファイル名")}はファイルを読み込むメソッドで、続く@<tt>{each_line}は読み込んだファイルの一行一行に対してループ処理するためのイテレータ。ここでは設定ファイルの一行ずつ、つまり@<tt>{"1 10"}のようなそれぞれのパッチング設定の文字列を仮引数@<tt>{each}にセットする
 * 正規表現で設定ファイルの各行@<tt>{each}をパースする。パッチでつなぐポートのペアを@<tt>{$1}と@<tt>{$2}で取り出し、@<tt>{[1, 10]}のような配列を作る。そして、設定情報を持つ配列である@<tt>{@patch}に@<tt>{<<}で追加する。

=== @<tt>{switch_ready}ハンドラ(パッチング)

@<tt>{switch_ready}ハンドラでは、起動してきたスイッチに対してパッチング用のフローエントリを書き込みます。

//emlist{
  # ...

  def switch_ready( datapath_id )
    @patch.each do | port_a, port_b |
      make_patch datapath_id, port_a, port_b
    end
  end

  # ...
//}

 * @<tt>{@patch.each}は@<tt>{start}ハンドラで読み込んだパッチング設定をひとつずつ処理するイテレータ。仮引数は@<tt>{port_a}と@<tt>{port_b}の2つで、それぞれに配列の第一と第二要素、つまりパッチでつなぐポート番号がひとつずつ入る。
 * プライベートメソッド@<tt>{make_patch}がパッチング処理の本体。起動してきたスイッチのDatapath ID、およびパッチングするポート番号2つを引数に取る。

====[column] 取間先生曰く：イテレータの仮引数は@<tt>{each}にしよう

イテレータを回すとき、仮引数の名前には何を使うのがよいでしょうか？律義なプログラマはたとえば次のように、要素の種類に応じて名前を変えているでしょう。

//emlist{
# pages に対するイテレータなので、仮引数は page
pages.each do | page |
  page.save
end

# servers に対するイテレータなので、仮引数は server
servers.each do | server |
  server.shutdown!
end
//}

しかし適切な名前付けは、やっかいな問題です。私の場合は、いつも迷わず@<tt>{each}を使うことにしています。

//emlist{
pages.each do | each |
  each.save
end

servers.each do | each |
  each.shutdown!
end
//}

実はこれは、Rubyの先祖にあたる古い言語、Smalltalkでの流儀です。SmalltalkにはRubyにも取り入れられたイテレータの機能があり、Smalltalkの達人プログラマは昔から仮引数に@<tt>{each}を使うようにしてきました。これによって名前をあれこれ悩まなくなりますし、@<tt>{each.save}などというコードの断片を見ただけで「これはイテレータで回している配列の要素に対する呼び出しだな」と分かります。

こういうよく使うイディオム、いわゆるベスト・プラクティスはRubyの先祖となった言語からたくさん学べます。Smalltalkのベスト・プラクティスについては、『Smalltalkベストプラクティス』(Kent Beck著／ピアソン・エデュケーション)がおすすめです。

====[/column]

=== @<tt>{make_patch}メソッド(Flow Mod)

@<tt>{make_patch}メソッドではパッチング情報をフローエントリとしてスイッチに書き込みます。

//emlist{
  # ...

  def make_patch( datapath_id, port_a, port_b )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_b ),
      :actions => SendOutPort.new( port_a )
    )
  end

  # ...
//}

最初に説明したように、1つのパッチは2つのフローエントリになります。@<tt>{make_patch}の中で2回呼び出している、@<tt>{send_flow_mod_add}がフローエントリを書き込むためのメソッドです。@<tt>{send_flow_mod_add}メソッドは次の2つの引数を取ります。

//emlist{
send_flow_mod_add( datapath_id, options )
//}

それぞれの引数の意味は次の通りです。

 * @<tt>{datapath_id}：Flow Modメッセージの届け先となるスイッチのDatapath ID
 * @<tt>{options}：Flow Modメッセージの中身を決めるためのオプション

オプションの具体例として、最初の@<tt>{send_flow_mod_add}の呼び出し部分を見てみましょう。

//emlist{
  # ...

  def make_patch( datapath_id, port_a, port_b )
    send_flow_mod_add(
      datapath_id,
      :match => Match.new( :in_port => port_a ),
      :actions => SendOutPort.new( port_b )
    )

    # ...
//}

//noindent
ここでは、ポート@<tt>{port_a}番へ上がってきたパケットをポート@<tt>{port_b}番へ出力するためのフローエントリを書き込んでいます。このためには次の2つのオプションが必要です。

 * @<tt>{:match}オプションにはマッチングルールを指定する。ここでは、「入力ポート(@<tt>{:in_port})が@<tt>{port_a}であった場合」、というマッチングルールを指定した@<tt>{Match}オブジェクトを渡している
 * @<tt>{:actions}オプションにはアクションを指定する。ここでは、「ポート@<tt>{port_b}番へ出力する」というForwardアクションを、@<tt>{SendOutPort}クラスで作って指定している

このようにフローエントリを追加するには、フローエントリに必要な要素であるマッチングルールとアクションを指定します。それぞれの詳しいAPIを紹介します。

=== マッチングルール

マッチングルールには、@<tt>{:in_port}以外にも@<chap>{openflow_spec}で紹介した次の12種類の条件を指定できます。

#@warn(アクションに関係するクラスの名前に合わせて、以下のオプション名も変更)

: @<tt>{:in_port}
  スイッチの物理ポート番号
: @<tt>{:dl_src}
  送信元MACアドレス
: @<tt>{:dl_dst}
  宛先MACアドレス
: @<tt>{:dl_type}
  イーサネットの種別
: @<tt>{:nw_src}
  送信元IPアドレス
: @<tt>{:nw_dst}
  宛先IPアドレス
: @<tt>{:nw_proto}
  IPのプロトコル種別
: @<tt>{:nw_tos}
  IPのToSフィールド
: @<tt>{:tp_src}
  TCP/UDPの送信元ポート番号
: @<tt>{:tp_dst}
  TCP/UDPの宛先ポート番号
: @<tt>{:dl_vlan}
  VLAN IDの値
: @<tt>{:dl_vlan_pcp}
  VLANのプライオティ

それぞれの利用方法は、続くいくつかの章で具体的な使い方を見て行きます。

=== アクション

アクションには、@<tt>{SendOutPort}以外にも@<chap>{openflow_spec}で紹介した次の12種類のアクションを指定できます。

#@warn(enqueue とかのは？)

: SendOutPort
  指定したスイッチのポートにパケットを出力する。ポートにはポート番号か、またはOpenFlowで規定されている論理ポート(@<chap>{openflow_spec}参照)を指定できる
: SetEthSrcAddr
  送信元MACアドレスを指定した値に書き換える
: SetEthDstAddr
  宛先MACアドレスを指定した値に書き換える
: SetIpSrcAddr
  送信元のIPアドレスを指定した値に書き換える
: SetIpDstAddr
  宛先のIPアドレスを指定した値に書き換える
: SetIpTos
  IPのToSフィールドを書き換える
: SetTransportSrcPort
  TCP/UDPの送信元ポート番号を書き換える
: SetTransportDstPort
  TCP/UDPの宛先ポート番号を書き換える
: StripVlanHeader
  VLANのヘッダを除去する
: SetVlanVid
  指定したVLAN IDをセットする、または既存のものがあれば書き換える
: SetVlanPriority
  指定したVLAN プライオリティをセットする、または既存のものがあれば書き換える
: VendorAction
  ベンダ定義のアクションを実行する

まだ使っていないアクションについては、続くいくつかの章で具体的な使い方を見て行きます。

=== @<tt>{send_flow_mod_add}のオプション一覧

最後に捕捉として、@<tt>{send_flow_mod_add}で指定できるすべてのオプションを紹介しておきます。Flow Modには次のようにたくさんのパラメータがあります。

: @<tt>{:match}
  フローエントリのマッチングルールを指定する。本章で紹介した@<tt>{Match}オブジェクトまたは@<tt>{ExactMatch}オブジェクト(@<chap>{learning_switch}で紹介)を指定する
: @<tt>{:actions}
  フローエントリのアクションを指定する。アクションはアクションの配列または単体で指定できる
: @<tt>{:idle_timeout}
  フローエントリが一定時間参照されなかった場合に破棄されるまでの秒数を指定する。デフォルトは0秒で、この場合フローエントリは破棄されない
: @<tt>{:hard_timeout}
  フローエントリの寿命を秒数で指定する。デフォルトは0秒で、この場合フローエントリは破棄されない
: @<tt>{:priority}
  フローエントリの優先度(符号なし16ビット、大きいほど優先度高)。Packet Inメッセージはこの優先度順にフローエントリのマッチングルールと照らし合わされる(デフォルでは0xffff(最高優先度))
: @<tt>{:send_flow_rem}
  タイムアウトでフローエントリが消えるときに、Flow Removedメッセージをコントローラに送るかどうかを指定する(デフォルトは@<tt>{true})
: @<tt>{:check_overlap}
  @<tt>{true}にセットすると、フローテーブルの中に同じ優先度で競合するものがあった場合、フローエントリを追加せずにエラーを起こす(デフォルトは@<tt>{false})
: @<tt>{:emerg}
  この値を@<tt>{true}にセットすると、フローエントリを緊急エントリとして追加する。緊急エントリはスイッチが何らかの障害でコントローラと切断したときにのみ有効となる(デフォルトは@<tt>{false})
: @<tt>{:cookie}
  任意の用途に使える 64 ビットの整数。使い道としては、同じクッキー値を持つフローエントリ同士をまとめて管理するなどといった用途がある

こうしたオプションも、続くいくつかの章で具体的な使い方を見て行きます。

== まとめ

フローを使ってパケットを転送する方法の入門編として、OpenFlowで実現するインテリジェントなパッチパネルを書きました。

 * Tremaで作ったコントローラを、実機のOpenFlowスイッチと接続した
 * Rubyプログラミングで多用する、イテレータや正規表現を学んだ
 * フローエントリを追加するための@<tt>{send_flow_mod_add}を使って、スイッチのフローテーブルを書き換えた
 * マッチングルールの作りかたと、指定できるルールを学んだ
 * Forwardアクションによるパケットの転送と、その他のアクションを学んだ

実は、今回作ったOpenFlow版パッチパネルはSDNの一種です。なぜならば、パッチパネルはネットワークの構成をソフトウェアで自由に変更できるツールだからです。@<chap>{openflow_usecases}で紹介したように、パッチパネルを使えばホストの所属するネットワークをソフトウェア的に切り替えられます。これは、物理ネットワークの上にそれぞれ独立したネットワークをいくつも作れるという意味で、最も単純なネットワーク仮想化に他なりません。より高度な仮想化については、@<chap>{sliceable_switch}および@<chap>{datacenter_wakame}でも紹介します。

続く章では、Flow Modに並んで重要なOpenFlowメッセージである、Packet InとPacket Outを使ってみましょう。
