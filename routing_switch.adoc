= たくさんのスイッチを制御する
:sourcedir: vendor/routing_switch
:imagesdir: images/routing_switch

大規模なネットワークを構成するたくさんのスイッチを連携させ、うまく制御する仕組みを見て行きましょう。

== 複数のスイッチを制御する

たくさんの OpenFlow スイッチがつながった環境では、パケットを目的地まで転送するためにスイッチを連携させる必要があります。複数の OpenFlow スイッチを連携し 1 台の大きな仮想スイッチにするコントローラが、本章で紹介するルーティングスイッチです (<<fig_routing_switch,図 15-1>>)。同じスイッチ機能を提供するコントローラとしては、<<learning_switch,第 6 章>>や<<learning_switch13,第 7 章>>で紹介したラーニングスイッチがありました。ラーニングスイッチとルーティングスイッチの大きな違いは、連携できるスイッチの台数です。ラーニングスイッチは OpenFlow スイッチを独立した 1 台のスイッチとして扱います。一方で、ルーティングスイッチは複数の OpenFlow スイッチを連携させることで、仮想的な 1 台のスイッチとして扱います。

[[fig_routing_switch]]
image::routing_switch.png[caption="図15-1",title="ルーティングスイッチはたくさんの OpenFlow スイッチを連携し 1 台の仮想スイッチとして動作させる"]

注意すべきは、ルーティングスイッチはルータではなく、あくまでスイッチであるという点です。**ルーティング**スイッチという名前は、複数のOpenFlowスイッチを経由し、まさにルーティングするようにパケットを転送することから来ています。このようにスイッチ機能を実現するという点では、ラーニングスイッチとの機能的な違いはありません。ただし制御できるネットワーク規模においては、ルーティングスイッチは複数の OpenFlow スイッチを扱えるという違いがあります。

=== ルーティングスイッチの動作

ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転送が複雑になります。宛先のホストまでいくつものスイッチを経由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指示してやる必要があります。

[[routing_switch_flow_mod]]
image::routing_switch_flow_mod.png[caption="図15-2",title="最短パスでパケットを転送するフローエントリを書き込む"]

たとえば<<routing_switch_flow_mod,図15-2>>において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみましょう。もしパケットを最短のパスで届けたい場合、ホスト 1 → スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローエントリを最短パス上のスイッチ 1, 5, 6 へそれぞれ書き込みます。

このとき、実際にルーティングスイッチとスイッチ間でやりとりする OpenFlow メッセージは<<routing_switch_packetin_flowmod_packetout,図 15-3>>のようになります:

1. ホスト 1 がホスト 4 宛てにパケットを送信すると、ルーティングスイッチはこのパケットを Packet In としてスイッチ 1 から受け取る (この Packet In の in_port をポート s とする)
2. ルーティングスイッチはあらかじめ収集しておいたトポロジ情報 (<<topology,第14章>>) を検索し、宛先のホスト 4 が接続するスイッチ (スイッチ 6) とポート番号 (ポート g とする) を得る
3. ポート s から宛先のポート g までの最短パスをトポロジ情報から計算する。その結果、ポート s → スイッチ 1 → スイッチ 5 → スイッチ 6 → ポート g というパスを得る
4. この最短パスに沿ってパケットを転送するフローエントリを書き込むために、ルーティングスイッチはパス上のスイッチそれぞれに Flow Mod を送る
5. Packet In を起こしたパケットを宛先に送るために、ルーティングスイッチはスイッチ 6 に Packet Out (ポート g) を送る

[[routing_switch_packetin_flowmod_packetout]]
image::routing_switch_packetin_flowmod_packetout.png[caption="図15-3",title="ルーティングスイッチでパケットを送信したときの OpenFlow メッセージ"]

ここで使っている OpenFlow メッセージはいずれも、今まで使ってきた Packet In や Flow Mod, Packet Out などおなじみの物ばかりです。ステップ 3 で新たに登場した、最短パスの計算方法を詳しく見て行きましょう。

=== 最短パスを計算する

最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短路を求める汎用アルゴリズムの 1 つで、カーナビの経路検索や鉄道の乗換案内などにも使われています。

ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のとおりです。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、見つかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、 4 ホップ……というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します。footnote:[ダイクストラ法はリンクに重み（距離）がある場合の最短路を求めることができるので、実際にはもう少し複雑な手順になります。ネットワーク上の最短パスではそれぞれのリンクは“重み1”として考えるので、このように単純化できます。]

[[dijkstra]]
image::dijkstra.png[caption="図15-4",title="最短パスをダイクストラ方で計算する"]

実際に<<routing_switch_flow_mod,図 15-2>>のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ方で探索する手順は<<dijkstra,図 15-4>>のようになります:

1. 始点となるスイッチ 1 を 0 ホップとする
2. スイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ 1 から出るリンクの先に繋がっているスイッチ 2, 4, 5 である
3. 同様にステップ 2 で見つかったスイッチから 1 ホップで行けるすべてのスイッチを探し、スイッチ 3, 6 が見つかる。これらは始点からのホップ数が 2 のスイッチである
4. ステップ 3 でゴールのスイッチ 6 が見つかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 とわかる

// TODO (dijkstra.rb の実装をここで解説する？)

== 実行してみよう

動作原理が分かったところで、実際のトポロジ検出や最短路計算の動作をルーティングスイッチを起動し確認してみましょう。ルーティングスイッチは他のサンプルと同様、GitHub で公開しています。次のコマンドでソースコードを取得してください。

----
$ git clone https://github.com/trema/routing_switch.git
----

依存する gem のインストールは、いつも通り `bundle install` コマンドです。

----
$ cd routing_switch
$ bundle install --binstubs
----

これで準備は完了です。

=== ルーティングスイッチを動かす

それでは、ルーティングスイッチを動かしてみましょう。Trema のネットワークエミュレータ機能を用いて、<<routing_switch_sample_network,図 15-5>>のネットワークを作ります。

[[routing_switch_sample_network]]
image::routing_switch_sample_network.png[caption="図15-5",title="ホスト 4 台、スイッチ 6 台からなるネットワーク"]

この構成を実現する設定ファイルは、ルーティングスイッチのソースツリーの中に含まれています (`trema.conf`)。この設定ファイルを指定して、次のようにルーティングスイッチを起動します。

----
$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf
----

// === トポロジを表示する
// ルーティングスイッチが使う Topology は、現在のトポロジ情報を Graphviz で次のようなファイルを作ります。

// 図: Topology が作ったトポロジ図

// 図 ?-? と比較すると、スイッチ間のリンクがうまく検出できていることがわかります。しかし、仮想ホストとスイッチ間のリンクは検出できていません。LLDP と OpenFlow によるトポロジ検出は、あくまでスイッチ間のリンクを検出する仕組みだからです。

=== 最短パスを通すフローエントリを確認する

次に host1 と host4 の間でパケットを送受信し、最短パスを通すフローエントリがうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行っていないので、host1 から host4 へとパケットを送っただけではフローエントリは設定されません。ラーニングスイッチと同じく、次のように両方向でパケットを送った段階でフローエントリが設定されます。

----
$ ./bin/trema send_packets --source host1 --dest host4
$ ./bin/trema send_packets --source host4 --dest host1
$ ./bin/trema send_packets --source host1 --dest host4
----

すると、ルーティングスイッチを起動したターミナルには host4 → host1 と host1 → host4 の 2 つの最短パスを発見した、というメッセージが表示されているはずです。

----
Creating path: 44:44:44:44:44:44 -> 0x6:1 -> 0x6:2 -> 0x5:5 -> 0x5:2 -> 0x1:4 -> 0x1:1 -> 11:11:11:11:11:11
Creating path: 11:11:11:11:11:11 -> 0x1:1 -> 0x1:4 -> 0x5:2 -> 0x5:5 -> 0x6:2 -> 0x6:1 -> 44:44:44:44:44:44
----

実際にどのようなフローエントリが設定されたか見てみましょう。フローエントリの確認は `trema dump_flows` コマンドです。まずは host1 から host4 への最短パスである switch1, switch5, switch6 のフローテーブルをそれぞれ見てみましょう。

----
$ ./bin/trema dump_flows switch1
cookie=0x0, duration=8.949s, table=0, n_packets=0, n_bytes=0, idle_age=8, priority=65535,udp,in_port=4,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1
cookie=0x0, duration=4.109s, table=0, n_packets=0, n_bytes=0, idle_age=4, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:4
$ ./bin/trema dump_flows switch5
cookie=0x0, duration=14.230s, table=0, n_packets=0, n_bytes=0, idle_age=14, priority=65535,udp,in_port=5,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
cookie=0x0, duration=9.320s, table=0, n_packets=0, n_bytes=0, idle_age=9, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:5
$ ./bin/trema dump_flows switch6
cookie=0x0, duration=18.688s, table=0, n_packets=0, n_bytes=0, idle_age=18, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
cookie=0x0, duration=13.723s, table=0, n_packets=0, n_bytes=0, idle_age=13, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1
----

たしかに switch1, switch5, switch6 それぞれについて、host1 と host4 間の 2 つの最短パス用のフローエントリが設定されています。

一方で、最短パス上にない switch2, switch3, switch4 はパケットが通らないため、次のようにフローエントリがありません。

----
$ ./bin/trema dump_flows switch2

$ ./bin/trema dump_flows switch3

$ ./bin/trema dump_flows switch4

----

=== 最短パスの再計算を確認する

トポロジが変化した場合、ルーティングスイッチは自動的に最短パスを作り直します。たとえば<<routing_switch_sample_network,図 15-5>> において、switch1 と switch5 の間のリンクが切れた場合を考えます。このときルーティングスイッチは古い最短パス (host1 ⇔ switch1 ⇔ switch5 ⇔ switch6 ⇔ host4) のフローエントリを消し、新たな最短パス (host1 ⇔ switch1 ⇔ switch4 ⇔ switch5 ⇔ switch6) のフローエントリを追加します (<<routing_switch_update_shortest_path, 図 15-6>>)。

[[routing_switch_update_shortest_path]]
image::routing_switch_update_shortest_path.png[caption="図15-6",title="トポロジの変化に応じて最短パスを作り直す"]

この動作も実際に動かして確認してみましょう。リンクの削除は `trema delete_link` コマンドです。

----
$ ./bin/trema delete_link switch1 switch5
----

すると、ルーティングスイッチを起動したターミナルには host1 ⇔ host4 の 2 つの最短パスを削除し、新たに最短パスを作りなおしたというメッセージが表示されます。

----
Deleting path: 44:44:44:44:44:44 -> 0x6:1 -> 0x6:2 -> 0x5:5 -> 0x5:2 -> 0x1:4 -> 0x1:1 -> 11:11:11:11:11:11
Creating path: 44:44:44:44:44:44 -> 0x6:1 -> 0x6:2 -> 0x5:5 -> 0x5:4 -> 0x4:3 -> 0x4:2 -> 0x1:3 -> 0x1:1 -> 11:11:11:11:11:11
Deleting path: 11:11:11:11:11:11 -> 0x1:1 -> 0x1:4 -> 0x5:2 -> 0x5:5 -> 0x6:2 -> 0x6:1 -> 44:44:44:44:44:44
Creating path: 11:11:11:11:11:11 -> 0x1:1 -> 0x1:3 -> 0x4:2 -> 0x4:3 -> 0x5:4 -> 0x5:5 -> 0x6:2 -> 0x6:1 -> 44:44:44:44:44:44
----

以上でルーティングスイッチの最短パス計算と再計算の動作を見てきました。いよいよ実装に移りましょう。

== ルーティングスイッチのソースコード

ルーティングスイッチは次の 4 つのクラスが協調して動作します (<<routing_switch_architecture,図15-7>>)。

- RoutingSwitch クラス: OpenFlow メッセージの振り分け
- Topology クラス (<<topology,第14章>>で紹介): トポロジ情報を PathManager へ送る
- PathManager クラス: 最短パスの作成と更新を Path に指示
- Path クラス: パスを構成するフローエントリの生成と削除

[[routing_switch_architecture]]
image::routing_switch_architecture.png[caption="図15-7",title="ルーティングスイッチのクラス構成"]

RoutingSwitch クラスの主な仕事は OpenFlow メッセージの振り分けです。OpenFlow スイッチと接続し、スイッチから上がってくる OpenFlow メッセージをその種類に応じて Topology または PathManager へと振り分けます。

Topology コントローラは、トポロジ情報の変化に関連する OpenFlow メッセージを RoutingSwitch コントローラから受け取ります。そしてこの受け取った OpenFlow メッセージをネットワークトポロジ上のイベントへ変換し、PathManager へ渡します。

PathManager がルーティングスイッチの本体です。RoutingSwitch コントローラから Packet In メッセージを受け取ると、Topology コントローラから受け取るトポロジ情報を元に最短パスを計算または再計算し、Path クラスを通じて新しい最短パスをスイッチに反映します。

Path クラスはフローエントリの管理を一手に引き受けます。FlowMod や FlowModDelete といった OpenFlow メッセージの詳細を PathManager から隠蔽します。

=== ルーティングスイッチのソースコード (routing_switch.rb)

RoutingSwitchコントローラは委譲パターンによって各OpenFlowメッセージを他のコントローラへと振り分けます。たとえばTopologyコントローラへ switch_ready イベントを転送するには、`def_delegators` を使ってTopologyクラスのインスタンスへ `switch_ready` メソッドを委譲します。packet_in イベントは Topology と PathManager の両方に届ける必要があるため、packet_in ハンドラの中で転送します。

// TODO 次章で説明するSliceableSwitchのことをここで簡単に触れておく

[source,ruby,subs="verbatim,attributes"]
.lib/routing_switch.rb
----
include::{sourcedir}/lib/routing_switch.rb[lines="40..48"]
----

=== パスマネージャのソースコード (path_manager.rb)

パスマネージャは、TopologyコントローラとObserverパターンで連携します。TopologyコントローラはRoutingSwitchコントローラから上がってくる生のOpenFlowメッセージをトポロジ上の変化イベント(スイッチ・ポート・リンクの追加/削除とホストの追加)へと変換し、オブザーバであるPathManagerコントローラへ通知します。

パスマネージャはトポロジイベントを受け取ると、インスタンス変数 `@graph` として持つ現在のネットワークグラフを更新します。たとえばLLDPによって新しいリンクを発見すると、Topologyコントローラはトポロジイベント `add_link` をパスマネージャへ送ります。そしてPathManagerはグラフ情報を更新し新しくみつかったリンクを登録します。

[source,ruby,subs="verbatim,attributes"]
.lib/path_manager.rb
----
include::{sourcedir}/lib/path_manager.rb[lines="33..37,59..62"]
----

// リンクの発見だけでなくて、その他の場合についても図を使って説明する?

// TODO Topologyのパス発見と`add_link`イベントからPathManagerが@graphを更新する図

パスマネージャへ `packet_in` が到着すると、パスマネージャは次の方法でパケットを宛先へと届けます (<<path_manager_internals,図15-6>>)。

1. グラフ情報から送信元→宛先への最短路を計算する。もし最短路がみつかった場合には、最短路上のスイッチにフローエントリを打つ
2. みつかった場合には、宛先ポートにPacketOutすることでPacketInを起こしたパケットを宛先へ届ける。みつからなかった場合には、パケットをすべての外部ポート(外部と接続しているポート)へPacketOutする

[[path_manager_internals]]
image::path_manager_internals.png[caption="図15-6",title="パスマネージャの仕組み"]

// TODO 内部ポートと外部ポートの説明図

[source,ruby,subs="verbatim,attributes"]
.PathManager#packet_in
----
include::{sourcedir}/lib/path_manager.rb[lines="14..22"]
----

// === Dijkstra

// TODO ダイクストラの説明はやったほうがいい?

// TODO ソースコードを include

== OpenFlow の利点

本章のはじめで説明したように、ルーティングスイッチは OpenFlow ネットワークを 1 台の仮想的なスイッチとして動作させるコントローラです。普通のスイッチを真似るだけならば、わざわざ OpenFlow を使わなくてもよいのでは? と思うかもしれません。ここでは、OpenFlow を使った場合の利点について考えてみたいと思います。

=== リンク帯域を有効活用できる

通常のスイッチで構成されたネットワークでは、パケットのループを防ぐためにスパニングツリープロトコルでリンクの一部を遮断します。たとえば、<<spt1,図 15-7>>のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ2とスイッチ3間のリンクが遮断されループが解消します。このとき、たとえばホスト2からホスト3へのパケットは、この遮断されたリンクを通過できないため、スイッチ1を経由して転送します。これは明かに無駄な回り道で、せっかくのリンク帯域が無駄になっています。

[[spt1]]
image::spt1.png[caption="図15-7",title="スパニングツリーではループを避けるために一部のリンクを遮断する"]

一方、ルーティングスイッチではコントローラがトポロジ全体を把握しているため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路を各スイッチにフローエントリとして明示的に指示するため、ループを含むトポロジであっても問題なく動作します。このためスパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使えます（<<spt2,図 15-8>>）。

[[spt2]]
image::spt2.png[caption="図15-8",title="ルーティングスイッチではネットワーク中のリンクを有効に使える"]

=== いろいろなパス選択アルゴリズムを使える

パスの決定はコントローラで一括して行なうため、パス決定アルゴリズムを入れ替えるだけで、さまざまなパス選択を実現できます。今回、ルーティングスイッチではダイクストラ法による最短パスを使いましたが、たとえば<<multipath,図15-9>>のようにフロー毎に異なるパスを設定することで、帯域確保のためのマルチパスを作ることも簡単にできます。

[[multipath]]
image::multipath.png[caption="図15-9",title="OpenFlowでは最短でないパスを含んだマルチパスを自由に作れる"]

このようなマルチパスは従来の自律分散型でも実現できますが、厳しい制限があります。IETFが標準化を行うTRILL（Transparent Interconnect of Lots ofLinks）やIEEEが標準化を行うSPB（Shortest Path Bridges）は、マルチパス転送に対応しています。しかし、マルチパス転送を使えるのは、最短パスが複数ある場合footnote:[このようなパスを、イコールコストマルチパス（Equal Cost Multipath）と呼びます。]だけです。最短ではないパスは、ループを起こす可能性があるため、使用することができません。また最短パスが1本だけの場合にもマルチパスにできません。

== まとめ

いくつものスイッチからなるネットワークを扱うことができる、ルーティングスイッチの動作を見てきました。この章で学んだことを簡単にまとめておきましょう。

- ネットワーク上の最短パスを計算する方法
- 複数のコントローラを連携させる方法
- OpenFlowを使う場合の利点

次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。

=== 参考文献

- 『最短経路の本——レナのふしぎな数学の旅』（Peter Gritzmann、Rene Brandenberg 著／シュプリンガー・ジャパン） 最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章ではネットワーク上での最短パスを求める場合のダイクストラ法を紹介しましたが、リンクに重みがある場合の一般的なダイクストラ法についてはこの本がおすすめです。
- 『マスタリングTCP/IP 応用編』（Philip Miller 著／オーム社 とくにレイヤ3の経路制御プロトコルについて詳しく説明した本です。ダイクストラ法を用いた経路制御プロトコルの1つであるOSPFについても説明しているので、ルーティングスイッチとの違いを比べてみるのもおもしろいでしょう。
