= たくさんのスイッチを制御する
:sourcedir: vendor/routing_switch
:imagesdir: images/routing_switch

大規模なネットワークを構成するたくさんのスイッチを連携させ、うまく制御する仕組みを見て行きましょう。

== 複数のスイッチを制御する

たくさんの OpenFlow スイッチがつながった環境では、パケットを目的地まで転送するためにスイッチを連携させる必要があります。複数の OpenFlow スイッチを連携し 1 台の大きな仮想スイッチにするコントローラが、本章で紹介するルーティングスイッチです (<<fig_routing_switch,図 15-1>>)。同じスイッチ機能を提供するコントローラとしては、<<learning_switch,第 6 章>>や<<learning_switch13,第 7 章>>で紹介したラーニングスイッチがありました。ラーニングスイッチとルーティングスイッチの大きな違いは、連携できるスイッチの台数です。ラーニングスイッチは OpenFlow スイッチを独立した 1 台のスイッチとして扱います。一方で、ルーティングスイッチは複数の OpenFlow スイッチを連携させることで、仮想的な 1 台のスイッチとして扱います。

[[fig_routing_switch]]
image::routing_switch.png[caption="図15-1",title="ルーティングスイッチはたくさんの OpenFlow スイッチを連携し 1 台の仮想スイッチとして動作させる"]

注意すべきは、ルーティングスイッチはルータではなく、あくまでスイッチであるという点です。**ルーティング**スイッチという名前は、複数のOpenFlowスイッチを経由し、まさにルーティングするようにパケットを転送することから来ています。このようにスイッチ機能を実現するという点では、ラーニングスイッチとの機能的な違いはありません。ただし制御できるネットワーク規模においては、ルーティングスイッチは複数の OpenFlow スイッチを扱えるという違いがあります。

=== ルーティングスイッチの動作

ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転送が複雑になります。宛先のホストまでいくつものスイッチを経由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指示してやる必要があるのです。

[[routing_switch_flow_mod]]
image::routing_switch_flow_mod.png[caption="図15-2",title="最短パスでパケットを転送するためにフローエントリを書き込む"]

たとえば<<routing_switch_flow_mod,図15-2>>において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみます。もしパケットを最短のパスで届けたい場合、スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローエントリを最短パス上のスイッチ 1, 5, 6 へ書き込む必要があります。

ルーティングスイッチの詳しい動作は次の通りです:

1. パケットの道順を指定するため、スイッチ同士の接続情報であるトポロジ情報を収集する (<<topology,第14章>>)
2. ホスト 1 からホスト 4 宛てのパケットをスイッチ 1 から Packet In として受け取る
3. トポロジ情報を検索し、宛先のホスト 4 が接続するスイッチとポート番号を得る。その結果、スイッチ 6 とホスト 4 が接続するポート番号を得る。
4. Packet In を出したスイッチ 1 から出口となるスイッチ 6 までの最短パスをステップ 1 で収集したトポロジ情報を使って計算する。その結果、スイッチ 1 → スイッチ 5 → スイッチ 6 というパスを得る
5. この最短パスに沿ってパケットが転送されるようにパス上のスイッチそれぞれに Flow Mod を送りフローエントリを書き込む
6. 最初の Packet In を起こしたパケットも宛先に送るために、スイッチ 6 に Packet Out を送る。

ここでキーとなるのは、ステップ 4 の最短パスの計算方法です。

=== 最短パスを計算する

最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短路を求める汎用アルゴリズムの 1 つで、カーナビの経路検索や鉄道の乗換案内などにも使われています。

ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のとおりです。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、見つかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、 4 ホップ……というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します。footnote:[ダイクストラ法はリンクに重み（距離）がある場合の最短路を求めることができるので、実際にはもう少し複雑な手順になります。ネットワーク上の最短パスではそれぞれのリンクは“重み1”として考えるので、このように単純化できます。]

[[dijkstra]]
image::dijkstra.png[caption="図15-3",title="最短パスをダイクストラ方で計算する"]

実際に<<flow_mod_routing_switch,図 15-2>>のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ方で探索する手順は次のようになります (<<dijkstra,図 15-3>>)。

1. 視点となるスイッチ 1 に着目し、ここを 0 ホップとする
2. 視点のスイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ1 から出るリンクの先に繋がっているスイッチで、スイッチ 2 と スイッチ 5 が見つかる
3. ステップ 2 で見つかったスイッチから 1 ホップで行けるすべてのスイッチを見つける。これはつまり、始点からのホップ数が 2 のすべてのスイッチということになる。今度はスイッチ 3, 4, 6 が見つかる
4. ゴールであるスイッチ 6 が見つかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 とわかる

// TODO (dijkstra.rb の実装をここで解説する??)

== 実行してみよう

ルーティングスイッチを使って実際のトポロジ検出や最短路計算の動作を見ていきましょう。ルーティングスイッチは他のサンプルと同様、GitHub で公開されています。次のようにソースコードを取得してください。

----
$ git clone https://github.com/trema/routing_switch.git
----

依存する gem のインストールは、いつも通り次のコマンドです。

----
$ cd routing_switch
$ bundle install --binstubs
----

これで準備は完了です。

=== ルーティングスイッチを動かす

それでは、ルーティングスイッチを動かしてみましょう。Trema のネットワークエミュレータ機能を用いて、次のネットワークを作ります。

image::fullmesh.png[caption="図15-4",title="図スイッチ4台からなるネットワーク"]

// TODO 図スイッチ?台からなるネットワーク

この構成を実現する設定ファイルは、ルーティングスイッチのソースツリーの中に含まれています (`trema.conf`)。この設定ファイルを指定して、次のようにルーティングスイッチを起動します。

----
$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf
----

// === トポロジを表示する
// ルーティングスイッチが使う Topology は、現在のトポロジ情報を Graphviz で次のようなファイルを作ります。

// 図: Topology が作ったトポロジ図

// 図 ?-? と比較すると、スイッチ間のリンクがうまく検出できていることがわかります。しかし、仮想ホストとスイッチ間のリンクは検出できていません。LLDP と OpenFlow によるトポロジ検出は、あくまでスイッチ間のリンクを検出する仕組みだからです。

=== 最短パスを通すフローエントリを確認する

次に host1 と host2 の間でパケットを送受信し、最短パスを通すフローエントリがうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行っていないので、host1 から host2 へとパケットを送っただけではフローエントリは設定されません。ラーニングスイッチと同じく、次のように両方向でパケットを送った段階でフローエントリが設定されます。

----
$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1
$ ./bin/trema send_packets --source host1 --dest host2
----

すると、ルーティングスイッチを起動したターミナルには host2 → host1 と host1 → host2 の 2 つの最短路パスを発見した、というメッセージが表示されているはずです。

----
Creating path: 22:22:22:22:22:22 -> 0x2:1 -> 0x2:2 -> 0x1:2 -> 0x1:1 -> 11:11:11:11:11:11
Creating path: 11:11:11:11:11:11 -> 0x1:1 -> 0x1:2 -> 0x2:2 -> 0x2:1 -> 22:22:22:22:22:22
----

実際にどのようなフローエントリが設定されたか見てみましょう。フローエントリの確認は、`trema dump_flows [スイッチの Datapath ID]` コマンドです。まずは host1 から host2 への最短パスであるスイッチ 0x1, 0x2 のフローテーブルを見てみましょう。

----
$ ./bin/trema dump_flows switch1
NXST_FLOW reply (xid=0x4):
 cookie=0x0, duration=11.522s, table=0, n_packets=0, n_bytes=0, hard_timeout=60, idle_age=11, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=22:22:22:22:22:22,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.2,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1
 cookie=0x0, duration=6.835s, table=0, n_packets=1, n_bytes=42, hard_timeout=60, idle_age=6, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=22:22:22:22:22:22,nw_src=192.168.0.1,nw_dst=192.168.0.2,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
$ ./bin/trema dump_flows switch2
NXST_FLOW reply (xid=0x4):
 cookie=0x0, duration=18.474s, table=0, n_packets=0, n_bytes=0, hard_timeout=60, idle_age=18, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=22:22:22:22:22:22,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.2,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
 cookie=0x0, duration=13.737s, table=0, n_packets=0, n_bytes=0, hard_timeout=60, idle_age=13, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=22:22:22:22:22:22,nw_src=192.168.0.1,nw_dst=192.168.0.2,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1
----

たしかにスイッチ 0x1 と 0x2 それぞれについて、host1 と host2 間の 2 つの最短パス用のフローエントリが設定されています。

一方で、最短パス上にないスイッチ 0x3, 0x4 はパケットが通らないため、次のようにフローエントリがありません。

----
$ ./bin/trema dump_flows 0x3
NXST_FLOW reply (xid=0x4):
$ ./bin/trema dump_flows 0x4
NXST_FLOW reply (xid=0x4):
----

以上でルーティングスイッチにおけるトポロジ検出と最短パス計算の動作を見てきました。いずれも OpenFlow で大規模なネットワークを扱う際の基本的なテクニックですので、ぜひ習得してください。

== ルーティングスイッチのソースコード

ルーティングスイッチは次の3つのコントローラクラスが協調して動作します (<<routing_switch_architecture,図15-5>>)。

- RoutingSwitchクラス
- Topologyクラス (<<topology,第14章>>で紹介)
- PathManagerクラス

[[routing_switch_architecture]]
image::routing_switch_architecture.png[caption="図15-5",title="ルーティングスイッチのクラス構成"]

RoutingSwitchクラスの主な仕事はOpenFlowメッセージの振り分けです。OpenFlowスイッチと接続し、スイッチから上がってくるOpenFlowメッセージをその種類に応じて Topology または PathManager へと振り分けます。

Topologyコントローラは、トポロジ情報に関連する次のOpenFlowイベントをRoutingSwitchコントローラから受け取ります。

- `switch_ready`
- `features_reply`
- `switch_disconnected`
- `port_modify`
- `packet_in`

Topologyコントローラはこの受け取った OpenFlow メッセージをネットワークトポロジ上のイベントへ変換し、PathManager へ渡します。

PathManagerがルーティングスイッチの本体です。RoutingSwitchコントローラからpacket_inイベントを受け取ると、Topologyコントローラから受け取るトポロジ情報を元に最短路を計算し、パスに沿ってフローエントリを各スイッチへと打ち込みます。また Packet Out することで宛先へとパケットを届けます。

=== ルーティングスイッチのソースコード (routing_switch.rb)

RoutingSwitchコントローラは委譲パターンによって各OpenFlowメッセージを他のコントローラへと振り分けます。たとえばTopologyコントローラへ switch_ready イベントを転送するには、`def_delegators` を使ってTopologyクラスのインスタンスへ `switch_ready` メソッドを委譲します。packet_in イベントは Topology と PathManager の両方に届ける必要があるため、packet_in ハンドラの中で転送します。

// TODO 次章で説明するSliceableSwitchのことをここで簡単に触れておく

[source,ruby,subs="verbatim,attributes"]
.lib/routing_switch.rb
----
include::{sourcedir}/lib/routing_switch.rb[lines="40..48"]
----

=== パスマネージャのソースコード (path_manager.rb)

パスマネージャは、TopologyコントローラとObserverパターンで連携します。TopologyコントローラはRoutingSwitchコントローラから上がってくる生のOpenFlowメッセージをトポロジ上の変化イベント(スイッチ・ポート・リンクの追加/削除とホストの追加)へと変換し、オブザーバであるPathManagerコントローラへ通知します。

パスマネージャはトポロジイベントを受け取ると、インスタンス変数 `@graph` として持つ現在のネットワークグラフを更新します。たとえばLLDPによって新しいリンクを発見すると、Topologyコントローラはトポロジイベント `add_link` をパスマネージャへ送ります。そしてPathManagerはグラフ情報を更新し新しくみつかったリンクを登録します。

[source,ruby,subs="verbatim,attributes"]
.lib/path_manager.rb
----
include::{sourcedir}/lib/path_manager.rb[lines="33..37,59..62"]
----

// リンクの発見だけでなくて、その他の場合についても図を使って説明する?

// TODO Topologyのパス発見と`add_link`イベントからPathManagerが@graphを更新する図

パスマネージャへ `packet_in` が到着すると、パスマネージャは次の方法でパケットを宛先へと届けます (<<path_manager_internals,図15-6>>)。

1. グラフ情報から送信元→宛先への最短路を計算する。もし最短路がみつかった場合には、最短路上のスイッチにフローエントリを打つ
2. みつかった場合には、宛先ポートにPacketOutすることでPacketInを起こしたパケットを宛先へ届ける。みつからなかった場合には、パケットをすべての外部ポート(外部と接続しているポート)へPacketOutする

[[path_manager_internals]]
image::path_manager_internals.png[caption="図15-6",title="パスマネージャの仕組み"]

// TODO 内部ポートと外部ポートの説明図

[source,ruby,subs="verbatim,attributes"]
.PathManager#packet_in
----
include::{sourcedir}/lib/path_manager.rb[lines="14..22"]
----

// === Dijkstra

// TODO ダイクストラの説明はやったほうがいい?

// TODO ソースコードを include

== OpenFlow の利点

本章のはじめで説明したように、ルーティングスイッチは OpenFlow ネットワークを 1 台の仮想的なスイッチとして動作させるコントローラです。普通のスイッチを真似るだけならば、わざわざ OpenFlow を使わなくてもよいのでは? と思うかもしれません。ここでは、OpenFlow を使った場合の利点について考えてみたいと思います。

=== リンク帯域を有効活用できる

通常のスイッチで構成されたネットワークでは、パケットのループを防ぐためにスパニングツリープロトコルでリンクの一部を遮断します。たとえば、<<spt1,図 15-7>>のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ2とスイッチ3間のリンクが遮断されループが解消します。このとき、たとえばホスト2からホスト3へのパケットは、この遮断されたリンクを通過できないため、スイッチ1を経由して転送します。これは明かに無駄な回り道で、せっかくのリンク帯域が無駄になっています。

[[spt1]]
image::spt1.png[caption="図15-7",title="スパニングツリーではループを避けるために一部のリンクを遮断する"]

一方、ルーティングスイッチではコントローラがトポロジ全体を把握しているため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路を各スイッチにフローエントリとして明示的に指示するため、ループを含むトポロジであっても問題なく動作します。このためスパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使えます（<<spt2,図 15-8>>）。

[[spt2]]
image::spt2.png[caption="図15-8",title="ルーティングスイッチではネットワーク中のリンクを有効に使える"]

=== いろいろなパス選択アルゴリズムを使える

パスの決定はコントローラで一括して行なうため、パス決定アルゴリズムを入れ替えるだけで、さまざまなパス選択を実現できます。今回、ルーティングスイッチではダイクストラ法による最短パスを使いましたが、たとえば<<multipath,図15-9>>のようにフロー毎に異なるパスを設定することで、帯域確保のためのマルチパスを作ることも簡単にできます。

[[multipath]]
image::multipath.png[caption="図15-9",title="OpenFlowでは最短でないパスを含んだマルチパスを自由に作れる"]

このようなマルチパスは従来の自律分散型でも実現できますが、厳しい制限があります。IETFが標準化を行うTRILL（Transparent Interconnect of Lots ofLinks）やIEEEが標準化を行うSPB（Shortest Path Bridges）は、マルチパス転送に対応しています。しかし、マルチパス転送を使えるのは、最短パスが複数ある場合footnote:[このようなパスを、イコールコストマルチパス（Equal Cost Multipath）と呼びます。]だけです。最短ではないパスは、ループを起こす可能性があるため、使用することができません。また最短パスが1本だけの場合にもマルチパスにできません。

== まとめ

いくつものスイッチからなるネットワークを扱うことができる、ルーティングスイッチの動作を見てきました。この章で学んだことを簡単にまとめておきましょう。

- ネットワーク上の最短パスを計算する方法
- 複数のコントローラを連携させる方法
- OpenFlowを使う場合の利点

次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。

=== 参考文献

- 『最短経路の本——レナのふしぎな数学の旅』（Peter Gritzmann、Rene Brandenberg 著／シュプリンガー・ジャパン） 最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章ではネットワーク上での最短パスを求める場合のダイクストラ法を紹介しましたが、リンクに重みがある場合の一般的なダイクストラ法についてはこの本がおすすめです。
- 『マスタリングTCP/IP 応用編』（Philip Miller 著／オーム社 とくにレイヤ3の経路制御プロトコルについて詳しく説明した本です。ダイクストラ法を用いた経路制御プロトコルの1つであるOSPFについても説明しているので、ルーティングスイッチとの違いを比べてみるのもおもしろいでしょう。
