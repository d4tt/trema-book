= いくつものスイッチをルーティングスイッチで制御する
:sourcedir: vendor/routing_switch
:imagesdir: images/routing_switch

== 複数のスイッチを制御する
ルーティングスイッチは、複数台の OpenFlow スイッチを連動させ 1 つの大きなスイッチとして動作させるためのコントローラです (図)。同じスイッチ機能を提供するコントローラとしては第○章で紹介したラーニングスイッチがありました。これとの大きな違いは制御できるスイッチの台数です。ラーニングスイッチは 1 台の OpenFlow スイッチしか扱えません。一方で、ルーティングスイッチは複数の OpenFlow スイッチを制御できます。

// TODO 図: いくつもの OpenFlow スイッチを 1 つの大きなスイッチとして動作させる

ルーティングスイッチの名前は、複数のOpenFlowスイッチを使い、まさにルーティングするようにパケットを転送することから来ています。ただし、ルーティングスイッチはルータではありません。ラーニングスイッチと同じく、スイッチ機能を実現するコントローラであることに注意が必要です。
=== ルーティングスイッチの動作
ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転送が複雑になります。宛先のホストまでいくつものスイッチを経由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指示してやる必要があるのです。

たとえば図?-?において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみます。もしパケットを最短のパスで届けたい場合、スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローエントリを最短パス上のスイッチ 1, 5, 6 へ書き込む必要があります。

ルーティングスイッチの詳しい動作は次の通りです:

1. パケットの道順を指定するため、スイッチ同士の接続情報であるトポロジ情報を収集する。トポロジ情報の中身は、スイッチ同士がどのポートでつながっているかを集めたもの (詳しい収集方法は後述)
2. ホスト 1 からホスト 4 宛てのパケットをスイッチ 1 から Packet In として受け取る
3. トポロジ情報を検索し、宛先のホスト 4 が接続するスイッチとポート番号を得る。その結果、スイッチ 6 とホスト 4 が接続するポート番号を得る。
4. Packet In を出したスイッチ 1 から出口となるスイッチ 6 までの最短パスをステップ 1 で収集したトポロジ情報を使って計算する。その結果、スイッチ 1 → スイッチ 5 → スイッチ 6 というパスを得る
5. この最短パスに沿ってパケットが転送されるようにパス上のスイッチそれぞれに Flow Mod を送りフローエントリを書き込む
6. 最初の Packet In を起こしたパケットも宛先に送るために、スイッチ 6 に Packet Out を送る。

ここでキーとなるのは、ステップ 4 の最短パスの計算方法です。

=== 最短パスを計算する
最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短路を求める汎用アルゴリズムの 1 つで、カーナビの経路検索や鉄道の乗換案内などにも使われています。

ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のとおりです。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、見つかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、 4 ホップ……というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します。(fn)

// TODO 図 最短パスをダイクストラ方で計算する

実際に図 x-x のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ方で探索する手順は次のようになります (図 x-x)。

1. 視点となるスイッチ 1 に着目し、ここを 0 ホップとする
2. 視点のスイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ1 から出るリンクの先に繋がっているスイッチで、スイッチ 2 と スイッチ 5 が見つかる
3. ステップ 2 で見つかったスイッチから 1 ホップで行けるすべてのスイッチを見つける。これはつまり、始点からのホップ数が 2 のすべてのスイッチということになる。今度はスイッチ 3, 4, 6 が見つかる
4. ゴールであるスイッチ 6 が見つかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 とわかる

// TODO (dijkstra.rb の実装をここで解説する??)
== 実行してみよう
ルーティングスイッチを使って実際のトポロジ検出や最短路計算の動作を見ていきましょう。ルーティングスイッチは他のサンプルと同様、GitHub で公開されています。次のようにソースコードを取得してください。

----
$ git clone https://github.com/trema/routing_switch.git
----

依存する gem のインストールは、いつも通り次のコマンドです。

----
$ cd routing_switch
$ bundle install --binstubs
----

これで準備は完了です。

=== ルーティングスイッチを動かす
それでは、ルーティングスイッチを動かしてみましょう。Trema のネットワークエミュレータ機能を用いて、次のネットワークを作ります。

// TODO 図スイッチ?台からなるネットワーク

この構成を実現する設定ファイルは、ルーティングスイッチのソースツリーの中に含まれています (`trema.conf`)。この設定ファイルを指定して、次のようにルーティングスイッチを起動します。

----
$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf -d
----

=== トポロジを表示する
ルーティングスイッチが使う Topology は、現在のトポロジ情報を Graphviz で次のようなファイルを作ります。

図: Topology が作ったトポロジ図

図 ?-? と比較すると、スイッチ間のリンクがうまく検出できていることがわかります。しかし、仮想ホストとスイッチ間のリンクは検出できていません。LLDP と OpenFlow によるトポロジ検出は、あくまでスイッチ間のリンクを検出する仕組みだからです。

=== 最短パスを通すフローエントリを確認する
次に host1 と host2 の間でパケットを送受信し、最短パスを通すフローエントリがうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行っていないので、host1 から host2 へとパケットを送っただけではフローエントリは設定されません。次のように両方向でパケットを送った段階でフローエントリが設定されます。

----
$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1
----

それでは、どのようなフローエントリが設定されたか見てみましょう。フローエントリの確認は、`trema dump_flows [スイッチの Datapath ID]` コマンドです。まずは host1 から host2 への最短パスであるスイッチ 0x1, 0x3 のフローテーブルを見てみましょう。

----
$ ./bin/trema dump_flows 0x1
(出力をここに)
$ ./bin/trema dump_flows 0x2
(出力をここに)
----

これより、0x1 と 0x2 のスイッチそれぞれに host2 → host1 のフローエントリが設定されていることがわかります。

一方で、最短パス上にないスイッチ 0x3, 0x4 はパケットが通らないため、次のようにフローエントリがありません。

----
$ ./bin/trema dump_flows 0x3
(出力をここに)
$ ./bin/trema dump_flows 0x4
(出力をここに)
----

以上でルーティングスイッチにおけるトポロジ検出と最短パス計算の動作を見てきました。これらは OpenFlow で大規模なネットワークを扱う際の基本的なテクニックですので、ぜひ習得してください。

== ルーティングスイッチのソースコード
ルーティングスイッチは次の3つのコントローラクラスが協調して動作します。

- RoutingSwitchクラス
- Topologyクラス (○章で紹介)
- PathManagerクラス

RoutingSwitchクラスの主な仕事はOpenFlowメッセージの振り分けです。OpenFlowスイッチと接続し、スイッチから上がってくるOpenFlowメッセージをその種類に応じて適切なコントローラのハンドラへと振り分けます。

// TODO RoutingSwitchが行うOpenFlowメッセージの振り分け

Topologyコントローラは、トポロジ情報に関連する次のOpenFlowイベントをRoutingSwitchコントローラから受け取ります。

- switch\_ready
- features\_reply
- switch\_disconnected
- port\_modify
- packet\_in

PathManagerがルーティングスイッチの本体です。RoutingSwitchコントローラからpacket\_inイベントを受け取り、Topologyコントローラから受け取るトポロジ情報を元に最短路を計算し、パスに沿ってフローエントリを各スイッチへと打ち込みます。

=== ルーティングスイッチのソースコード (routing\_switch.rb)

RoutingSwitchコントローラは委譲パターンによって各OpenFlowメッセージを他のコントローラへと振り分けます。たとえばTopologyコントローラへswitch\_readyイベントを転送するには、`def_delegators :@topology, :switch_ready`のように`def_delegators`を使ってTopologyクラスのインスタンスへ`switch_ready`メソッドを委譲します。

// TODO 次章で説明するSliceableSwitchのことをここで簡単に触れておく

// TODO ソースコードを include

=== パスマネージャのソースコード (path\_manager.rb)

パスマネージャは、TopologyコントローラとObserverパターンで図○のように連携します。TopologyコントローラはRoutingSwitchコントローラから上がってくる生のOpenFlowメッセージをトポロジ上の変化イベント(ポートの追加/削除、リンクの追加/削除、ホストの追加)へと変換し、オブザーバであるPathManagerコントローラへ通知します。

// TODO TopologyコントローラとPathManagerコントローラ間でのやりとりの図

パスマネージャはトポロジイベントを受け取ると、インスタンス変数`@graph`として持つ現在のネットワークグラフを更新します。たとえばTopologyが定期的に送信するLLDPパケットによって新しいリンクを発見すると、Topologyコントローラはトポロジイベント`add_link`をパスマネージャへ送ります。そしてPathManagerはグラフ情報を更新し新しくみつかったリンクを登録します。

// リンクの発見だけでなくて、その他の場合についても図を使って説明する?

// TODO Topologyのパス発見と`add_link`イベントからPathManagerが@graphを更新する図

パスマネージャへ`packet_in`が到着すると、パスマネージャは次の方法でパケットを宛先へと届けます。

1. グラフ情報から送信元→宛先への最短路を計算する。もし最短路がみつかった場合には、最短路上のスイッチにフローエントリを打つ
2. みつかった場合には、宛先ポートにPacketOutすることでPacketInを起こしたパケットを宛先へ届ける。みつからなかった場合には、パケットをすべての外部ポート(外部と接続しているポート)へPacketOutする

// TODO 内部ポートと外部ポートの説明図

// TODO ソースコードを include

=== Dijkstra

// TODO ダイクストラの説明はやったほうがいい?

// TODO ソースコードを include

== OpenFlow の利点

本章のはじめで説明したように、ルーティングスイッチは OpenFlow ネットワークを 1 台の仮想的なスイッチとして動作させるコントローラです。普通のスイッチを真似るだけならば、わざわざ OpenFlow を使わなくてもよいのでは? と思うかもしれません。ここでは、OpenFlow を使った場合の利点について考えてみたいと思います。

=== リンク帯域を有効活用できる

通常のスイッチで構成されたネットワークでは、パケットのループを防ぐためにスパニングツリープロトコルでリンクの一部を遮断します。たとえば、▼図14-11のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ2とスイッチ3間のリンクが遮断されループが解消します。このとき、たとえばホスト2からホスト3へのパケットは、この遮断されたリンクを通過できないため、スイッチ1を経由して転送します。これは明かに無駄な回り道で、せっかくのリンク帯域が無駄になっています。

// TODO 図14-11：スパニングツリーではループを避けるために一部のリンクを遮断する

一方、ルーティングスイッチではコントローラがトポロジ全体を把握しているため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路を各スイッチにフローエントリとして明示的に指示するため、ループを含むトポロジであっても問題なく動作します。このためスパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使えます（▼図14-12）。

// TODO ○図14-12：ルーティングスイッチではネットワーク中のリンクを有効に使える

=== いろいろなパス選択アルゴリズムを使える

パスの決定はコントローラで一括して行なうため、パス決定アルゴリズムを入れ替えるだけで、さまざまなパス選択を実現できます。今回、ルーティングスイッチではダイクストラ法による最短パスを使いましたが、たとえば▼図14-13のようにフロー毎に異なるパスを設定することで、帯域確保のためのマルチパスを作ることも簡単にできます。

// TODO ○図14-13：OpenFlowでは最短でないパスを含んだマルチパスを自由に作れる

このようなマルチパスは従来の自律分散型でも実現できますが、厳しい制限があります。IETFが標準化を行うTRILL（Transparent Interconnect of Lots ofLinks）やIEEEが標準化を行うSPB（Shortest Path Bridges）は、マルチパス転送に対応しています。しかし、マルチパス転送を使えるのは、最短パスが複数ある場合▼注2だけです。最短ではないパスは、ループを起こす可能性があるため、使用することができません。また最短パスが1本だけの場合にもマルチパスにできません。

○注2：このようなパスを、イコールコストマルチパス（Equal Cost Multipath）と呼びます。

== まとめ

いくつものスイッチからなるネットワークを扱うことができる、ルーティングスイッチの動作を見てきました。この章で学んだことを簡単にまとめておきましょう。

- ネットワーク上の最短パスを計算する方法
- 複数のコントローラを連携させる方法
- OpenFlowを使う場合の利点

次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。

=== 参考文献

- 『最短経路の本——レナのふしぎな数学の旅』（Peter Gritzmann、Rene Brandenberg 著／シュプリンガー・ジャパン） 最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章ではネットワーク上での最短パスを求める場合のダイクストラ法を紹介しましたが、リンクに重みがある場合の一般的なダイクストラ法についてはこの本がおすすめです。
- 『マスタリングTCP/IP 応用編』（Philip Miller 著／オーム社 とくにレイヤ3の経路制御プロトコルについて詳しく説明した本です。ダイクストラ法を用いた経路制御プロトコルの1つであるOSPFについても説明しているので、ルーティングスイッチとの違いを比べてみるのもおもしろいでしょう。
