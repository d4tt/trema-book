= いくつものスイッチをルーティングスイッチで制御する

私はネットワーク研究者という仕事柄、よく大小さまざまなネットワークを目にします。その中でもいつも「すごい!」とうならされるのが、ネットワーク業界の恒例行事とも言える ShowNet です。これはネットワーク系最大の展示会 Interop の期間中だけ構築・運用されるネットワークで、最新ネットワーク技術のいわばショーケースとも言えるものです。普段は絶対に触ることのできない、ネットワーク界の F1 マシンとも言える最新機器を集めたライブデモンストレーションは圧巻の一言です。

私のようなネットワーク業界人を魅了するもうひとつの名物が、Interop で配られる ShowNet のトポロジ図です (@<img>{shownet_topology})。これの見どころは、ShowNet を構成するネットワーク機器同士の複雑な接続関係をたった一枚の美しい図に収めているところです。「この部分は、いったいどんなプロトコルで動いているんだろう？」「実際の詳しいトポロジはどうなっているのかな？」詳しく見れば見るほど、私のワクワクは止まりません。

//image[shownet_topology][2012 年 Interop の ShowNet トポロジ図。Copyright (C) 2012 Interop Tokyo ShowNet NOC Team All Rights Reserved.][scale=0.6]

ShowNet のようにいくつものスイッチやルータがつながるネットワークの動作では、トポロジー情報が一つの鍵です。パケットが迷子になったりループしたりせずに正しく目的地まで届けられるためには、スイッチやルータ同士がどのような接続関係にあるかをお互いに把握しなければなりません。

OpenFlow では、コントローラがこのトポロジ情報を検出します。集中管理の中心であるコントローラが全体のトポロジを把握することで、パケットを思いのままに転送できます。たとえば、ネットワーク上の最短パスでパケットを転送するだけでなく、特定の部分の回り道や複数のパスを使った転送も自由自在です。

ここではいくつものスイッチを制御するコントローラの一例として、ルーティングスイッチを紹介します。ルーティングスイッチがどのようにしてトポロジを把握し、パケットを目的地まで転送するかを見ていきましょう。

== 複数のスイッチを制御する

ルーティングスイッチは、複数台の OpenFlow スイッチを連動させ一つの大きなスイッチとして動作させるためのコントローラです (@<img>{routing_switch})。@<chap>{learning_switch}で紹介した、同じスイッチ機能を提供するラーニングスイッチとの違いは制御できるスイッチの台数です。ラーニングスイッチは 1 台の OpenFlow スイッチしか扱えない一方で、ルーティングスイッチは複数台の OpenFlow スイッチを制御できます。

//image[routing_switch][いくつもの OpenFlow スイッチを一つの大きなスイッチとして動作させる][scale=0.5]

=== ルーティングスイッチの動作

ルーティングスイッチではたくさんのスイッチ同士を接続するため、多くの場合パケットの入口となるスイッチと出口となるスイッチが異なります。このため、いくつものスイッチを経由してパケットを届けなくてはならず、そのための道順をスイッチに指示してやる必要があります。

例えば、@<img>{flow_mod} において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみます。もしパケットを最短のパスで届けたい場合、スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローをスイッチ 1, 5, 6 へ書き込む必要があります。

//image[flow_mod][最短パスでパケットを転送するためにフローを書き込む][scale=0.5]

ルーティングスイッチコントローラの詳しい動作は次のようになります:

 1. パケットの道順を指定するため、スイッチ同士の接続情報であるトポロジ情報を収集する。トポロジ情報の中身は、スイッチ同士がどのポートでつながっているかを集めたものである (詳しい収集方法は後ほど説明)。
 2. ホスト 1 からホスト 4 宛てのパケットをスイッチ 1 から Packet In として受け取る。
 3. FDB を検索し、宛先のホスト 4 が接続するスイッチとポート番号を検索する。その結果、スイッチ 6 とホスト 4 が接続するポート番号を得る。
 4. Packet In を出したスイッチ 1 から出口となるスイッチ 6 までの最短パスをステップ 1 で収集したトポロジ情報を使って計算する。その結果、スイッチ 1 → スイッチ 5 → スイッチ 6 というパスを得る。
 5. この最短パスに沿ってパケットが転送されるよう、パス上のスイッチそれぞれに Flow Mod を送りフローを書き込む。
 6. 最初の Packet In を起こしたパケットも宛先に送るために、スイッチ 6 に Packet Out を送る。

ここでキーとなるのは、ステップ 4 で使うトポロジ情報の収集方法と最短パスの計算方法です。まずは最短パスを説明します。

=== 最短パスを計算する

最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短路を求めるための汎用アルゴリズムの一つで、カーナビの経路探索や鉄道の乗換案内などにも使われています。

ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のようになります。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、みつかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、4 ホップ…というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します@<fn>{dijkstra}。

//footnote[dijkstra][ダイクストラ法はリンクに重み (距離) がある場合の最短路を求めることができるので、実際にはもう少し複雑な手順になります。ネットワークの最短パスではそれぞれのリンクは重み 1 として考えるので、このように単純化できます。]

//image[dijkstra][最短パスをダイクストラ法で計算する][scale=0.5]

実際に@<img>{routing_switch} のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ法で探索する手順は次のようになります (@<img>{dijkstra}):

 1. 始点となるスイッチ 1 に着目し、ここを 0 ホップとする。
 2. 始点のスイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ 1 から出るリンクの先に繋がっているスイッチで、スイッチ 2 とスイッチ 5 が見つかる。
 3. ステップ 2 でみつかったスイッチから 1 ホップで行けるすべてのスイッチを見つける。これはつまり、始点からのホップ数が 2 のすべてのスイッチということになる。今度はスイッチ 3, 4, 6 が見つかる。
 4. ゴールであるスイッチ 6 がみつかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 であることがわかる。

=== トポロジーを検出する

ダイクストラ法には、"リンクの先に繋がっているスイッチを調べる"というステップがありました。これを実行するためには、コントローラはトポロジ情報を知っている必要があります。トポロジを検出するには、スイッチ間のリンクをすべて発見する必要があります。

==== リンクの発見

OpenFlow でリンクを発見する方法として代表的なのは、次の Link Layer Discovery Protocol (LLDP) パケットを使った方法です (@<img>{lldp_overview})。コントローラはどこにリンクがあるかあたりをつけるために、適当なスイッチ A に LLDP パケットを試しに送ります。もし、スイッチ A に別のスイッチ B がリンクでつながっていれば、LLDP パケットはそこのリンクを通りスイッチ B を経由してブーメランのようにコントローラへと戻ってきます。このように LLDP パケットが無事に戻ってくれば、スイッチ A と B はリンクでつながっているとわかります。また、LLDP パケットには通過したリンクの詳しい情報が書き込まれるので、スイッチ A と B がどのポート番号で接続しているかということまで分かります。これを繰り返していけば、最終的にはすべてのリンクを発見できるわけです。

//image[lldp_overview][LLDP を使ってリンクを発見する][scale=0.5]

「なぜ、LLDP パケットはきちんとリンクを通ってコントローラまで戻ってくるんだろう？スイッチに LLDP 固有のしかけが必要なのかな？」こう思った方もいるかもしれません。実は、LLDP によるリンク発見は今まで学んできた OpenFlow の仕組みだけを使って実現できます。つまり、OpenFlow に対応したスイッチであれば LLDP を使えます。

LLDP によるリンク発見を OpenFlow で実現する方法を見ていきましょう。@<img>{lldp_openflow} のように、スイッチ 0x1 のポート 4 とスイッチ 0x2 のポート 1 が接続されていたとします。このリンクを発見するために、コントローラは以下の動作をします。

//image[lldp_openflow][LLDP パケットと OpenFlow の仕組みを使ってリンクを発見する][scale=0.5]

 1. コントローラは、接続関係を調べたいスイッチの Datapath ID 0x1 とポート番号 4 を埋め込んだ Link Layer Discovery Protocol (LLDP) パケットを作ります。
 2. ポート 4 から出力するというアクションを含む Packet Out メッセージを作り、先ほど作った LLDP パケットをスイッチ 0x1 へと送ります。
 3. Packet Out を受け取ったスイッチはアクションに従い、LLDP パケットを指定されたポート 4 から出力します。その結果、LLDP パケットは、ポート 4 の先につながるスイッチ 0x2 へと到着します。
 4. LLDP パケットを受け取ったスイッチ 0x2 は、自身のフローテーブルを参照し、パケットの処理方法を調べます。このとき LLDP に対するフローはあえて設定していないため、今回受信した LLDP パケットは、Packet In としてコントローラまで戻されます。
 5. コントローラは、受け取った Packet In メッセージを解析することで、リンクの発見を行います。スイッチ 0x2 からは @<img>{lldp-packet-in} の Packet In メッセージが送られきます。この中身を見ることで、スイッチ 0x1 のポート 4 と、スイッチ 0x2 のポート 1 の間にリンクを発見できます。

//image[lldp-packet-in][スイッチ 0x2 から送られてくる Packet In メッセージ][scale=0.7]

このように、Packet Out で送られた LLDP パケットは、リンクを通過し、隣のスイッチから Packet In でコントローラへと戻ってきます。この一連の動作によりコントローラは、リンクを発見できます。この方法自体は、OpenFlow 仕様で特に規定されているわけではありません。それぞれのスイッチは OpenFlow 仕様で定められた動作を行なっているだけです。つまり、Packet Out と Packet In をうまく使った "OpenFlow ならでは" のリンク発見方法だと言えます。

==== トポロジの検出

このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロジーを知ることができます。たとえば @<img>{topology_before} のような 3 台の OpenFlow スイッチからなるネットワークにおいて、どのようにトポロジーを検出するかを見ていきましょう。各 OpenFlow スイッチがコントローラに接続した直後の状態では、コントローラはスイッチ同士がどのように接続されているかを知りません。

//image[topology_before][トポロジー検出前のコントローラ][scale=0.5]

まずスイッチ 0x1 から調べていきます。はじめに Features Request メッセージを送ることで、スイッチ 0x1 が持つポート一覧を取得します。そして、それぞれのポートに対して、前述のリンク発見手順を行います(@<img>{topology_after})。その結果、スイッチ 0x1 からスイッチ 0x2 およびスイッチ 0x3 へと至るリンクがそれぞれ発見できます。

//image[topology_after][スイッチ 0x1 から出るリンクを発見][scale=0.5]

あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていくだけです。スイッチ 0x2, 0x3 に接続するリンクを順に調べていくことで、ネットワークの完全なトポロジー情報を知ることができます。

== 実行してみよう

ルーティングスイッチは、Trema Apps の一部として、Github 上で公開されています。公開されているルーティングスイッチを使いながら、実際の動作を見ていきましょう。

=== 準備

Trema Apps のソースコードは、@<tt>{https://github.com/trema/apps/} にあります。まずは、@<tt>{git} を使って、ソースコードを取得しましょう。

//cmd{
% git clone https://github.com/trema/apps.git
//}

@<chap>{trema_architecture} で紹介したように、Trema Apps 中はさまざまなアプリケーションがあります。そのうち、今回使用するのは @<tt>{topology} と @<tt>{routing_switch} です。@<tt>{topology} は、トポロジー検出を担当するモジュール @<tt>{topology_discovery} と検出したトポロジーを管理するモジュール @<tt>{topology} を含んでいます。また @<tt>{routing_switch} は、ルーティングスイッチの本体を含んでいます。各モジュールの関係を @<img>{modules} に示します。

//image[modules][ルーティングスイッチの動作に必要なモジュール][scale=0.7]

@<tt>{topology} と @<tt>{routing_switch} を順に @<tt>{make} してください。

//cmd{
% (cd apps/topology/; make)
% (cd apps/routing_switch; make)
//}

=== ルーティングスイッチを動かす

それでは、ルーティングスイッチを動かしてみましょう。今回は Trema のネットワークエミュレータ機能を用いて、@<img>{fullmesh} のネットワークを作ります。

//image[fullmesh][スイッチ 4 台から構成されるネットワーク]

このネットワーク構成を作るためには、@<list>{conf} のように記述します。

//list[conf][@<tt>{routing_switch_fullmesh.conf}]{
vswitch {
  datapath_id "0xe0"
}

vswitch {
  datapath_id "0xe1"
}

vswitch {
  datapath_id "0xe2"
}

vswitch {
  datapath_id "0xe3"
}

vhost ("host1") {
  ip "192.168.0.1"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:01"
}

vhost ("host2") {
  ip "192.168.0.2"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:02"
}

vhost ("host3") {
  ip "192.168.0.3"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:03"
}

vhost ("host4") {
  ip "192.168.0.4"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:04"
}

link "0xe0", "host1"
link "0xe1", "host2"
link "0xe2", "host3"
link "0xe3", "host4"
link "0xe0", "0xe1"
link "0xe0", "0xe2"
link "0xe0", "0xe3"
link "0xe1", "0xe2"
link "0xe1", "0xe3"
link "0xe2", "0xe3"

run {
  path "../apps/topology/topology"
}

run {
  path "../apps/topology/topology_discovery"
}

run {
  path "../apps/routing_switch/routing_switch"
}

event :port_status => "topology", :packet_in => "filter", :state_notify => "topology"
filter :lldp => "topology_discovery", :packet_in => "routing_switch"
//}

以下のように、@<tt>{-d} オプションを使い、デーモンモードで trema を起動します。

//cmd{
% trema run -c ./routing_switch_fullmesh.conf -d
//}

=== 見つけたリンクを表示する

@<tt>{topology} ディレクトリには、検出したトポロジーを表示するコマンドが用意されていますので、使ってみましょう。以下のように実行してください。

//cmd{
% ./apps/topology/show_topology -D
vswitch {
  datapath_id "0xe0"
}

vswitch {
  datapath_id "0xe2"
}

vswitch {
  datapath_id "0xe3"
}

vswitch {
  datapath_id "0xe1"
}

link "0xe3", "0xe2"
link "0xe1", "0xe0"
link "0xe3", "0xe0"
link "0xe2", "0xe1"
link "0xe2", "0xe0"
link "0xe3", "0xe1"
//}

ルーティングスイッチの起動時に指定した設定ファイル (@<list>{conf}) やネットワーク構成 (@<img>{fullmesh}) と比較してみましょう。@<tt>{topology_discovery} モジュールが検出できるのは、スイッチ間のリンクのみです。仮想ホストとスイッチ間のリンクは検出できないため、@<tt>{show_topology} の検出結果には表示されないことに注意しましょう。

=== パケットを送り、フローが設定されているかを確認する
   
次に、仮想ホストからパケットを送り、フローが設定されることを確認しましょう。

//cmd{
% trema send_packets --source host1 --dest host2
% trema send_packets --source host2 --dest host1
//}

ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行なっていないので、host1 から host2 へとパケットを送っただけではフローは設定されません。この段階で host1 の MAC アドレスを学習したので、host2 から host1 へと送った段階でフローが設定されます。

それでは、どのようなフローが設定されたかを見てみます。設定されているフローの確認は、@<tt>{trema dump_flows [表示したいスイッチの Datapath ID]} でできます。@<tt>{0xe0} から @<tt>{0xe1} まで順に表示してみましょう。

//cmd{
% trema dump_flows 0xe0
NXST_FLOW reply (xid=0x4):
 cookie=0x3, duration=41s, table=0, n_packets=0, n_bytes=0, idle_timeout=62, \
 ...	     		   	    		 	    		     \
 dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,nw_src=192.168.0.2,	     \
 nw_dst=192.168.0.1,nw_tos=0,tp_src=1,tp_dst=1 actions=output:3
% ./trema dump_flows 0xe1
NXST_FLOW reply (xid=0x4):
 cookie=0x3, duration=42s, table=0, n_packets=0, n_bytes=0, idle_timeout=61, \
 ...	     		   	    		 	    		     \
 dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,nw_src=192.168.0.2,	     \
 nw_dst=192.168.0.1,nw_tos=0,tp_src=1,tp_dst=1 actions=output:3
% ./trema dump_flows 0xe2
NXST_FLOW reply (xid=0x4):
% ./trema dump_flows 0xe3
NXST_FLOW reply (xid=0x4):
//}

@<tt>{0xe0} と @<tt>{0xe1} のスイッチそれぞれに、@<tt>{dl_src} が host2 の MAC アドレス、@<tt>{dl_dst} が host1 の MAC アドレスがマッチングルールのフローが設定されていることが分かります。一方で @<tt>{0xe2} と @<tt>{0xe3} のスイッチには、フローがありません。@<img>{fullmesh} をもう一度見てください。host2 から host1 への最短パスは@<tt>{0xe1} → @<tt>{0xe0} なので、この二つのスイッチにきちんとフローが設定されています。

== OpenFlow を使う利点

本章のはじめで説明したように、ルーティングスイッチは、OpenFlow ネットワークを普通の L2 スイッチとして動作させるコントローラアプリケーションです。普通の L2 スイッチとして動かすだけならば、わざわざ OpenFlow を使わなくてもよいのでは？と思うかもしれません。ここでは、OpenFlow で実現した場合の利点について、少し考えてみたいと思います。

=== リンク帯域を有効活用できる

通常の L2 スイッチで構成されたネットワークでは、パケットがループすることを防ぐために、スパニングツリープロトコルが用いられています。例えば、@<img>{spt1} のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ 2 とスイッチ 3 間のリンクが遮断され、ループが解消されます。この時、例えばホスト 2 からホスト 3 へのパケットは、この遮断されたリンクを通過できないため、スイッチ 1 を経由して転送されます。

//image[spt1][ループを含む構成では、一部のリンクを遮断する必要がある]

ルーティングスイッチでは、Packet In メッセージが送られてきた時に、そのパケットに対するフローを各スイッチに設定するという動作を行います。この時、Packet In を受信したスイッチから、出口となるスイッチまでの最短パスを計算し、そのパス上の各スイッチに対してフローの設定を行います。このため、ループを含むトポロジーであっても問題なく動作します。ブロックリンクを作る必要がないため、スパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使うことができます(@<img>{spt2})。

//image[spt2][ルーティングスイッチでは、ネットワーク中のリンクを有効に使うことができる]

=== いろいろなパス選択アルゴリズムを使える

パケットの通過するパスの決定は、OpenFlow コントローラであるルーティングスイッチが行っています。そのため、パス決定アルゴリズムを入れ替えるだけで、@<img>{multipath} のようにフロー毎に異なるパスを設定することが、簡単に出来ます。

//image[multipath][マルチパスを使って帯域を確保する]

このようなマルチパスは、従来の自律分散型の制御でも実現できますが、制限があります。IETF で標準化が行われている TRILL (Transparent Interconnect of Lots of Links) や IEEE で標準化が行われている SPB (Shortest Path Bridges) を用いれば、マルチパスを使用できます。ただし、コストが最短となるパスが複数存在する場合のみに限定されます@<fn>{ecmp}。なぜなら、各スイッチの自律分散で動作しているからです。各スイッチが、宛先に向かって最短となるパスに沿ってパケットの転送を行うことで、パケットはループすることなく宛先まで届きます。

一方、ルーティングスイッチでは、OpenFlow コントローラが一括してパスを決定し、各スイッチにフローが設定されます。そのため、@<img>{multipath} のように最短ではないパスを用いることもできます。

//footnote[ecmp][このようなパスを、イコールコストマルチパス (Equal Cost Multipath) と呼びます。]

== まとめ

本章で学んだことは、次の 3 つです。

 * 複数のスイッチからなる大規模ネットワークを扱うことができる、ルーティングスイッチがどのように動作するかを見てみました。
 * トポロジーを検出する仕組みを学びました。エミュレータ機能上のネットワークでの動作を通して、LLDP を使ったトポロジー検出の動作を理解しました。
 * 最短パスを計算する方法について学びました。

また、ルーティングスイッチの動作を参考に、L2 スイッチ機能を OpenFlow を使って実現する利点と欠点についても見てみました。次の章では、より本格的な Trema のアプリケーションとして、ルーティングスイッチを発展させたスライス機能付きスイッチについて説明します。

== 参考文献

: マスタリング TCP/IP 応用編 (Philip Miller 著、オーム社)
  L3 の経路制御プロトコルについて詳しく説明されています。本章で扱ったダイクストラ法を用いた経路制御プロトコルである OSPF についても説明がされているので、ルーティングスイッチとの違いを比べてみるのも面白いでしょう。

: 最短経路の本 レナのふしぎな数学の旅 (P・グリッツマンら著、シュプリンガー・ジャパン株式会社)
  最短経路を題材にした読み物で、難しい理論を知らなくても読むことができます。本章でも最短パスの計算を簡単に紹介しましたが、この本を読めばより理解が深まるでしょう。

