= いくつものスイッチをルーティングスイッチで制御する

//lead{
いよいよ OpenFlow で大規模なネットワークを作ります。まずは基礎固めとして、トポロジ情報の扱いに慣れておきましょう。
//}

私はネットワーク研究者という仕事柄、よく大小さまざまなネットワークを目にします。その中でもいつも「すごい!」とうならされるのが、すべてのネットワークエンジニアの憧れ、ShowNet です。これはネットワーク系最大の展示会 Interop の期間中だけ構築・運用されるネットワークで、最新ネットワーク技術のいわばショーケースとも言えるものです。普段は絶対に触ることのできない、ネットワーク界の F1 マシンとも言える最新機器を集めたライブデモンストレーションは圧巻の一言です。

ShowNet の魅力をもっともよく伝えてくれるアイテムが、Interop で毎年公開される ShowNet のトポロジ図です (@<img>{shownet_topology})。これの素晴らしいところは、ShowNet を構成するネットワーク機器同士の複雑な接続関係をたった一枚の図に収めているところです。「この部分は、いったいどんなプロトコルで動いているんだろう？」「実際の詳しいトポロジはどうなっているのかな？」ネットワークが好きな人であれば、気が付くと何時間でも眺めてしまうほどの魅力を持ったトポロジ図なのです。

//image[shownet_topology][2012 年 Interop の ShowNet トポロジ図。Copyright (C) 2012 Interop Tokyo ShowNet NOC Team. All Rights Reserved.][scale=0.6]

ShowNet のようにいくつものスイッチやルータがつながるネットワークの動作では、トポロジ情報の把握が一つの鍵です。パケットが迷子になったりループしたりせずに正しく目的地まで届けられるためには、スイッチやルータ同士がどのような接続関係にあるかをお互いに把握しなければなりません。

OpenFlow では、コントローラがこのトポロジ情報を検出します。集中管理の中心であるコントローラが全体のトポロジを把握することで、パケットを思いのままに転送できます。たとえば、ネットワーク上の最短パスでパケットを転送するだけでなく、特定の部分の回り道や複数のパスを使った転送 (マルチパス) も自由自在です。

ここではいくつものスイッチを制御するコントローラの一例として、ルーティングスイッチを紹介します。ルーティングスイッチがどのようにしてトポロジを把握し、パケットを目的地まで転送するかを見ていきましょう。

== 複数のスイッチを制御する

ルーティングスイッチは、複数台の OpenFlow スイッチを連動させ一つの大きなスイッチとして動作させるためのコントローラです (@<img>{routing_switch})。同じスイッチ機能を提供するコントローラとしては@<chap>{learning_switch}で紹介したラーニングスイッチがありましたが、これとの大きな違いは制御できるスイッチの台数です。ラーニングスイッチは 1 台の OpenFlow スイッチしか扱えない一方で、ルーティングスイッチは複数台の OpenFlow スイッチを制御できます。

//image[routing_switch][いくつもの OpenFlow スイッチを一つの大きなスイッチとして動作させる][scale=0.5]

=== ルーティングスイッチの動作

ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転送が複雑になります。多くの場合、宛先のホストまでいくつものスイッチを経由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指示してやる必要があるのです。

例えば、@<img>{flow_mod} において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみます。もしパケットを最短のパスで届けたい場合、スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローを最短パス上のスイッチ 1, 5, 6 へ書き込む必要があります。

//image[flow_mod][最短パスでパケットを転送するためにフローを書き込む][scale=0.5]

ルーティングスイッチコントローラの詳しい動作は次のようになります:

 1. パケットの道順を指定するため、スイッチ同士の接続情報であるトポロジ情報を収集します。トポロジ情報の中身は、スイッチ同士がどのポートでつながっているかを集めたものです (詳しい収集方法は後ほど説明)。
 2. ホスト 1 からホスト 4 宛てのパケットをスイッチ 1 から Packet In として受け取ります。
 3. FDB を検索し、宛先のホスト 4 が接続するスイッチとポート番号を検索します。その結果、スイッチ 6 とホスト 4 が接続するポート番号を得ます。
 4. Packet In を出したスイッチ 1 から出口となるスイッチ 6 までの最短パスをステップ 1 で収集したトポロジ情報を使って計算します。その結果、スイッチ 1 → スイッチ 5 → スイッチ 6 というパスを得ます。
 5. この最短パスに沿ってパケットが転送されるよう、パス上のスイッチそれぞれに Flow Mod を送りフローを書き込みます。
 6. 最初の Packet In を起こしたパケットも宛先に送るために、スイッチ 6 に Packet Out を送ります。

ここでキーとなるのは、ステップ 4 で使うトポロジ情報の収集方法と最短パスの計算方法です。まずは最短パスを説明します。

=== 最短パスを計算する

最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短路を求めるための汎用アルゴリズムの一つで、カーナビの経路探索や鉄道の乗換案内などにも使われています。

ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のようになります。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、みつかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、4 ホップ…というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します@<fn>{dijkstra}。

//footnote[dijkstra][ダイクストラ法はリンクに重み (距離) がある場合の最短路を求めることができるので、実際にはもう少し複雑な手順になります。ネットワーク上の最短パスではそれぞれのリンクは重み 1 として考えるので、このように単純化できます。]

//image[dijkstra][最短パスをダイクストラ法で計算する][scale=0.5]

実際に@<img>{routing_switch} のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ法で探索する手順は次のようになります (@<img>{dijkstra}):

 1. 始点となるスイッチ 1 に着目し、ここを 0 ホップとする。
 2. 始点のスイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ 1 から出るリンクの先に繋がっているスイッチで、スイッチ 2 とスイッチ 5 が見つかる。
 3. ステップ 2 でみつかったスイッチから 1 ホップで行けるすべてのスイッチを見つける。これはつまり、始点からのホップ数が 2 のすべてのスイッチということになる。今度はスイッチ 3, 4, 6 が見つかる。
 4. ゴールであるスイッチ 6 がみつかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 であることがわかる。

=== トポロジを検出する

ダイクストラ法には、"リンクの先に繋がっているスイッチを調べる"というステップがありました。これを実行するためには、コントローラはトポロジ情報を知っている必要があります。トポロジを検出するには、スイッチ間のリンクをすべて発見する必要があります。

==== リンクの発見

OpenFlow でリンクを発見する方法として代表的なのは、次の Link Layer Discovery Protocol (LLDP) パケットを使った方法です (@<img>{lldp_overview})。コントローラはどこにリンクがあるかあたりをつけるために、適当なスイッチ A に LLDP パケットを試しに送ります。もし、スイッチ A に別のスイッチ B がリンクでつながっていれば、LLDP パケットはそこのリンクを通りスイッチ B を経由してブーメランのようにコントローラへと戻ってきます。このように LLDP パケットが無事に戻ってくれば、スイッチ A と B はリンクでつながっているとわかります。また、LLDP パケットには通過したリンクの詳しい情報が書き込まれるので、スイッチ A と B がどのポート番号で接続しているかということまで分かります。これを繰り返していけば、最終的にはすべてのリンクを発見できるわけです。

//image[lldp_overview][LLDP を使ってリンクを発見する][scale=0.5]

「なぜ、LLDP パケットはきちんとリンクを通ってコントローラまで戻ってくるんだろう？スイッチに LLDP 固有のしかけが必要なのかな？」こう思った方もいるかもしれません。実は、LLDP によるリンク発見は今まで学んできた OpenFlow の仕組みだけを使って実現できます。つまり、OpenFlow に対応したスイッチであれば LLDP でリンクを発見できるのです。

LLDP によるリンク発見を OpenFlow で実現する方法を見ていきましょう。@<img>{lldp_openflow} のように、スイッチ 0x1 のポート 4 とスイッチ 0x2 のポート 1 が接続されていたとします。このリンクを発見するために、コントローラは以下の動作をします。

//image[lldp_openflow][LLDP パケットと OpenFlow の仕組みを使ってリンクを発見する][scale=0.5]

 1. コントローラは、接続関係を調べたいスイッチの Datapath ID 0x1 とポート番号 4 を埋め込んだ Link Layer Discovery Protocol (LLDP) パケットを作ります。
 2. ポート 4 から出力するというアクションを含む Packet Out メッセージを作り、先ほど作った LLDP パケットをスイッチ 0x1 へと送ります。
 3. Packet Out を受け取ったスイッチはアクションに従い、LLDP パケットを指定されたポート 4 から出力します。その結果、LLDP パケットは、ポート 4 の先につながるスイッチ 0x2 へと到着します。
 4. LLDP パケットを受け取ったスイッチ 0x2 は、自身のフローテーブルを参照し、パケットの処理方法を調べます。このとき LLDP に対するフローはあえて設定していないため、今回受信した LLDP パケットは、Packet In としてコントローラまで戻されます。
 5. コントローラは、受け取った Packet In メッセージを解析することで、リンクの発見を行います。スイッチ 0x2 からは @<img>{lldp-packet-in} の Packet In メッセージが送られきます。この中身を見ることで、スイッチ 0x1 のポート 4 と、スイッチ 0x2 のポート 1 の間にリンクを発見できます。

//image[lldp-packet-in][スイッチ 0x2 から送られてくる Packet In メッセージ][scale=0.7]

このように、Packet Out で送られた LLDP パケットは、リンクを通過し、隣のスイッチから Packet In でコントローラへと戻ってきます。この一連の動作によりコントローラは、リンクを発見できます。この方法自体は、OpenFlow 仕様で特に規定されているわけではありません。それぞれのスイッチは OpenFlow 仕様で定められた動作を行なっているだけです。つまり、Packet Out と Packet In をうまく使った "OpenFlow ならでは" のリンク発見方法だと言えます。

==== トポロジの検出

このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロジを知ることができます。たとえば @<img>{topology_before} のような 3 台の OpenFlow スイッチからなるネットワークにおいて、どのようにトポロジを検出するかを見ていきましょう。各 OpenFlow スイッチがコントローラに接続した直後の状態では、コントローラはスイッチ同士がどのように接続されているかを知りません。

//image[topology_before][トポロジ検出前のコントローラ][scale=0.5]

まずスイッチ 0x1 から調べていきます。はじめに Features Request メッセージを送ることで、スイッチ 0x1 が持つポート一覧を取得します。そして、それぞれのポートに対して、前述のリンク発見手順を行います(@<img>{topology_after})。その結果、スイッチ 0x1 からスイッチ 0x2 およびスイッチ 0x3 へと至るリンクがそれぞれ発見できます。

//image[topology_after][スイッチ 0x1 から出るリンクを発見][scale=0.5]

あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていくだけです。スイッチ 0x2, 0x3 に接続するリンクを順に調べていくことで、ネットワークの完全なトポロジ情報を知ることができます。

== 実行してみよう

ではルーティングスイッチを使って実際のトポロジ検出や最短路計算の動作を見ていきましょう。ルーティングスイッチは Trema Apps の一部として GitHub で公開されています。次のようにソースコードを取得してください。

//cmd{
% git clone https://github.com/trema/apps.git
//}

//noindent
ルーティングスイッチは次の 3 つのアプリケーションが連携して動作します。

 * @<tt>{topology}: 検出したトポロジ情報を管理する。
 * @<tt>{topology_discovery}: トポロジ情報を検出する。
 * @<tt>{routing_switch}: ルーティングスイッチ本体。

//noindent
この 3 つをセットアップするには、ダウンロードした Trema Apps の @<tt>{topology} と @<tt>{routing_switch} を次のようにコンパイルしてください。

//cmd{
% (cd apps/topology/; make)
% (cd apps/routing_switch; make)
//}

//noindent
これで準備は完了です。

=== ルーティングスイッチを動かす

それでは、ルーティングスイッチを動かしてみましょう。Trema のネットワークエミュレータ機能を用いて、@<img>{fullmesh} のネットワークを作ります。

//image[fullmesh][スイッチ 4 台からなるネットワーク][scale=0.5]

//noindent
設定ファイルは@<list>{conf} のようになります。

//list[conf][@<tt>{routing_switch_fullmesh.conf}]{
vswitch { datapath_id "0x1" }
vswitch { datapath_id "0x2" }
vswitch { datapath_id "0x3" }
vswitch { datapath_id "0x4" }

vhost ("host1") {
  ip "192.168.0.1"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:01"
}
vhost ("host2") {
  ip "192.168.0.2"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:02"
}
vhost ("host3") {
  ip "192.168.0.3"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:03"
}
vhost ("host4") {
  ip "192.168.0.4"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:04"
}

link "0x1", "host1"
link "0x2", "host2"
link "0x3", "host3"
link "0x4", "host4"
link "0x1", "0x2"
link "0x1", "0x3"
link "0x1", "0x4"
link "0x2", "0x3"
link "0x2", "0x4"
link "0x3", "0x4"

run {
  path "../apps/topology/topology"
}
run {
  path "../apps/topology/topology_discovery"
}
run {
  path "../apps/routing_switch/routing_switch"
}

event :port_status => "topology", :packet_in => "filter", :state_notify => "topology"
filter :lldp => "topology_discovery", :packet_in => "routing_switch"
//}

//noindent
ルーティングスイッチを起動するには、次のようにデーモンモードで起動してください。

//cmd{
% trema run -c ./routing_switch_fullmesh.conf -d
//}

//noindent
それでは起動したルーティングスイッチを使ってトポロジがどのように検出できているかを見てみましょう。

=== トポロジを表示する

Trema Apps の @<tt>{topology} ディレクトリには、検出したトポロジを表示するコマンド @<tt>{show_topology} が用意されています。以下のように実行すると、検出したトポロジを仮想ネットワーク設定ファイルと同じフォーマットで出力します。

//cmd{
% ./apps/topology/show_topology -D
vswitch {
  datapath_id "0x1"
}

vswitch {
  datapath_id "0x3"
}

vswitch {
  datapath_id "0x4"
}

vswitch {
  datapath_id "0x2"
}

link "0x4", "0x3"
link "0x2", "0x1"
link "0x4", "0x1"
link "0x3", "0x2"
link "0x3", "0x1"
link "0x4", "0x2"
//}

ルーティングスイッチの起動時に指定した設定ファイル (@<list>{conf}) と比較すると、スイッチ間のリンクがうまく検出できていることがわかります。しかし、仮想ホストとスイッチ間のリンクは検出できていません。LLDP と OpenFlow によるトポロジ検出は、あくまでスイッチ間のリンクを検出する仕組みだからです。

=== 最短パスを通すフローを確認する
   
次に host1 と host2 の間でパケットを送受信し、最短パスを通すフローがうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行なっていないので、host1 から host2 へとパケットを送っただけではフローは設定されません。そこで次のように両方向でパケットを送った段階でフローが設定されます。

//cmd{
% trema send_packets --source host1 --dest host2
% trema send_packets --source host2 --dest host1
//}

それでは、どのようなフローが設定されたかを見てみます。設定されているフローの確認は、@<tt>{trema dump_flows [表示したいスイッチの Datapath ID]} でできます。まずは host1 から host2 への最短パスであるスイッチ 0x1, 0x2 のフローテーブルを見てみましょう。

//cmd{
% trema dump_flows 0x1
NXST_FLOW reply (xid=0x4):
 cookie=0x3, duration=41s, table=0, n_packets=0, n_bytes=0, idle_timeout=62, \
 ...	     		   	    		 	    		     \
 dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,nw_src=192.168.0.2,	     \
 nw_dst=192.168.0.1,nw_tos=0,tp_src=1,tp_dst=1 actions=output:3
% ./trema dump_flows 0x2
NXST_FLOW reply (xid=0x4):
 cookie=0x3, duration=42s, table=0, n_packets=0, n_bytes=0, idle_timeout=61, \
 ...	     		   	    		 	    		     \
 dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,nw_src=192.168.0.2,	     \
 nw_dst=192.168.0.1,nw_tos=0,tp_src=1,tp_dst=1 actions=output:3
//}

//noindent
出力より、@<tt>{0x1} と @<tt>{0x2} のスイッチそれぞれに host2 → host1 のフローが設定されていることが分かります。

一方で、最短パス上にないスイッチ @<tt>{0x3}, @<tt>{0x4} はパケットが通らないため、次のようにフローがありません。

//cmd{
% ./trema dump_flows 0x3
NXST_FLOW reply (xid=0x4):
% ./trema dump_flows 0x4
NXST_FLOW reply (xid=0x4):
//}

//noindent
以上でルーティングスイッチにおけるトポロジ検出と最短パス計算の動作を見てきました。これらは OpenFlow で大規模なネットワークを扱う際の基本的なテクニックですので、ぜひ習得してください。

== OpenFlow を使う利点

本章のはじめで説明したように、ルーティングスイッチは OpenFlow ネットワークを一台の仮想的なスイッチとして動作させるコントローラアプリケーションです。普通のスイッチを真似るだけならば、わざわざ OpenFlow を使わなくてもよいのでは？と思うかもしれません。ここでは、OpenFlow を使った場合の利点について考えてみたいと思います。

=== リンク帯域を有効活用できる

通常のスイッチで構成されたネットワークでは、パケットのループを防ぐためにスパニングツリープロトコルでリンクの一部を遮断します。例えば、@<img>{spt1} のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ 2 とスイッチ 3 間のリンクが遮断されループが解消します。この時、例えばホスト 2 からホスト 3 へのパケットは、この遮断されたリンクを通過できないため、スイッチ 1 を経由して転送します。これは明かに無駄な回り道で、せっかくのリンク帯域が無駄になっています。

//image[spt1][スパニングツリーではループを避けるために一部のリンクを遮断する][scale=0.5]

一方、ルーティングスイッチではコントローラがトポロジ全体を把握しているため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路を各スイッチにフローとして明示的に指示するため、ループを含むトポロジであっても問題なく動作します。このためスパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使うことができます (@<img>{spt2})。

//image[spt2][ルーティングスイッチではネットワーク中のリンクを有効に使える][scale=0.5]

=== いろいろなパス選択アルゴリズムを使える

パスの決定はコントローラによる集中管理なので、コントローラのパス決定アルゴリズムを入れ替えるだけでさまざまなパス選択ができます。今回、ルーティングスイッチではダイクストラ法による最短パスを使いましたが、たとえば @<img>{multipath} のようにフロー毎に異なるパスを設定することで、帯域確保のためのマルチパスを作ることも簡単にできます。

//image[multipath][OpenFlow では最短でないパスを含んだマルチパスを自由に作れる][scale=0.5]

このようなマルチパスは従来の自律分散型でも実現できますが、きつい制限があります。マルチパスを実現できる自律分散型制御には、IETF が標準化を行う TRILL (Transparent Interconnect of Lots of Links) や IEEE が標準化を行う SPB (Shortest Path Bridges) などがあります。これらがマルチパスを作れる条件は、最短となるパスが何本もある場合@<fn>{ecmp}に限ります。なぜなら、最短パスが何本もあれば、各スイッチが自律的にそれぞれの最短パスに沿ってパケットの転送を行えるからです。この場合ループは起こりません。最短でないパスは選べませんし、最短パスが 1 本だけの場合にはマルチパスになりません。

//footnote[ecmp][このようなパスを、イコールコストマルチパス (Equal Cost Multipath) と呼びます。]

== まとめ

いくつものスイッチからなるネットワークを扱うことができる、ルーティングスイッチの動作を見てきました。この章で学んだことを簡単にまとめておきましょう。
 
 * ネットワーク上の最短パスを計算する方法を学びました。
 * LLDP でトポロジを検出する仕組みを学びました。また Trema のネットワークエミュレータを使って、ルーティングスイッチの topology モジュールの動作を理解しました。
 * ルーティングスイッチの動作を参考に、OpenFlow によるスイッチ機能の利点と欠点を学びました。
 
 次の章では、ネットワーク仮想化を実現する本格的な SDN アプリケーションの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。

== 参考文献

: 最短経路の本 レナのふしぎな数学の旅 (P・グリッツマンら著、シュプリンガー・ジャパン)
  最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章ではネットワーク上での最短パスを求める場合のダイクストラ法を紹介しましたが、リンクに重みがある場合の一般的なダイクストラ法についてはこの本がおすすめです。

: マスタリング TCP/IP 応用編 (Philip Miller 著、オーム社)
  とくにレイヤ 3 の経路制御プロトコルについて詳しく説明した本です。ダイクストラ法を用いた経路制御プロトコルの一つである OSPF についても説明しているので、ルーティングスイッチとの違いを比べてみるのも面白いでしょう。
