= ルーティングスイッチ: いくつものスイッチを制御する

私はネットワーク研究者という仕事柄、よく大小さまざまなネットワークを目にします。その中でも最もすごいと感じるのが、ネットワーク業界ではおなじみの ShowNet です。これはネットワーク系最大の展示会 Interop の期間中だけ運用されるネットワークで、最新鋭のネットワーク機器を一堂に集めたショーケースとも言えるものです。ふつうは絶対に触ることのできない、ネットワーク機器の F1 マシンとも言える最新機器たちが目の前で動くさまは圧巻の一言です。

私のようなネットワーク大好き人間を魅了するもうひとつの名物が、Interop で配られる ShowNet のトポロジ図 (ネットワーク機器同士の接続関係を表した図) です。これの見どころは、一流のネットワークエンジニア達による複雑な ShowNet が美しい一枚の図で表現されているところです。「この部分は、いったいどんなプロトコルで動いているんだろう？」「実際の詳しいトポロジはどうなっているのかな？」詳しく見れば見るほど、私の妄想は止まりません。

(ここに ShowNet のトポロジ図。キャプションは指定されたものを使う。)

ShowNet のようにいくつものスイッチやルータがつながるネットワークでは、トポロジー情報が一つの鍵です。パケットが迷子になったりループしたりせずに正しく目的地まで届けられるためには、スイッチやルータ同士がどのような接続関係にあるかをお互いに把握しなければなりません。

OpenFlow では、コントローラがこのトポロジ情報を検出します。集中管理の中心であるコントローラが全体のトポロジを把握することで、パケットを思いのままに転送できます。たとえば、ネットワーク上の最短パスでパケットを転送するだけでなく、特定の部分を回り道させたり複数のパスを使った転送も自由自在です。

ここではいくつものスイッチを制御するコントローラの一例として、ルーティングスイッチを紹介します。ルーティングスイッチがどのようにしてトポロジを把握し、パケットを目的地まで転送するかを見ていきましょう。

== 複数のスイッチを扱う

ルーティングスイッチは、複数台の OpenFlow スイッチを連動させ一つの大きなスイッチとして動作させるためのコントローラです (@<img>{routing_switch})。同じくスイッチ機能を提供するラーニングスイッチ (@<chap>{learning_switch}で紹介) との違いは、ラーニングスイッチは 1 台の OpenFlow スイッチしか扱えない一方で、ルーティングスイッチは複数台の OpenFlow スイッチを制御できるところです。

//image[routing_switch][複数台の OpenFlow スイッチを、一つの大きなスイッチとして動作させる]

=== ルーティングスイッチの動作

ラーニングスイッチとルーティングスイッチの動作の一番の違いは、パケットが経由するスイッチの数です。ルーティングスイッチでは多くの場合、パケットの入口となるスイッチと出口となるスイッチが異なります。このため、パケットをいくつものスイッチを経由して届けなくてはならず、正しい道順の情報が必要です。

例えば、@<img>{flow_mod} のネットワークにおいて、ホスト 1 からホスト 4 へとパケットを届ける場合について考えてみます。ホスト 1 はスイッチ 1 へ、ホスト 4 はスイッチ 6 へと、それぞれ違うスイッチに接続されています。そのため、もし最短のパスで届けたい場合、スイッチ 1 からスイッチ 5、スイッチ 6 の順にパケットを転送しホスト 4 へと届くように各スイッチへフローを書き込みます。

//image[flow_mod][最短パスでパケットを転送するためにフローを書き込む]

この時のルーティングスイッチの動作は次のようになります:

 1. ホスト 1 からホスト 4 へのパケットをスイッチ 1 から Packet In として受け取る。
 2. FDB を検索し、宛先ホストが接続するスイッチとポートを検索する。その結果、スイッチ 6 と、ホスト 4 が接続するポート番号を得る。
 3. Packet In を送ったスイッチ 1 から出口となるスイッチ 6 までの最短パスをトポロジ情報を使って計算する。ここではスイッチ 5 を経由するパスが得られる。
 4. 得られた最短パスに沿ってパケットが転送されるよう、パス上のスイッチそれぞれに Flow Mod を送りフローを書き込む。
 5. 最初の Packet In を起こしたパケットも宛先に送るために、スイッチ 6 に Packet Out を送る。

ここでキーとなるのは、ステップ 3 で使うトポロジ情報の作り方と最短パスの計算方法です。まずは最短パスを説明します。

=== 最短パスを計算する

最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。これは、最短路を求めるための有名なアルゴリズムの一つで、カーナビの経路探索や鉄道の乗換案内などにも使われています。

//image[dijkstra][最短パスをダイクストラ法で計算する]

ダイクストラ法を使った最短パスの計算は次のようになります:

 1. 始点となるスイッチ 1 に着目します (@<img>{dijkstra} (a))。
 2. 始点のスイッチ 1 から 1 ホップで行けるすべてのスイッチを見つけます。これはスイッチ 1 から出るリンクの先に繋がっているスイッチです。つまり、スイッチ 2 とスイッチ 5 が見つけ出せます (@<img>{dijkstra} (b))。これらのスイッチを、始点からの距離が 1 のスイッチとします。
 3. 同じようにして、ステップ 2 でみつかったスイッチから 1 ホップで行けるすべてのスイッチを見つけます。これはつまり、始点からの距離が 2 のスイッチ全体ということになります。今度はスイッチ 3, 4, 6 が見つかります (@<img>{dijkstra} (c))。このように、1 ホップずつ足を伸ばしていき終点のスイッチに到達するまで続けます。
 4. 終点であるスイッチ 6 が、スイッチ 5 の先で見つかりますので、最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 であることがわかります。

=== トポロジーを検出する

コントローラが、スイッチ同士がどのように接続しているかという情報 (トポロジー情報) を調べる方法について紹介します。ダイクストラ法には、``リンクの先に繋がっているスイッチを調べる'' というステップがありました。このステップを実行するためには、コントローラはトポロジー情報を知っている必要があります。

//image[lldps0][LLDP を使ってリンクを発見する][scale=0.7]

実際に、コントローラがスイッチ間のリンクを発見するにはどのようにすればよいでしょうか？コントローラが作り、送り出したパケットがブーメランのように戻ってきた時の情報を用いて、リンクの発見を行います。例えば、@<img>{lldps0} のように、スイッチ 0x1 のポート 4 とスイッチ 0x2 のポート 1 が接続されていたとします。このリンクを発見するために、コントローラは以下の手順を行います。

 1. まずコントローラは、接続関係を調べたいスイッチの Datapath ID 0x1 とポート番号 4 を埋め込んだ Link Layer Discovery Protocol (LLDP) パケットを作ります。
 2. ポート 4 から出力するというアクションを含む Packet Out メッセージを作り、先ほど作った LLDP パケットをスイッチ 0x1 へと送ります。
 3. Packet Out を受け取ったスイッチはアクションに従い、LLDP パケットを指定されたポート 4 から出力します。その結果、LLDP パケットは、ポート 4 の先につながるスイッチ 0x2 へと到着します。
 4. LLDP パケットを受け取ったスイッチ 0x2 は、自身のフローテーブルを参照し、パケットの処理方法を調べます。このとき LLDP に対するフローはあえて設定していないため、今回受信した LLDP パケットは、Packet In としてコントローラまで戻されます。
 5. コントローラは、受け取った Packet In メッセージを解析することで、リンクの発見を行います。スイッチ 0x2 からは @<img>{lldp-packet-in} の Packet In メッセージが送られきます。この中身を見ることで、スイッチ 0x1 のポート 4 と、スイッチ 0x2 のポート 1 の間にリンクを発見できます。

//image[lldp-packet-in][スイッチ 0x2 から送られてくる Packet In メッセージ][scale=0.7]

このように、Packet Out で送られた LLDP パケットは、リンクを通過し、隣のスイッチから Packet In でコントローラへと戻ってきます。この一連の動作によりコントローラは、リンクを発見することができます。

この方法自体は、仕様で特に規定されているわけではありません。しかし、上記の 3, 4 のステップで、それぞれのスイッチは OpenFlow スイッチの仕様として定められた動作を行なっているだけです。つまりこの方法は、特別な動作を必要とせず、仕様に従っていればどのような OpenFlow スイッチでも使えるため、OpenFlow ではよく用いられています。Packet Out と Packet In を用いた ``OpenFlow ならでは'' のリンク発見方法だと言えます。

このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロジーを知ることができます。例えば @<img>{lldp0} のような 3 台の OpenFlow スイッチからなるネットワークにおいて、どのようにトポロジーが検出されるかを見ていきましょう。@<img>{lldp0} は各 OpenFlow スイッチがコントローラに接続した直後の状態です。この段階で、コントローラは、スイッチ同士がどのように接続されているかを知りません。

//image[lldp0][トポロジー検出前][scale=0.7]

まず スイッチ 0x1 から調べていきます。はじめに Features Request メッセージを送ることで、スイッチ 0x1 が持つポート一覧を取得します。そして、それぞれのポートに対して、前述のリンク発見手順を行います(@<img>{lldp1})。その結果、スイッチ 1 からスイッチ 2 およびスイッチ 3 へと至るリンクがそれぞれ発見できます。

//image[lldp1][スイッチ 0x1 のリンク発見][scale=0.7]

あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていくだけです。スイッチ 2, 3 に接続するリンクを順に調べていくことで、ネットワークの完全なトポロジー情報を知ることができます。

== 実行してみよう

ルーティングスイッチは、Trema Apps の一部として、Github 上で公開されています。公開されているルーティングスイッチを使いながら、実際の動作を見ていきましょう。

=== 準備

Trema Apps のソースコードは、@<tt>{https://github.com/trema/apps/} にあります。まずは、@<tt>{git} を使って、ソースコードを取得しましょう。

//cmd{
% git clone https://github.com/trema/apps.git
//}

@<chap>{trema_architecture} で紹介したように、Trema Apps 中はさまざまなアプリケーションがあります。そのうち、今回使用するのは @<tt>{topology} と @<tt>{routing_switch} です。@<tt>{topology} は、トポロジー検出を担当するモジュール @<tt>{topology_discovery} と検出したトポロジーを管理するモジュール @<tt>{topology} を含んでいます。また @<tt>{routing_switch} は、ルーティングスイッチの本体を含んでいます。各モジュールの関係を @<img>{modules} に示します。

//image[modules][ルーティングスイッチの動作に必要なモジュール][scale=0.7]

@<tt>{topology} と @<tt>{routing_switch} を順に @<tt>{make} してください。

//cmd{
% (cd apps/topology/; make)
% (cd apps/routing_switch; make)
//}

=== ルーティングスイッチを動かす

それでは、ルーティングスイッチを動かしてみましょう。今回は Trema のネットワークエミュレータ機能を用いて、@<img>{fullmesh} のネットワークを作ります。

//image[fullmesh][スイッチ 4 台から構成されるネットワーク]

このネットワーク構成を作るためには、@<list>{conf} のように記述します。

//list[conf][@<tt>{routing_switch_fullmesh.conf}]{
vswitch {
  datapath_id "0xe0"
}

vswitch {
  datapath_id "0xe1"
}

vswitch {
  datapath_id "0xe2"
}

vswitch {
  datapath_id "0xe3"
}

vhost ("host1") {
  ip "192.168.0.1"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:01"
}

vhost ("host2") {
  ip "192.168.0.2"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:02"
}

vhost ("host3") {
  ip "192.168.0.3"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:03"
}

vhost ("host4") {
  ip "192.168.0.4"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:04"
}

link "0xe0", "host1"
link "0xe1", "host2"
link "0xe2", "host3"
link "0xe3", "host4"
link "0xe0", "0xe1"
link "0xe0", "0xe2"
link "0xe0", "0xe3"
link "0xe1", "0xe2"
link "0xe1", "0xe3"
link "0xe2", "0xe3"

run {
  path "../apps/topology/topology"
}

run {
  path "../apps/topology/topology_discovery"
}

run {
  path "../apps/routing_switch/routing_switch"
}

event :port_status => "topology", :packet_in => "filter", :state_notify => "topology"
filter :lldp => "topology_discovery", :packet_in => "routing_switch"
//}

以下のように、@<tt>{-d} オプションを使い、デーモンモードで trema を起動します。

//cmd{
% trema run -c ./routing_switch_fullmesh.conf -d
//}

=== 見つけたリンクを表示する

@<tt>{topology} ディレクトリには、検出したトポロジーを表示するコマンドが用意されていますので、使ってみましょう。以下のように実行してください。

//cmd{
% ./apps/topology/show_topology -D
vswitch {
  datapath_id "0xe0"
}

vswitch {
  datapath_id "0xe2"
}

vswitch {
  datapath_id "0xe3"
}

vswitch {
  datapath_id "0xe1"
}

link "0xe3", "0xe2"
link "0xe1", "0xe0"
link "0xe3", "0xe0"
link "0xe2", "0xe1"
link "0xe2", "0xe0"
link "0xe3", "0xe1"
//}

ルーティングスイッチの起動時に指定した設定ファイル (@<list>{conf}) やネットワーク構成 (@<img>{fullmesh}) と比較してみましょう。@<tt>{topology_discovery} モジュールが検出できるのは、スイッチ間のリンクのみです。仮想ホストとスイッチ間のリンクは検出できないため、@<tt>{show_topology} の検出結果には表示されないことに注意しましょう。

=== パケットを送り、フローが設定されているかを確認する
   
次に、仮想ホストからパケットを送り、フローが設定されることを確認しましょう。

//cmd{
% trema send_packets --source host1 --dest host2
% trema send_packets --source host2 --dest host1
//}

ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行なっていないので、host1 から host2 へとパケットを送っただけではフローは設定されません。この段階で host1 の MAC アドレスを学習したので、host2 から host1 へと送った段階でフローが設定されます。

それでは、どのようなフローが設定されたかを見てみます。設定されているフローの確認は、@<tt>{trema dump_flows [表示したいスイッチの Datapath ID]} でできます。@<tt>{0xe0} から @<tt>{0xe1} まで順に表示してみましょう。

//cmd{
% trema dump_flows 0xe0
NXST_FLOW reply (xid=0x4):
 cookie=0x3, duration=41s, table=0, n_packets=0, n_bytes=0, idle_timeout=62, \
 ...	     		   	    		 	    		     \
 dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,nw_src=192.168.0.2,	     \
 nw_dst=192.168.0.1,nw_tos=0,tp_src=1,tp_dst=1 actions=output:3
% ./trema dump_flows 0xe1
NXST_FLOW reply (xid=0x4):
 cookie=0x3, duration=42s, table=0, n_packets=0, n_bytes=0, idle_timeout=61, \
 ...	     		   	    		 	    		     \
 dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,nw_src=192.168.0.2,	     \
 nw_dst=192.168.0.1,nw_tos=0,tp_src=1,tp_dst=1 actions=output:3
% ./trema dump_flows 0xe2
NXST_FLOW reply (xid=0x4):
% ./trema dump_flows 0xe3
NXST_FLOW reply (xid=0x4):
//}

@<tt>{0xe0} と @<tt>{0xe1} のスイッチそれぞれに、@<tt>{dl_src} が host2 の MAC アドレス、@<tt>{dl_dst} が host1 の MAC アドレスがマッチングルールのフローが設定されていることが分かります。一方で @<tt>{0xe2} と @<tt>{0xe3} のスイッチには、フローがありません。@<img>{fullmesh} をもう一度見てください。host2 から host1 への最短パスは@<tt>{0xe1} → @<tt>{0xe0} なので、この二つのスイッチにきちんとフローが設定されています。

== OpenFlow を使う利点

本章のはじめで説明したように、ルーティングスイッチは、OpenFlow ネットワークを普通の L2 スイッチとして動作させるコントローラアプリケーションです。普通の L2 スイッチとして動かすだけならば、わざわざ OpenFlow を使わなくてもよいのでは？と思うかもしれません。ここでは、OpenFlow で実現した場合の利点について、少し考えてみたいと思います。

=== リンク帯域を有効活用できる

通常の L2 スイッチで構成されたネットワークでは、パケットがループすることを防ぐために、スパニングツリープロトコルが用いられています。例えば、@<img>{spt1} のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ 2 とスイッチ 3 間のリンクが遮断され、ループが解消されます。この時、例えばホスト 2 からホスト 3 へのパケットは、この遮断されたリンクを通過できないため、スイッチ 1 を経由して転送されます。

//image[spt1][ループを含む構成では、一部のリンクを遮断する必要がある]

ルーティングスイッチでは、Packet In メッセージが送られてきた時に、そのパケットに対するフローを各スイッチに設定するという動作を行います。この時、Packet In を受信したスイッチから、出口となるスイッチまでの最短パスを計算し、そのパス上の各スイッチに対してフローの設定を行います。このため、ループを含むトポロジーであっても問題なく動作します。ブロックリンクを作る必要がないため、スパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使うことができます(@<img>{spt2})。

//image[spt2][ルーティングスイッチでは、ネットワーク中のリンクを有効に使うことができる]

=== いろいろなパス選択アルゴリズムを使える

パケットの通過するパスの決定は、OpenFlow コントローラであるルーティングスイッチが行っています。そのため、パス決定アルゴリズムを入れ替えるだけで、@<img>{multipath} のようにフロー毎に異なるパスを設定することが、簡単に出来ます。

//image[multipath][マルチパスを使って帯域を確保する]

このようなマルチパスは、従来の自律分散型の制御でも実現できますが、制限があります。IETF で標準化が行われている TRILL (Transparent Interconnect of Lots of Links) や IEEE で標準化が行われている SPB (Shortest Path Bridges) を用いれば、マルチパスを使用できます。ただし、コストが最短となるパスが複数存在する場合のみに限定されます@<fn>{ecmp}。なぜなら、各スイッチの自律分散で動作しているからです。各スイッチが、宛先に向かって最短となるパスに沿ってパケットの転送を行うことで、パケットはループすることなく宛先まで届きます。

一方、ルーティングスイッチでは、OpenFlow コントローラが一括してパスを決定し、各スイッチにフローが設定されます。そのため、@<img>{multipath} のように最短ではないパスを用いることもできます。

//footnote[ecmp][このようなパスを、イコールコストマルチパス (Equal Cost Multipath) と呼びます。]

== まとめ

本章で学んだことは、次の 3 つです。

 * 複数のスイッチからなる大規模ネットワークを扱うことができる、ルーティングスイッチがどのように動作するかを見てみました。
 * トポロジーを検出する仕組みを学びました。エミュレータ機能上のネットワークでの動作を通して、LLDP を使ったトポロジー検出の動作を理解しました。
 * 最短パスを計算する方法について学びました。

また、ルーティングスイッチの動作を参考に、L2 スイッチ機能を OpenFlow を使って実現する利点と欠点についても見てみました。次の章では、より本格的な Trema のアプリケーションとして、ルーティングスイッチを発展させたスライス機能付きスイッチについて説明します。

== 参考文献

: マスタリング TCP/IP 応用編 (Philip Miller 著、オーム社)
  L3 の経路制御プロトコルについて詳しく説明されています。本章で扱ったダイクストラ法を用いた経路制御プロトコルである OSPF についても説明がされているので、ルーティングスイッチとの違いを比べてみるのも面白いでしょう。

: 最短経路の本 レナのふしぎな数学の旅 (P・グリッツマンら著、シュプリンガー・ジャパン株式会社)
  最短経路を題材にした読み物で、難しい理論を知らなくても読むことができます。本章でも最短パスの計算を簡単に紹介しましたが、この本を読めばより理解が深まるでしょう。

