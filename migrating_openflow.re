= 生活ネットワークをOpenFlowに移行する

//lead{
あとは実践あるのみ!今までの知識を総動員し、自宅や職場のネットワークをOpenFlow化していろいろ実験してみましょう。
//}

//indepimage[bicycle][][width=10cm]

== どんどん規模を広げていこう

第I部、II部を通じてOpenFlowのプロトコルや動作モデル、そしてTremaを使ったOpenFlowプログラミングを学んできました。一人前のOpenFlowエンジニアとしてやっていくために必要な基礎知識はすでにひととおり身についたと言えます。

あとはひたすら実践するだけです。今まで手に入れた知識を実際に道具として使い、いま生活しているネットワーク上でOpenFlowを実際に動かしてみるのが一番です。まずは自宅のネットワークをOpenFlowで置き換えましょう。これがうまくいき物足りなくなったら、こんどは職場で小規模にOpenFlowネットワークを作りましょう。このように徐々に規模を広げて行くのです。

実際にその環境で暮らしてみて、はじめて見えてくるニーズやアイデア、改善案があります。初めて自転車に乗ったときのことを思い出してください。補助輪をはずしただけで最初は派手に転びますが、多少はケガをしつつもあきらめずに練習を繰り返しているうち誰でも乗りこなせるようになります。自転車に乗れれば、隣りの街やそのまた隣りと行動範囲は一気に広がります。しかし補助輪をはずさずにただ考えているだけではどこにも行けません。

== 大ケガしないためのヘルメット

「でも、いきなりOpenFlowに移行してもし大失敗したら……」。そう考えるのが人情です。家のネットワークはともかく、もし職場のネットワークを止めて同僚に迷惑をかけてしまったらどうしよう……。管理者や上司に注意されたらどうしよう……。

本章ではそうした大失敗を防ぐための「ヘルメット」を紹介します。筆者らは、OpenFlowが登場したころから職場のネットワークで実験を始め、それこそ数え切れないほどの失敗を繰り返してきました。とにかく何度も怒られましたが、その経験からうまくやる方法をアドバイスできます。私たちは既存のネットワークを穏便にOpenFlowに移行するテクニックを持っています。ちょっとしたOpenFlowコントローラを書くだけで、移行の際に起こりがちなネットワーク障害を簡単に防げるのです。

まずは、私たちの失敗談を振り返らせてください。

== 私たちの失敗談

話は2009年までさかのぼります。OpenFlowが登場したばかりの当時、私たちはさっそくスイッチングハブ相当のOpenFlowコントローラを書いて小さなOpenFlowネットワークを職場に構築してみました。「おお、ちゃんと動くじゃん!」気を良くした私たちは、こともあろうにこのOpenFlowネットワークと職場ネットワークとをいきなりつないでしまいました。まあ大丈夫だろうと楽観的に考えていたのです。

しかしすぐにネットワーク障害が起こり、異常に気づいたネットワーク管理者からお叱りのメールを受け取ることになりました。障害時のセットアップを単純化すると@<img>{buggy_controller_setup}のようになります。

//image[buggy_controller_setup][障害を起こしたときのネットワーク構成を単純化したもの][width=12cm]

//noindent
職場ネットワーク（レガシーネットワークとします）のスイッチにはホストを2台つないでおり、スイッチのポート3番をOpenFlowスイッチのポート1番と接続しました。このOpenFlowスイッチは、私たちが書いたスイッチングハブ相当のOpenFlowコントローラ(仮にBuggyControllerとします)で制御していました。

=== 障害報告：Host Flappingが起こっている

ネットワーク管理者から届いた障害報告メールには次のようにありました「レガシーネットワークのホストどうしが通信できなくなった。スイッチはHost Flapping警告を出している」

Host Flappingとは、1つのホストがいくつかのポートの間で高速で移動しているように見えるという障害です。「なんでそんなことが起こるんだろう？」われわれはすぐにOpenFlowネットワークを切断し、そしてもちろんネットワーク管理者にはごめんなさいメールを出してから、原因の分析にとりかかりました。

=== 障害原因が判明

分析の結果、@<img>{failure_analysis}のようなシナリオが起こっているという結論に至りました。

//image[failure_analysis][レガシーネットワークで起こった障害のシナリオ][width=12cm]

 1. host1がhost2へパケットを送信する
 2. BuggyControllerはOpenFlowスイッチポート1番からのPacket Inを受け取り、OpenFlowスイッチのスイッチポート1番にhost1がつながっていると学習する
 3. host2がhost1へパケットを送信する
 4. BuggyControllerはスイッチポート1番から「宛先＝host1」のPacket Inを受け取る。ここで、host1はOpenFlowスイッチのスイッチポート1番にあると学習しているので、スイッチポート1番にPacket Outする
 5. 結果的に、host1はポート2と3の両方から同じパケットを受け取る。レガシーネットワークのスイッチから見ると、host2がスイッチポート2番と3番を高速に移動しているように見える

つまり、BuggyControllerがレガシーネットワークにパケットを逆流させたおかげでネットワークが大混乱し、通信できない状況が起きたのです。

=== 教訓：これをやってはいけない

振り返ると、失敗した原因は2つありました。

1つは、OpenFlowネットワークをいきなりレガシーネットワークとつないでしまったことです。OpenFlowネットワーク単体では動いていたのに、というのは言い訳にはなりません。若気の至りや経験不足から来る「青い」ミスです。もう1つは、BuggyControllerがPacket Inと同じポートにPacket Outするという通常あり得ない動作をしていたことです。要所要所で@<tt>{assert}を入れるといった防御的プログラミングや、ユニットテストを徹底していれば@<fn>{unittest}防げるバグでしたが、当時の私たちは動かすことに精いっぱいでそこまで気が回りませんでした。

//footnote[unittest][ユニットテストを使ったコントローラの開発手法については@<chap>{tdd}で解説します。]

というわけで、大障害を起こして始めて気付くという最悪のパターンになってしまったわけです。

== OpenFlowへの移行パターン

大失敗をやらかしてしまった筆者たちは、OpenFlow移行のための作戦を練りなおさざるを得なくなりました。いろいろな方向から考えなおしたところ、OpenFlowへの移行方法には次の3つのパターンがあることがわかりました。もちろん、それぞれでメリット／デメリットや危険度が異なります。

=== A：独立ネットワークパターン

最初のパターンは、既存のレガシーネットワークにまったく手を加えずに、それとは独立したもうひとつのOpenFlowネットワークを構築する方法です(@<img>{pattern1})。それぞれのネットワーク間でパケットの行き来はなく、お互いに完全に独立しています。

//image[pattern1][レガシーネットワークとは独立したOpenFlowネットワークを構築し、徐々に拡大する][width=12cm]

//noindent
この状態から、レガシーネットワーク内のサーバや端末を徐々にOpenFlowネットワークに移動することで移行していきます。

それぞれのネットワーク間ではパケットが行き来できないので、OpenFlowネットワークがレガシーネットワークに悪影響を及ぼす可能性はまずありません。ただし、OpenFlowネットワークに移行する際には関連する機器同士（ファイルサーバとクライアント群など）を一度に移行する必要があります。これはトラブルを起こす可能性が高いため、レガシーネットワークの規模が大きい場合には移行が難しいという問題があります。

=== B：いきなり接続パターン

次のパターンは、私たちがやったようにレガシーネットワークとOpenFlowネットワークをいきなりつなげてしまう方法です（@<img>{pattern2}）。

//image[pattern2][レガシーネットワークとOpenFlowネットワークを直結してしまう][width=12cm]

//noindent
この方法だと、相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできます。このため、独立ネットワークパターンに比べて移行の手間はずっと小さいと言えます。

ただしこの方法は、私たちが失敗したようにとてもリスクの高い方法です。OpenFlowネットワークのコントローラが完璧に作られていれば、このようにいきなりつなげても問題はありませんが、完璧を期するのはなかなかむずかしいものです。というのも、実際のトラフィックをコントローラに流し込んでみて初めて見つかるバグもあるからです。よって、この方法は自宅ネットワークなど他人に迷惑のかからないネットワーク以外では推奨できません。

=== C：フィルタ経由で接続パターン

最後のパターンは、今までに挙げてきた2つのパターンのいいとこどりです。2つのネットワークを接続するのですが、そのときに「逆流防止フィルタ」となるOpenFlowスイッチを間にはさむことでパケットの逆流が起きないようにします（@<img>{pattern3}）。

//image[pattern3][レガシーネットワークとOpenFlowネットワークの間での逆流を防止する][width=12cm]

//noindent
この逆流防止フィルタはたとえば、「レガシーネットワーク→OpenFlow ネットワーク」のような一方向のパケットは通しますが、同じパケットがレガシー側に戻ることを防ぎます。逆方向も同様です。

この方法の利点は、逆流を防ぐだけで今回のケースも含めたかなりの障害を未然に防げることです。また、使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽です。ただし、2つのネットワーク間にもうひとつフィルタ用のOpenFlowスイッチをはさまなければならないという手間はかかります。

== 逆流防止フィルタ

検討の結果、逆流防止フィルタを使ったパターンが一番良さそうでした。フィルタを動かすためのサーバもちょうど余っていましたし、何よりコントローラとして簡単に実装できそうだったからです。前置きが長くなりましたが、さっそくTremaで実装してみましょう。

逆流防止フィルタは1つのPacket Inに対して2つのフローエントリを設定します。1つは順方向のフローエントリで、入ってきたパケットをもう1つのスイッチポートに転送します。もう1つは逆方向のフローエントリで、同じパケットが逆方向に流れてきたときにこのパケットを落とします。

=== ソースコード

逆流防止フィルタ（OneWayBridge コントローラ）のソースコードを@<list>{oneway_bridge}に示します。このコントローラは、Packet InとFlow Removedのハンドラを定義しています。

//list[oneway_bridge][逆流防止フィルタ (OneWayBridge コントローラ)]{
class OneWayBridge < Controller
  # Packet Inで順方向および逆方向のフローエントリを設定する
  def packet_in( datapath_id, message )
    out_port = { 1 => 2, 2 => 1 }[ message.in_port ]
    add_flow datapath_id, message.macsa, message.in_port, out_port
    send_packet datapath_id, message, out_port
    add_drop_flow datapath_id, message.macsa, out_port
  end


  # 順方向と逆方向のフローエントリのいずれかが消えたときに、もう一方も消す
  def flow_removed( datapath_id, message )
    delete_flow datapath_id, message.match.dl_src
  end


  private


  # 順方向のフローエントリの設定:
  # 送信元MACアドレスがmacsaで、スイッチポートin_portからout_portへのフローエントリを追加
  def add_flow( datapath_id, macsa, in_port, out_port )
    send_flow_mod_add(
      datapath_id,
      :idle_timeout => 10 * 60,
      :match => Match.new( :in_port => in_port, :dl_src => macsa ),
      :actions => SendOutPort.new( out_port )
    )
  end


  # 逆方向のフローエントリの設定:
  # 逆流してきたパケット(送信元MACアドレスから判断)を落とす。
  def add_drop_flow( datapath_id, macsa, in_port )
    send_flow_mod_add(
      datapath_id,
      :idle_timeout => 10 * 60,
      :match => Match.new( :in_port => in_port, :dl_src => macsa )
    )
  end


  # パケットをスイッチポートout_portへ転送
  def send_packet( datapath_id, message, out_port )
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => SendOutPort.new( out_port )
    )
  end


  # 順方向と逆方向のフローエントリで残っている方を消す
  def delete_flow( datapath_id, macsa )
    send_flow_mod_delete(
      datapath_id,
      :match => Match.new( :dl_src => macsa )
    )
  end
end
//}

@<tt>{packet_in}ハンドラでは、Packet Inしたスイッチポートとは別のポートへパケットを転送するフローエントリを設定し（@<tt>{add_flow} メソッド）、Packet Inを起こしたパケットを転送します（@<tt>{send_packet}メソッド）。また、同じパケットが逆向きに流れないようにするフローエントリを設定することで逆流を防ぎます（@<tt>{add_drop_flow}メソッド）。同じパケットかどうかは送信元のMACアドレスが同じかどうかで判断します。

@<tt>{flow_removed}ハンドラは、順方向または逆方向のフローエントリが消えたときに呼ばれます。これらのフローエントリはどちらも@<tt>{:dl_src}に同じMACアドレスを指定しているので、@<tt>{delete_flow}メソッドでもう片方の対になるフローエントリを消します。

=== 実行してみよう

逆流防止フィルタを実行するには、レガシーネットワークとOpenFlowネットワークの間にOpenFlowスイッチをはさみ、これをOneWayBridgeコントローラで制御します。でも実機のOpenFlowスイッチを準備するのは大変なので、Tremaの仮想ネットワーク機能でやってしまいましょう。NICが2枚挿さったサーバを用意し、仮想ネットワーク内で起動した仮想スイッチ(vswitch)の各ポートとそれぞれのNICを接続します(@<img>{oneway_bridge}）。

//image[oneway_bridge][逆流防止フィルタ（OneWayBridgeコントローラ）を実行するための物理構成例][width=12cm]

この物理構成をTrema設定ファイルにしたものが@<list>{oneway_bridge_conf}（one-way-bridge.conf）です。仮想リンク（@<tt>{link}で始まる行）の端点にインターフェース名eth0、eth1を指定していることに注目してください。

//list[oneway_bridge_conf][逆流防止フィルタ（OneWayBridgeコントローラ）の設定ファイル]{
vswitch ( "bridge" ) {
  datapath_id 0xabc
}

link "bridge", "eth0"
link "bridge", "eth1"
//}

実行するには、この設定ファイルを@<tt>{trema run}の@<tt>{-c}オプションに渡します。

//cmd{
% trema run ./one-way-bridge.rb -c ./one-way-bridge.conf
//}

=== 職場で使ってみた

さっそくこの逆流防止フィルタを導入したところ、問題は起こらなくなりました。現在、OpenFlowスイッチ5台、ホスト約100台から構成されるOpenFlowネットワークを職場ネットワークと接続して運用しています。このOpenFlowネットワークは現在もどんどん拡大しつつあり、その上でOpenFlowを使ったたくさんのアプリケーションが生まれています。こうした「実践あるのみ」という姿勢から生まれたたくさんのアプリケーション、それを支えるプログラミングフレームワークとして誕生したのがTremaです。

== まとめ

職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。

 * レガシーネットワークをOpenFlowに移行するいくつかのパターンを考察。自宅など自由にできるネットワークでは「いきなり接続パターン」で十分だが、職場ネットワークでは「逆流防止パターン」が最適
 * 逆流防止フィルタを実現するOpenFlowコントローラを実装。2つのフローエントリを設定するだけで、簡単に逆流を防止できる
