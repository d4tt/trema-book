= 生活ネットワークを OpenFlow に移行する

そろそろ独り立ちするときがやってきました。Part 2 では、OpenFlow コント
ローラの書き方や Trema の仮想ネットワークを使った実行方法など、Trema を
使った OpenFlow 開発手法を学んできました。OpenFlow プログラマとしてやっ
ていくための基本的な知識はすべて身につきました。

次は何をすればよいでしょうか？ あとはやってみるだけです。まずは自宅のネッ
トワークを OpenFlow で置き換えましょう。うまくいったら，こんどは職場の
ネットワークを OpenFlow で置き換えましょう。その環境で実際に暮らしてみ
て，初めて見えてくるニーズや改善案があります。これは，とにかくやってみ
なければ絶対にわからないことです。

「怒られるかもしれない」。あなたはそう考えます。家のネットワークはとも
かく，職場のネットワークを止めてしまったらどうしよう……。管理者や上司に
注意されたらどうしよう……。大丈夫です。筆者たちも何度も怒られたことがあ
りますが，その経験からうまくやる方法を学びました。

今回は我々の経験を踏まえ，既存のネットワークを“穏便に”OpenFlow に移行す
るためのテクニックを教えます。ちょっとした OpenFlow プログラムを書くだ
けで，移行の際に起こりがちなネットワーク障害を簡単に防げます。まずは，
筆者たちの失敗談を振り返らせてください。

== 我々の失敗談

話は 2009 年 7 月までさかのぼります。OpenFlow が登場したばかりの当時，
私達たちはさっそく OpenFlow コントローラを書いて小さな OpenFlow ネット
ワークを職場に構築しました。うまく動作して気を良くした我々は，職場のネッ
トワークとこの OpenFlow ネットワークをいきなりつないでみました。まあ大
丈夫だろうと楽観的に考えていたのです。結果的にはすぐにネットワーク障害
が起こり，事態に気づいた管理者からお叱りのメールを受け取ることになりま
した。

当時の状況を単純化すると@<img>{buggy_controller_setup} のようになります。

//image[buggy_controller_setup][障害を起こしたときのネットワーク構成を単純化したもの]

職場ネットワーク（レガシーネットワークとします）のスイッチにはホストが
つながれており，そのうちのスイッチポート 3 番を OpenFlow スイッチのスイッ
チポート 1 番と接続しました。この OpenFlow スイッチは，我々が書いた
BuggyController という OpenFlow コントローラで制御されているとします。

=== 「警告が出てるんですけど」

具体的な障害の症状はこうでした。レガシーネットワークと OpenFlow ネット
ワークを接続してすぐに，レガシースイッチにつながったホストどうしが通信
できなくなりました。そして，ネットワークを監視する watchdog プログラム
が「Host Flapping が起こっている」という警告を出しました。これは，1 つ
のホストがいくつかのポートの間で高速で移動しているように見えるという意
味です。我々はすぐに OpenFlow ネットワークを切断し，原因の分析にとりか
かりました。

=== 障害原因が判明

分析の結果，次のようなシナリオで起こっているのではないかという結論に至りました。

 1. host1 が host2 へパケットを送信する
 2. BuggyController は OpenFlow スイッチポート 1 番からの packet_in を受け取り，OpenFlow スイッチのスイッチポート 1 番に host1 がつながっていると学習する
 3. host2 が host1 へパケットを送信する
 4. BuggyController はスイッチポート 1 番から「宛先＝host1」の packet_in を受け取る。ここで，host1 は OpenFlow スイッチのスイッチポート 1 番にあると学習しているので，スイッチポート 1 番に packet_out する
 5. 結果的に，host1 はポート 2 と 3 の両方から同じパケットを受け取る。watchdog から見ると，host2 がスイッチポート 2 番と 3 番を高速に移動しているように見える

つまり，BuggyController が予期せぬパケットをレガシーネットワークに送っ
たおかげでネットワークが混乱し，通信できない状況が起きたのです。

=== 教訓: これをやってはいけない

振り返ると，失敗した原因は 2 つありました。

1 つは，OpenFlow ネットワークをいきなりレガシーネットワークとつないでし
まったことです。OpenFlow ネットワーク単体では動いていたという言い訳はあ
りますが，いきなりつないでしまったのは若気の至り＆経験不足でした。

もう 1 つは，BuggyController が packet_in してきたスイッチポートに
packet_out していたことです。assert を入れるといった防御的プログラミン
グや、ユニットテストを徹底できていれば防げるバグでしたが，残念ながら当
時の我々では気づくことができませんでした。というわけで、レガシーネット
ワークにつないで始めて気付いた、という最悪のパターンになってしまったわ
けです。

== OpenFlow への移行パターン

大失敗をやらかしてしまった筆者たちは，作戦を練りなおさざるを得なくなり
ました。いろいろな方向から考えなおしたところ，OpenFlow への移行方法には
次の 3 つのパターンがあることがわかりました。もちろん，それぞれでメリッ
ト／デメリットや危険度が異なります。

=== A: 独立ネットワークパターン

最初のパターンは，既存のレガシーネットワークにまったく手を加えずに，独
立した形で OpenFlow ネットワークを構築する方法です (@<img>{pattern1})。
それぞれのネットワーク間でパケットの行き来はなく，お互いに完全に独立し
ています。

//image[pattern1][レガシーネットワークとは独立した OpenFlow ネットワークを構築し，徐々に拡大する]

この状態から，レガシーネットワーク内のサーバや端末を徐々に OpenFlow ネッ
トワークに移動することで移行していきます。

それぞれのネットワーク間ではパケットが行き来できないので，OpenFlow ネッ
トワークがレガシーネットワークに悪影響を及ぼす可能性はまずありません。
ただし，OpenFlow ネットワークに移行する際には関連する機器どうし（ファイ
ルサーバとクライアント群など）を一度に移行する必要があります。これはト
ラブルを起こす可能性が高いため，レガシーネットワークの規模が大き場合に
は移行が難しいという問題があります。

=== B: いきなり接続パターン

次のパターンは，我々がやったようにレガシーネットワークと OpenFlow ネッ
トワークをいきなりつなげてしまう方法です（@<img>{pattern2}）。

//image[pattern2][レガシーネットワークとOpenFlowネットワークを直結してしまう]

相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできま
す。このため，独立ネットワークパターンに比べて移行の手間はずっと小さい
と言えます。

OpenFlow ネットワークのコントローラが完璧に作られていれば，このようにい
きなりつなげても問題はありませんが，完璧なテストというのはあり得ません。
ユニットテストによって細かくテストすることもできますが，それでも不安が
残ります。というのも，我々が失敗したように，生のトラフィックをコントロー
ラに流し込んでみて初めて見つかるバグがあるからです。よって，この方法は
自宅ネットワークなど自由にいじれるネットワーク以外では推奨できません。

#@warn(テスト章への参照)

=== C: フィルタ経由で接続パターン

最後のパターンは，今までに挙げてきた 2 つのパターンのいいとこどりです。
2 つのネットワークを接続するのですが，そのときに「逆流防止フィルタ」を
付けてパケットの逆流が起きないようにします（図4）。

//image[pattern3][レガシーネットワークとOpenFlowネットワークの間での逆流を防止する]

たとえば，「レガシーネットワーク→OpenFlow ネットワーク」のような一方向
のパケットは通しますが，同じパケットがレガシー側に戻ることを防ぎます。
逆方向でも同じです。

この方法の利点は，逆流を防ぐだけでかなりの障害を未然に防げることです。
また，使い勝手はいきなり接続した場合と同じなので OpenFlow への移行も楽
です。

検討の結果，このパターンが一番良さそうでした。この逆流防止フィルタは
OpenFlow コントローラとして実装できそうです。前置きが長くなりましたが，
さっそく Trema を使って実装してみましょう。

== 逆流防止フィルタ

逆流防止フィルタは 1 つの packet_in に対して 2 つのフローを設定します。
1 つは順方向のフローで，入ってきたパケットをもう 1 つのスイッチポートに
転送します。もう 1 つは逆方向のフローで，同じパケットが逆方向に流れてき
たときにこのパケットを落とします。

=== ソースコード

逆流防止フィルタ（OneWayBridge コントローラ）のソースコードを
@<list>{oneway_bridge} に示します。このコントローラは，packet_in と
flow_removed のハンドラを定義しています。

//list[oneway_bridge][逆流防止弁 (OneWayBridge コントローラ)]{
class OneWayBridge < Controller
  # 順方向と逆方向のフローを設定する
  def packet_in datapath_id, message
    out_port = { 1 => 2, 2 => 1 }[ message.in_port ]
    add_flow datapath_id, message.macsa, message.in_port, out_port
    send_packet datapath_id, message, out_port
    add_drop_flow datapath_id, message.macsa, out_port
  end


  # 順方向と逆方向のフローのいずれかが消えたときに，もう一方も消す
  def flow_removed datapath_id, message
    delete_flow datapath_id, message.match.dl_src
  end


  # 以下，プライベートメソッド
  private


  # 送信元 MAC アドレスが macsa で，スイッチポート in_port から out_port へのフローを追加
  def add_flow datapath_id, macsa, in_port, out_port
    send_flow_mod_add(
      datapath_id,
      :idle_timeout => 10 * 60,
      :match => Match.new( :in_port => in_port, :dl_src => macsa ),
      :actions => ActionOutput.new( out_port )
    )
  end


  # パケットをスイッチポート out_port へ転送
  def send_packet datapath_id, message, out_port
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => ActionOutput.new( out_port )
    )
  end


  # 逆流してきたパケットを落とすフローを追加（:actions を指定していないので，マッチしたパケットは破棄）
  def add_drop_flow datapath_id, macsa, in_port
    send_flow_mod_add(
      datapath_id,
      :idle_timeout => 10 * 60,
      :match => Match.new( :in_port => in_port, :dl_src => macsa )
    )
  end


  # 順方向と逆方向のフローを両方とも消す
  def delete_flow datapath_id, macsa
    send_flow_mod_delete(
      datapath_id,
      :match => Match.new( :dl_src => macsa )
    )
  end
end
//}

packet_in ハンドラでは，packet_in したスイッチポートとは別のポートへパ
ケットを転送するフロー（たとえば，スイッチポート 1 番から入ってきたパケッ
トはスイッチポート 2 番に転送するフロー）を設定し（add_flow メソッド），
実際にパケットを転送します（send_packet メソッド）。また，同じパケット
が逆向きに流れないようにするフローを設定することで逆流を防ぎます
（add_drop_flow メソッド）。

flow_removed ハンドラは，順方向または逆方向のフローが消えたときに呼ばれ
ます。これらのフローはどちらも dl_src に同じ MAC アドレスを指定している
ので，delete_flow でもう片方を消します。なおここではやっていませんが，
flow_removed メッセージに乗ってくる統計情報（○章を参照）を使って，逆流
パケットがあった場合には警告メッセージを出すようにするとさらに効果的で
しょう。

#@warn(9 章への参照をここに入れる)

== 実行してみよう

それではさっそく実行してみましょう。実行のためには，レガシーネットワー
クと OpenFlow ネットワークの間に OneWayBridge コントローラで制御する仮
想スイッチ（vswitch）をはさみます（@<img>{oneway_bridge}）。vswitch のポートは，vswitch
を実行するマシンの NIC（eth0，eth1）に結び付けます。

//image[oneway_bridge][逆流防止弁（OneWayBridge コントローラ）を実行するときの物理構成]

@<img>{oneway_bridge} の物理構成を Trema 設定ファイルにしたものがリスト
2（one-way-bridge.conf）です。仮想リンク（link で始まる行）の端点にイン
ターフェース名 eth0，eth1 を指定していることに注目してください。

//list[oneway_bridge_conf][逆流防止弁（OneWayBridgeコントローラ）の設定ファイル]{
vswitch ( "bridge" ) {
  datapath_id 0xabc
}

link "bridge", "eth0"
link "bridge", "eth1"
//}

実行するには，この設定ファイルを trema run の -c オプションに渡します。

//cmd{
% ./trema run ./one-way-bridge.rb -c ./one-way-bridge.conf
//}

=== 使ってみた

さっそくこの逆流防止フィルタを導入したところ，期待していたとおり，問題
は起こらなくなりました。現在，OpenFlow スイッチ 5 台，ホスト約 100 台か
ら構成される OpenFlow ネットワークを職場ネットワークと接続して運用して
います。もちろん，この OpenFlow ネットワークはどんどん拡大しつつあり，
ゆくゆくは職場ネットワークを置き換える予定です。

== まとめ

職場のネットワークを安全に OpenFlow に移行するための Tips を学びました。
今回学んだことは次の2つです。

 * 既存のレガシーネットワークを OpenFlow に移行するいくつかのパターンを
   見ました。自宅ネットワークなど自由にできるネットワークでは「いきなり
   接続パターン」で十分ですが，職場ネットワークでは「逆流防止パターン」
   が最適です
 * 逆流防止フィルタを実現する OpenFlow コントローラを実装しました。基本
   的には 2 つのフローを設定するだけで，簡単に逆流を防止できます

== 参考文献
