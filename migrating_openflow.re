= 生活ネットワークを OpenFlow に移行する

そろそろ独り立ちするときがやってきました。これまで、OpenFlowコントロー
ラの書き方とTremaの仮想ネットワークを使った実行方法を知り，テスト駆動に
よるOpenFlowコントローラの開発手法を学びました。Tremaのソースコードを探
検し，その設計思想にも触れました。OpenFlowプログラマとしてやっていくた
めの基本的な知識はすべて身につきました。

次は何をすればよいでしょうか？ あとはやってみるだけです。まずは自宅のネッ
トワークをOpenFlowで置き換えましょう。うまくいったら，こんどは職場のネッ
トワークをOpenFlowで置き換えましょう。その環境で実際に暮らしてみて，初
めて見えてくるアイデアや改善案があります。これは，とにかくやってみなけ
れば絶対にわからないことです。

「怒られるかもしれない」。あなたはそう考えます。家のネットワークはとも
かく，職場のネットワークを止めてしまったらどうしよう……。管理者や上司に
注意されたらどうしよう……。大丈夫です。筆者たちも何度も怒られたことがあ
りますが，その経験からうまくやる方法を学びました。

今回は我々の経験を踏まえ，既存のネットワークを“穏便に”OpenFlowに移行す
るためのテクニックを教えます。ちょっとしたOpenFlowプログラムを書くだけ
で，移行の際に起こりがちなネットワーク障害を簡単に防げます。まずは，筆
者たちの失敗談を振り返らせてください。

== 我々の失敗談

話は2009年7月までさかのぼります。OpenFlowが登場したばかりの当時，筆者た
ちはさっそくOpenFlowコントローラを書いて小さなOpenFlowネットワークを職
場に構築しました。うまく動作して気を良くした我々は，職場のネットワーク
とこのOpenFlowネットワークをいきなりつないでみました。まあ大丈夫だろう
と楽観的に考えていたのです。結果的にはすぐにネットワーク障害が起こり，
事態に気づいた管理者からお叱りのメールを受け取ることになりました。

当時の状況を単純化すると図○のようになります。

#@warn(図 1 をここに入れる)

職場ネットワーク（レガシーネットワークとします）のスイッチにはホストが
つながれており，そのうちのスイッチポート3番をOpenFlowスイッチのスイッ
チポート1番と接続しました。このOpenFlow スイッチは，我々が書いた
BuggyController というOpenFlowコントローラで制御されています。

=== 「警告が出てるんですけど」

具体的な障害の症状はこうでした。レガシーネットワークとOpenFlowネットワー
クを接続してすぐに，レガシースイッチにつながったホストどうしが通信でき
なくなりました。そして，ネットワークを監視するwatchdogプログラムが
「Host Flappingが起こっている」という警告を出しました。これは，1つのホ
ストがいくつかのポートの間で高速で移動しているように見えるというもので
す。我々はすぐにOpenFlowネットワークを切断し，原因の分析にとりかかりま
した。

=== 障害原因が判明

分析の結果，次のようなシナリオで起こっているのではないかという結論に至りました。

 1. host1がhost2へパケットを送信する
 2. BuggyControllerはOpenFlowスイッチポート1番からのpacket_inを受け取り，OpenFlowスイッチのスイッチポート1番にhost1がつながっていると学習する
 3. host2がhost1へパケットを送信する
 4. BuggyControllerはスイッチポート1番から「宛先＝host1」のpacket_inを受け取る。ここで，host1はOpenFlowスイッチのスイッチポート1番にあると学習しているので，スイッチポート1番にpacket_outする
 5. 結果的に，host1はポート2と3の両方から同じパケットを受け取る。外から見ると，host2がスイッチポート2番と3番を高速に移動しているように見える

つまり，BuggyController が予期せぬパケットをレガシーネットワークに送ったおかげでネットワークが混乱し，通信できない状況が起きたのです。

=== 教訓: これをやってはいけない

振り返ると，失敗した原因は2つありました。

1つは，OpenFlow ネットワークをいきなりレガシーネットワークとつないでし
まったことです。OpenFlow ネットワーク単体では動いていたという言い訳はあ
りますが，いきなりつないでしまったのは若気の至り＆経験不足でした。

もう1つは，BuggyController が packet_in してきたスイッチポートに
packet_out していたことです。assertを入れるなど防御的プログラミングが徹
底できていれば防げるバグでしたが，残念ながら当時の我々では気づくことが
できませんでした。レガシーネットワークにつないで始めて顕在化するバグと
言えます。

== OpenFlow への移行パターン

大失敗をやらかしてしまった筆者たちは，作戦を練りなおさざるを得なくなり
ました。いろいろな方向から考えなおしたところ，OpenFlow への移行方法には
次の3つのパターンがあることがわかりました。もちろん，それぞれでメリット／
デメリットや危険度が異なります。

=== A: 独立ネットワークパターン

最初のパターンは，既存のレガシーネットワークにまったく手を加えずに，独
立した形でOpenFlowネットワークを構築する方法です（図2）。それぞれのネッ
トワーク間でパケットの行き来はなく，お互いに完全に独立しています。

#@warn(図 2 をここに入れる)

この状態から，レガシーネットワーク内のサーバや端末を徐々にOpenFlowネッ
トワークに移動することで移行していきます。

それぞれのネットワーク間ではパケットが行き来できないので，OpenFlowネッ
トワークがレガシーネットワークに悪影響を及ぼす可能性はほとんどありませ
ん。ただし，OpenFlowネットワークに移行する際には関連する機器どうし（ファ
イルサーバとクライアント群など）を一度に移行する必要があります。これは
トラブルを起こす可能性が高いため，移行が難しいという問題があります。

=== B: いきなり接続パターン

次のパターンは，我々がやったようにレガシーネットワークとOpenFlowネット
ワークをいきなりつなげてしまう方法です（図3）。

#@warn(図 3 をここに入れる)

相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできま
す。このため，独立ネットワークパターンに比べて移行の手間はずっと小さい
と言えます。

OpenFlowネットワークのコントローラが完璧に作られていれば，このようにい
きなりつなげても問題はありませんが，完璧なテストというのは難しいです。
ユニットテストによって関数レベルで細かくテストすることもできますが
(Appendix C を参照)，それだけでは不十分です。というのも，我々が失敗した
ように，生のトラフィックをコントローラに流し込んでみて初めて見つかるバ
グがあるからです。よって，この方法は自宅ネットワークなど自由にいじれる
ネットワーク以外では推奨できません。

#@warn(Appendix C への参照)

=== C: フィルタ経由で接続パターン

最後のパターンは，今までに挙げてきた2つのパターンのいいとこどりです。2
つのネットワークを接続するのですが，そのときに「逆流防止フィルタ」を付
けてパケットの逆流が起きないようにします（図4）。

#@warn(図 3 をここに入れる)

たとえば，「レガシーネットワーク→OpenFlowネットワーク」のような一方向の
パケットは通しますが，同じパケットがレガシー側に戻ることを防ぎます。逆
方向でも同じです。

この方法の利点は，逆流を防ぐだけでかなりの障害を未然に防げることです。
また，使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽で
す。

検討の結果，このパターンが一番良さそうでした。この逆流防止フィルタは
OpenFlowコントローラとして実装できそうです。前置きが長くなりましたが，
さっそくTremaを使って実装してみましょう。

== 逆流防止フィルタ

逆流防止フィルタは1つのpacket_inに対して2つのフローを設定します。1つは
順方向のフローで，入ってきたパケットをもう1つのスイッチポートに転送しま
す。もう1つは逆方向のフローで，同じパケットが逆方向に流れてきたときにこ
のパケットを落とします。

=== ソースコード

逆流防止フィルタ（OneWayBridgeコントローラ）のソースコードをリスト1に示
します。このコントローラは，packet_inとflow_removedのハンドラを定義して
います。

#@warn(リスト 1 をここに入れる)

packet_inハンドラでは，packet_inしたスイッチポートとは別のポートへパケッ
トを転送するフロー（たとえば，スイッチポート1番から入ってきたパケットは
スイッチポート2番に転送するフロー）を設定し（add_flowメソッド），実際に
パケットを転送します（send_packetメソッド）。また，同じパケットが逆向き
に流れないようにするフローを設定することで逆流を防ぎます
（add_drop_flowメソッド）。

flow_removedハンドラは，順方向または逆方向のフローが消えたときに呼ばれ
ます。これらのフローはどちらもdl_srcに同じMACアドレスが指定されているの
で，delete_flowでもう片方を消します。なおここではやっていませんが，
flow_removed メッセージに乗ってくる統計情報（9 章を参照）を使って，逆流パケッ
トがあった場合には警告メッセージを出すようにするとさらに効果的でしょう。

#@warn(9 章への参照をここに入れる)

== 実行してみよう

それではさっそく実行してみましょう。実行のためには，レガシーネットワー
クとOpenFlowネットワークの間にOneWayBridgeコントローラで制御する仮想ス
イッチ（vswitch）をはさみます（図5）。vswitchのポートは，vswitchを実行
するマシンのNIC（eth0，eth1）に結び付けます。

#@warn(図 5 をここに入れる)

図5の物理構成をTrema設定ファイルにしたものがリスト
2（one-way-bridge.conf）です。仮想リンク（link で始まる行）の端点にイン
ターフェース名eth0，eth1を指定していることに注目してください。

#@warn(リスト 2 をここに入れる)

実行するには，この設定ファイルをtrema runの-cオプションに渡します。

#@warn(コマンドラインをここに入れる)

=== 使ってみた

さっそくこの逆流防止フィルタを導入したところ，期待していたとおり，問題
は起こらなくなりました。現在，OpenFlowスイッチ5台，ホスト約100台から構
成されるOpenFlowネットワークを職場ネットワークと接続して運用しています。
もちろん，このOpenFlowネットワークはどんどん拡大しつつあり，ゆくゆくは
職場ネットワークを置き換える予定です。

== まとめ/参考文献

職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。今回学んだことは次の2つです。

 * 既存のレガシーネットワークをOpenFlowに移行するいくつかのパターンを見ました。自宅ネットワークなど自由にできるネットワークでは「いきなり接続パターン」で十分ですが，職場ネットワークでは「逆流防止パターン」が最適です
 * 逆流防止フィルタを実現するOpenFlowコントローラを実装しました。基本的には2つのフローを設定するだけで，簡単に逆流を防止できます
