= ネットワークトポロジを検出する
:sourcedir: vendor/topology
:imagesdir: images/topology

大規模なネットワークを構築する前準備として、ネットワークトポロジをOpenFlowで検出してみましょう

== 美しい大規模ネットワーク

筆者はネットワーク研究者という仕事柄、よくさまざまなネットワークを目にします。その中でいつも「すごい!」とうならされるのが、ネットワークエンジニアの憧れ、ShowNet です。ShowNet はネットワーク系最大の展示会 Interop の期間中だけ運用されるネットワークで、最新ネットワーク技術のいわばショーケースと言えます。普段は触れることのできない、ネットワーク界の F1 マシンとも言える最新機器を集めたライブデモンストレーションは圧巻の一言です。

ShowNet の魅力をもっともよく伝えてくれるのが、Interop で毎年公開される ShowNet のトポロジ図です (<<shownet_topology,図 14-1>>)。注目すべきは、ShowNet の複雑な情報をたった一枚の図に収めているところです。「この部分は、いったいどんなプロトコルで動いているんだろう?」「実際の詳しいトポロジはどうなっているのかな?」こうした気になる部分が、すべて一枚の図にきれいに収まっています。ネットワークが好きな人であれば、気がつくと何時間でも眺めてしまうほどの魅力を持つトポロジ図なのです。


[[shownet_topology]]
// TODO 「2015 年 Interop の ShowNet トポロジ図。Copyright (C) 2015 Interop Tokyo ShowNet NOC Team. All Rights Reserved.」

[WARNING]
====
TODO: 2015 年 Interop の ShowNet トポロジ図掲載許可をもらう。
====

ShowNet のようにいくつものスイッチやルータがつながるネットワークの動作では、トポロジ情報の把握が1つの鍵です。パケットが迷子になったりループしたりせずに正しく目的地まで届くためには、スイッチやルータ同士がどのような接続関係にあるかをお互いに把握しなければなりません。

OpenFlow では、コントローラがこのトポロジ情報を管理します。ネットワーク全体を集中管理するコントローラがトポロジを把握することで、パケットを思いのままに転送できます。たとえば、パケットの転送に、最短パスを使うだけではなく、回り道をさせたり、複数のパス (マルチパス) を使うことも自由自在です。

== トポロジ検出の仕組み

コントローラがトポロジ情報を検出するには、スイッチ間のリンクをすべて発見する必要があります。

=== リンクの発見

OpenFlow でリンクを発見する方法として代表的なのは、Link Layer Discovery Protocol (LLDP) パケットを使った方法です (図 x-y)。コントローラはどこにリンクがあるかあたりをつけるために、適当なスイッチ A に LLDP パケットを試しに送ります。もし、スイッチ Aに別のスイッチ B がリンクでつながっていれば、LLDPはそこのリンクを通りスイッチ Bを経由してブーメランのようにコントローラへと戻ってきます。このように LLDP パケットが無事に戻ってくれば、スイッチ A と B はリンクでつながっているとわかります。また、LLDP パケットには通過したリンクの詳しい情報が書き込まれるので、スイッチ A と B がどのポート番号で接続しているかということまでわかります。これを繰り返していけば、最終的にはすべてのリンクを発見できるわけです。

[[lldp_overview]]
image::lldp_overview.png[caption="図14-2",title="LLDP を使ってリンクを発見する"]

「なぜ、LLDP パケットはきちんとリンクを通ってコントローラまで戻ってくるんだろう？スイッチに LLDP 固有のしかけが必要なのかな？」こう思った方もいるかもしれません。実は、LLDPによるリンクは今まで学んできた OpenFlow の仕組みだけを使って実現できます。つまり、OpenFlow に対応したスイッチであれば LLDPでリンクを発見できるのです。

LLDP によるリンク発見を OpenFlow で実現する方法を見ていきましょう。<<lldp_openflow,図 14-3>> のように、スイッチ 0x1 のポート 4 とスイッチ 0x3 のポート 1 が接続されていたとします。このリンクを発見するために、コントローラは次の動作をします。

[[lldp_openflow]]
image::lldp_openflow.png[caption="図14-3",title="LLDP パケットと OpenFlow の仕組みを使ってリンクを発見する"]

1. コントローラは、接続関係を調べたいスイッチの Datapath ID 0x1 とポート番号 4 を埋め込んだ Link Layer Discovery Protocol (LLDP) パケットを作る
2. ポート 4 から出力するというアクションを含む Packet Out メッセージを作り、先ほど作った LLDPパケットをスイッチ 0x1 へと送る
3. Packet Out を受け取ったスイッチはアクションに従い、LLDPパケットを指定されたポート 4 から出力する。その結果、LLDP パケットは、ポート 4 の先につながるスイッチ 0x2 へと到着する
4. LLDP パケットを受け取ったスイッチ 0x2 は、自身のフローテーブルを参照し、パケットの処理方法を調べる。このとき LLDP に対するフローエントリはあえて設定していないため、今回受信した LLDPパケットは、Packet In としてコントローラまで戻される
5. コントローラは、受け取った Packet In メッセージを解析することで、リンクの発見を行う。スイッチ 0x2 からは<<lldp_packet-in,図 14-4>> の Packet In メッセージが送られてくる。この中身を見ることで、スイッチ 0x1 のポート 4 と、スイッチ 0x2 のポート 1 の間にリンクを発見できる

[[lldp_packet-in]]
image::lldp_packet-in.png[caption="図14-4",title="スイッチ 0x2 から送られてくる Packet In メッセージ"]

このように、Packet Out で送られた LLDP パケットは、リンクを通過し、隣のスイッチから Packet In でコントローラへと戻ってきます。この一連の動作によりコントローラはリンクを発見できます。この方法自体は、OpenFlow 仕様でとくに規定されているわけではありません。それぞれのスイッチは OpenFlow 仕様で定められた動作を行っているだけです。つまり、Packet Out と Packet In をうまく使った “OpenFlow ならでは” のリンク発見方法だと言えます。

// TODO 全体にトピックセンテンスがなってない。時間のあるときにちまちまと直そう

=== トポロジの検出

このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロジを知ることができます。たとえば<<topology_before,図 14-5>>のような 3 台の OpenFlow スイッチからなるネットワークにおいて、どのようにトポロジを検出するかを見ていきましょう。各 OpenFlow スイッチがコントローラに接続した直後の状態では、コントローラはスイッチ同士がどのように接続されているかを知りません。

[[topology_before]]
image:topology_before.png[caption="図14-5",title="トポロジ検出前のコントローラ"]

まずスイッチ 0x1 から調べていきます。はじめに Features Request メッセージを送ることで、スイッチ 0x1 が持つポート一覧を取得します。そして、それぞれのポートに対して、前述のリンク発見手順を行います (<<topology_after,図 14-6>>)。その結果、スイッチ 0x1 からスイッチ 0x2 およびスイッチ 0x3 へと至るリンクそれぞれを発見できます。

[[topology_after]]
image:topology_after.png[caption="図14-6",title="スイッチ 0x1 から出るリンクを発見"]

あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていくだけです。スイッチ 0x2, 0x3 に接続するリンクを順に調べていくことで、ネットワークの完全なトポロジ情報を知ることができます。

== 実行してみよう

ソースコードと仮想ネットワークの設定ファイルは GitHub の trema/topology からダウンロードできます。今までと同じく、`git clone` でソースコードを取得し `bundle install` で必要な gem をインストールしてください。

----
$ git clone https://github.com/trema/topology.git
$ cd topology
$ bundle install --binstubs
----

ソースコードに含まれる triangle.conf はスイッチ 3 台を三角形に接続したトアイアングル型のトポロジです。これをトポロジコントローラで検出するには、次のように実行します。

// TODO triangle.confのトポロジ図

----
$ ./bin/trema run ./lib/topology_controller.rb -c triangle.conf
Topology started (text mode).
Port 0x1:1 added: 1
Port 0x1:2 added: 1, 2
Switch 0x1 added: 0x1
Port 0x3:1 added: 1
Port 0x3:2 added: 1, 2
Switch 0x3 added: 0x1, 0x3
Port 0x2:1 added: 1
Port 0x2:2 added: 1, 2
Switch 0x2 added: 0x1, 0x2, 0x3
Link 0x1-0x2 added: 0x1-0x2
Link 0x1-0x3 added: 0x1-0x2, 0x1-0x3
Link 0x2-0x3 added: 0x1-0x2, 0x1-0x3, 0x2-0x3
----

先に説明したように、コントローラはまずFeatures Replyメッセージによってスイッチとポートの一覧を取得します。たとえば、“Port 0x1:1 added” の行はスイッチ0x1のポート1番をコントローラが検出したという意味です。”Switch 0x1 added”のメッセージも同じくFeatures Replyメッセージを返したスイッチのデータパスIDを表示しています。

リンクの検出はLLDPを使って行います。たとえば”Link 0x1-0x2 added”はスイッチ0x1から0x2にLLDPパケットが通ってコントローラにPacketInしたことからリンクを一本発見したという意味です。これを繰り返すことで最終的に三角形のトポロジ(”Link 0x2-0x3 added: 0x1-0x2, 0x1-0x3, 0x2-0x3”のメッセージ)を発見しています。

トポロジコントローラがトポロジの変化を検出する様子を見てみましょう。次のようにスイッチ0x1のポート1番を落とすと、0x1と0x2の間のリンクが消えるはずです。

----
$ ./bin/trema port_down --switch 0x1 --port 1
----

すると、コントローラを実行したターミナルには次の表示が出ます。たしかに、0x1-0x2間のリンクが消滅し残りは0x1-0x3と0x2-0x3の二本になりました。

----
Link 0x1-0x2 deleted: 0x1-0x3, 0x2-0x3
Port 0x1:1 deleted: 2
----

逆にふたたびポートを上げると、三角形トポロジが復活します。

----
$ ./bin/trema port_up --switch 0x1 --port 1
(コントローラを実行したターミナルの出力)
Port 0x2:1 added: 1, 2
Port 0x1:1 deleted: 2
Port 0x1:1 added: 1, 2
Link 0x1-0x2 added: 0x1-0x2, 0x1-0x3, 0x2-0x3
----

// TODO Port 0x1:1 deleted の出力はなぜ出るんだっけ?

以上で見てきたように、トポロジコントローラは定期的に LLDP パケットを投げることでリアルタイムにトポロジの変化を検出できることがわかりました。次章ではこのトポロジコントローラの機能を使って、仮想ネットワーク機能を作ります。

ちなみに、トポロジコントローラはトポロジを画像で表示することもできます。この機能を使うためには、システムに graphviz をあらかじめインストールしておきます。そして、`trema run` の引数に `--` と `graphviz トポロジ画像出力ファイル名` を追加してください。

----
$ ./bin/trema run ./lib/topology_controller.rb -c fullmesh.conf -- graphviz /tmp/topology.png
----

実行すると、このようにトポロジ画像が生成されます。

// TODO 画像出力を貼る

== トポロジコントローラのソースコード

トポロジコントローラは大きく分けて2つの部品からなります。`TopologyController` クラスがコントローラの本体で、LLDPパケットの送信とトポロジに関する OpenFlow メッセージの処理をします。収集したトポロジ情報は `Topology` クラスが管理します。

=== TopologyControllerの実装

TopologyController はトポロジ情報に関する OpenFlow メッセージのためのハンドラを持ちます。

- `switch_ready`: 新しくスイッチが接続してきたら、スイッチのポート情報を知るためにFeatures Requestメッセージをスイッチに投げます。
- `switch_disconnected`: スイッチが切断したら、トポロジ情報 (`@topology`) からスイッチを削除します。
- `features_reply`: スイッチから届いたFeatures Replyに含まれるポート情報のうち、物理ポートでポートが上がっているものを `@topology` に追加します。
- `port_modify`: ポート情報の変更(ポートのUPとDOWN)を識別し、それぞれの変更を `@topology` に反映します。
- `packet_in`: 返ってきたLLDPパケットを元に、`@topology` に新しいリンク情報を登録します。

LLDPパケットの定期送信は、`flood_lldp_frames` メソッドが行います。`@topology` に入っている現在見つかっているポートすべてに対して、LLDPパケットを送信するようにPacket Outを行います。

[source,ruby,subs="verbatim,attributes"]
.lib/topology_controller.rb
----
include::{sourcedir}/lib/topology_controller.rb[]
----

### トポロジ情報

`Topology` クラスはトポロジ情報のデータベースです。`TopologyController` がOpenFlowメッセージから解釈したトポロジの変化を、ポート一覧、スイッチ一覧などのデータ構造に保存します。

- `add_switch`: 新しいスイッチとポート一覧をデータベースに登録します。
- `delete_switch`: スイッチを削除し、スイッチから出ているすべてのリンクも削除します。
- `add_port`: すでに立ち上がっているスイッチに追加されたポートをデータベースに登録します。
- `delete_port`: 無効になったポートを削除し、ポートから出ているリンクも削除します。

`Topology` クラスには、トポロジの変更を他のオブジェクトに通知するという便利な機能があります。たとえば次章で紹介するスライス機能付きスイッチでは、この機能を使ってトポロジの変更を取得し、仮想ネットワークの構成を変更するのに使います。この機能はObserverパターンによって実装しており、トポロジ情報を取得したいオブジェクトは自分を `Topology` のトポロジ変更通知者リストに追加します。追加されたオブジェクトは、トポロジの変更があるたびに変更の種類に対応するハンドラを呼んでもらえます(図○)。この機能について詳しくは次章で解説します。

// TODO: ここの図がほしい。

[source,ruby,subs="verbatim,attributes"]
.lib/topology.rb
----
include::{sourcedir}/lib/topology.rb[]
----

== まとめ

ネットワークトポロジをOpenFlowで検出できる、トポロジコントローラの仕組みを見てきました。この章で学んだことを簡単にまとめておきましょう。

- LLDPでトポロジを検出する仕組み
- トポロジの変化を検出するOpenFlowメッセージとその処理を実装する方法

次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。
