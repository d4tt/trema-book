#+TITLE: 生活ネットワークをOpenFlowに移行する
#+AUTHOR: Yasuhito Takamiya
#+LANGUAGE: ja
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="book.css" />
#+OPTIONS: toc:nil

* 生活ネットワークをOpenFlowに移行する
#+BEGIN_VERSE
あとは実践あるのみ！ 今までの知識を総動員し、自宅や職場のネットワーク
をOpenFlow化していろいろ実験してみましょう。
#+END_VERSE

** どんどん規模を広げていこう
Part1、Part2を通じてOpenFlowのプロトコルや動作モデル、そしてTremaを使っ
たOpenFlowプログラミングを学んできました。一人前のOpenFlowエンジニアと
してやっていくために必要な基礎知識はすでにひととおり身についたと言えま
す。

あとはひたすら実践するだけです。今まで手に入れた知識を実際に道具として
使い、いま生活しているネットワーク上でOpenFlowを実際に動かしてみるのが
一番です。まずは自宅のネットワークをOpenFlowで置き換えましょう。これが
うまくいき物足りなくなったら、こんどは職場で小規模にOpenFlowネットワー
クを作りましょう。このように徐々に規模を広げていくのです。

実際にその環境で暮らしてみて、はじめて見えてくるニーズやアイデア、改善
案があります。初めて自転車に乗ったときのことを思い出してください。補助
輪をはずしただけで最初は派手に転びますが、多少はケガをしつつもあきらめ
ずに練習を繰り返しているうち誰でも乗りこなせるようになります。自転車に
乗れれば、隣りの街やそのまた隣りと行動範囲は一気に広がります。しかし補
助輪をはずさずにただ考えているだけではどこにも行けません。


** 大ケガしないためのヘルメット
「でも、いきなりOpenFlowに移行してもし大失敗したら……」。そう考えるの
が人情です。自宅のネットワークはともかく、もし職場のネットワークを止め
て同僚に迷惑をかけてしまったらどうしよう……。管理者や上司に注意された
らどうしよう……。

本章ではそうした大失敗を防ぐための「ヘルメット」を紹介します。筆者らは、
OpenFlowが登場したころから職場のネットワークで実験を始め、それこそ数え
切れないほどの失敗を繰り返してきました。とにかく何度も怒られましたが、
その経験からうまくやる方法をアドバイスできます。私たちは既存のネットワー
クを穏便にOpenFlowに移行するテクニックを持っています。ちょっとした
OpenFlowコントローラを書くだけで、移行の際に起こりがちなネットワーク障
害を簡単に防げるのです。

まずは、私たちの失敗談を振り返らせてください。

** 私たちの失敗談
話は2009年までさかのぼります。OpenFlowが登場したばかりの当時、私たちは
さっそくスイッチングハブ相当のOpenFlowコントローラを書いて小さな
OpenFlowネットワークを職場に構築してみました。「おお、ちゃんと動くじゃ
ん！」気を良くした私たちは、こともあろうにこのOpenFlowネットワークと職
場ネットワークとをいきなりつないでしまいました。まあ大丈夫だろうと楽観
的に考えていたのです。

しかしすぐにネットワーク障害が起こり、異常に気づいたネットワーク管理者
からお叱りのメールを受け取ることになりました。障害時のセットアップを単
純化すると▼図13-1のようになります。

#+CAPTION: 障害を起こしたときのネットワーク構成を単純化したもの
#+LABEL: fig:buggy_controller_setup
[[./images/migrating_openflow/buggy_controller_setup.png]]

職場ネットワーク（レガシーネットワークとします）のスイッチにはホストを
2台つないでおり、スイッチのポート3番をOpenFlowスイッチのポート1番と接
続しました。このOpenFlowスイッチは、私たちが書いたスイッチングハブ相当
のOpenFlowコントローラ（仮にBuggyControllerとします）で制御していまし
た。

*** 障害報告：Host Flappingが起こっている
ネットワーク管理者から届いた障害報告メールには次のようにありました。
「レガシーネットワークのホストどうしが通信できなくなった。スイッチは
Host Flapping警告を出している」

Host Flappingとは、1つのホストがいくつかのポートの間で高速で移動してい
るように見えるという障害です。「なんでそんなことが起こるんだろう？」わ
れわれはすぐにOpenFlowネットワークを切断し、そしてもちろんネットワーク
管理者にはごめんなさいメールを出してから、原因の分析にとりかかりました。

*** 障害原因が判明
分析の結果、▼図13-2のようなシナリオが起こっているという結論に至りまし
た。なお、次のステップ1.〜5.が発生する前提条件は、レガシーネットワーク
スイッチのエージアウト間隔よりも、OpenFlowスイッチのエージアウト間隔が
長いことです。

#+CAPTION: レガシーネットワークで起こった障害のシナリオ
#+LABEL: fig:failure_analysis
[[./images/migrating_openflow/failure_analysis.png]]

1. host1がhost2へパケットを送信する
2. BuggyControllerはOpenFlowスイッチポート1番からのPacket Inを受け取り、
   OpenFlowスイッチのスイッチポート1番にhost1がつながっていると学習す
   る。また、レガシーネットワークのスイッチが覚えているhost1の情報が、
   一定時間後に消える（いわゆるエージアウト）
3. host2がhost1へパケットを送信する
4. BuggyControllerはスイッチポート1番から「宛先＝host1」のPacket Inを
   受け取る。ここで、host1はOpenFlowスイッチのスイッチポート1番にある
   と学習しているので、スイッチポート1番にPacket Outする
5. 結果的に、host1はポート2と3の両方から同じパケットを受け取る。レガシー
   ネットワークのスイッチから見ると、host2がスイッチポート2番と3番を高
   速に移動しているように見える

つまり、BuggyControllerがレガシーネットワークにパケットを逆流させたお
かげでネットワークが大混乱し、通信できない状況が起きたのです。

*** 教訓: これをやってはいけない
振り返ると、失敗した原因は2つありました。

1つは、OpenFlowネットワークをいきなりレガシーネットワークとつないでし
まったことです。OpenFlowネットワーク単体では動いていたのに、というのは
言い訳にはなりません。若気の至りや経験不足から来る「青い」ミスです。も
う1つは、BuggyControllerがPacket Inと同じポートにPacket Outするという
通常あり得ない動作をしていたことです。要所要所で =assert= を入れるといっ
た防御的プログラミングや、ユニットテストを徹底していれば▼注1防げるバ
グでしたが、当時の私たちは動かすことに精いっぱいでそこまで気が回りませ
んでした。

というわけで、大障害を起こして始めて気づくという最悪のパターンになって
しまったわけです。

○注1：ユニットテストを使ったコントローラの開発手法についてはAppendix Bで解説します。

** OpenFlowへの移行パターン
大失敗をやらかしてしまった筆者たちは、OpenFlow移行のための作戦を練りな
おさざるを得なくなりました。いろいろな方向から考えなおしたところ、
OpenFlowへの移行方法には次の3つのパターンがあることがわかりました。も
ちろん、それぞれでメリット／デメリットや危険度が異なります。

*** A：独立ネットワークパターン
最初のパターンは、既存のレガシーネットワークにまったく手を加えずに、そ
れとは独立したもう1つのOpenFlowネットワークを構築する方法です（▼図
13-3）。それぞれのネットワーク間でパケットの行き来はなく、お互いに完全
に独立しています。

#+CAPTION: レガシーネットワークとは独立したOpenFlowネットワークを構築し、徐々に拡大する
#+LABEL: fig:pattern1
[[./images/migrating_openflow/pattern1.png]]

この状態から、レガシーネットワーク内のサーバや端末を徐々にOpenFlowネッ
トワークに移動することで移行していきます。

それぞれのネットワーク間ではパケットが行き来できないので、OpenFlowネッ
トワークがレガシーネットワークに悪影響を及ぼす可能性はまずありません。
ただし、OpenFlowネットワークに移行する際には関連する機器同士（ファイル
サーバとクライアント群など）を一度に移行する必要があります。これはトラ
ブルを起こす可能性が高いため、レガシーネットワークの規模が大きい場合に
は移行が難しいという問題があります。

*** B：いきなり接続パターン
次のパターンは、私たちがやったようにレガシーネットワークとOpenFlowネッ
トワークをいきなりつなげてしまう方法です（▼図13-4）。

#+CAPTION: レガシーネットワークとOpenFlowネットワークを直結してしまう
#+LABEL: fig:pattern2
[[./images/migrating_openflow/pattern2.png]]

この方法だと、相互に通信できるのでネットワーク間でのサーバや端末の移動
は自由にできます。このため、独立ネットワークパターンに比べて移行の手間
はずっと小さいと言えます。

ただしこの方法は、私たちが失敗したようにとてもリスクの高い方法です。
OpenFlowネットワークのコントローラが完璧に作られていれば、このようにい
きなりつなげても問題はありませんが、完璧を期するのはなかなかむずかしい
ものです。というのも、実際のトラフィックをコントローラに流し込んでみて
初めて見つかるバグもあるからです。よって、この方法は自宅ネットワークな
ど他人に迷惑のかからないネットワーク以外では推奨できません。

*** C：フィルタ経由で接続パターン
最後のパターンは、今までに挙げてきた2つのパターンのいいとこどりです。2
つのネットワークを接続するのですが、そのときに「逆流防止フィルタ」とな
るOpenFlowスイッチを間にはさむことでパケットの逆流が起きないようにしま
す（▼図13-5）。

#+CAPTION: レガシーネットワークとOpenFlowネットワークの間での逆流を防止する
#+LABEL: fig:pattern3
[[./images/migrating_openflow/pattern3.png]]

この逆流防止フィルタはたとえば、「レガシーネットワーク → OpenFlowネッ
トワーク」のような一方向のパケットは通しますが、同じパケットがレガシー
側に戻ることを防ぎます。逆方向も同様です。

この方法の利点は、逆流を防ぐだけで今回のケースも含めたかなりの障害を未
然に防げることです。また、使い勝手はいきなり接続した場合と同じなので
OpenFlowへの移行も楽です。ただし、2つのネットワーク間にもう1つフィルタ
用のOpenFlowスイッチをはさまなければならないという手間はかかります。

** 逆流防止フィルタ
検討の結果、逆流防止フィルタを使ったパターンが一番良さそうでした。フィ
ルタを動かすためのサーバもちょうど余っていましたし、何よりコントローラ
として簡単に実装できそうだったからです。前置きが長くなりましたが、さっ
そくTremaで実装してみましょう。

逆流防止フィルタは1つのPacket Inに対して2つのフローエントリを設定しま
す。1つは順方向のフローエントリで、入ってきたパケットをもう1つのスイッ
チポートに転送します。もう1つは逆方向のフローエントリで、同じパケット
が逆方向に流れてきたときにこのパケットを落とします。

*** ソースコード
逆流防止フィルタ（OneWayBridgeコントローラ）のソースコードを▼リスト
13-1に示します。このコントローラは、Packet InとFlow Removedのハンドラ
を定義しています。

○リスト13-1：逆流防止フィルタ（OneWayBridgeコントローラ）
#+BEGIN_SRC ruby
  class OneWayBridge < Controller
    # Packet Inで順方向および逆方向のフローエントリを設定する
    def packet_in(datapath_id, message)
      out_port = { 1 => 2, 2 => 1 }[message.in_port]
      add_flow datapath_id, message.macsa, message.in_port, out_port
      send_packet datapath_id, message, out_port
      add_drop_flow datapath_id, message.macsa, out_port
    end

    # 順方向と逆方向のフローエントリのいずれかが消えたときに、もう一方も消す
    def flow_removed(datapath_id, message)
      delete_flow datapath_id, message.match.dl_src
    end

    private

    # 順方向のフローエントリの設定:
    # 送信元MACアドレスがmacsaで、スイッチポートin_portから
    # out_portへのフローエントリを追加
    def add_flow(datapath_id, macsa, in_port, out_port)
      send_flow_mod_add(
        datapath_id,
        idle_timeout: 10 * 60,
        match: Match.new(in_port: in_port, dl_src: macsa),
        actions: SendOutPort.new(out_port)
      )
    end

    # 逆方向のフローエントリの設定:
    # 逆流してきたパケット（送信元MACアドレスから判断）を落とす
    def add_drop_flow(datapath_id, macsa, in_port)
      send_flow_mod_add(
        datapath_id,
        idle_timeout: 10 * 60,
        match: Match.new(in_port: in_port, dl_src: macsa)
      )
    end

    # パケットをスイッチポートout_portへ転送
    def send_packet(datapath_id, message, out_port)
      send_packet_out(
        datapath_id,
        packet_in: message,
        actions: SendOutPort.new(out_port)
      )
    end

    # 順方向と逆方向のフローエントリで残っている方を消す
    def delete_flow(datapath_id, macsa)
      send_flow_mod_delete(
        datapath_id,
        match: Match.new(dl_src: macsa)
      )
    end
  end
#+END_SRC

=packet_in= ハンドラでは、Packet Inしたスイッチポートとは別のポートへ
パケットを転送するフローエントリを設定し (=add_flow= メソッド)、Packet
Inを起こしたパケットを転送します (=send_packet= メソッド)。また、同じ
パケットが逆向きに流れないようにするフローエントリを設定することで逆流
を防ぎます (=add_drop_flow= メソッド)。同じパケットかどうかは送信元の
MACアドレスが同じかどうかで判断します。

=flow_removed= ハンドラは、順方向または逆方向のフローエントリが消えた
ときに呼ばれます。これらのフローエントリはどちらも =:dl_src= に同じMAC
アドレスを指定しているので、 =delete_flow= メソッドでもう片方の対にな
るフローエントリを消します。

*** 実行してみよう
逆流防止フィルタを実行するには、レガシーネットワークとOpenFlowネットワー
クの間にOpenFlowスイッチをはさみ、これをOneWayBridgeコントローラで制御
します。でも実機のOpenFlowスイッチを準備するのは大変なので、Tremaの仮
想ネットワーク機能でやってしまいましょう。NICが2枚挿さったサーバを用意
し、仮想ネットワーク内で起動した仮想スイッチ（vswitch）の各ポートとそ
れぞれのNICを接続します（▼図13-6）。

#+CAPTION: 逆流防止フィルタ（OneWayBridgeコントローラ）を実行するための物理構成例
#+LABEL: fig:oneway_bridge
[[./images/migrating_openflow/oneway_bridge.png]]

この物理構成をTrema設定ファイルにしたものが▼リスト13-2
(=one-way-bridge.conf=) です。仮想リンク (=link= で始まる行) の端点に
インターフェース名 =eth0= 、 =eth1= を指定していることに注目してくださ
い。

○リスト13-2：逆流防止フィルタ（OneWayBridgeコントローラ）の設定ファイル
#+BEGIN_SRC ruby
  vswitch('bridge') { datapath_id 0xabc }

  link 'bridge', 'eth0'
  link 'bridge', 'eth1'
#+END_SRC

実行するには、この設定ファイルを =trema run= の =-c= オプションに渡し
ます。

#+BEGIN_SRC bash
% trema run ./one-way-bridge.rb -c ./one-way-bridge.conf ▼<Enter>
#+END_SRC

*** 職場で使ってみた
さっそくこの逆流防止フィルタを導入したところ、問題は起こらなくなりまし
た。現在、OpenFlowスイッチ5台、ホスト約100台から構成されるOpenFlowネッ
トワークを職場ネットワークと接続して運用しています。このOpenFlowネット
ワークは現在もどんどん拡大しつつあり、その上でOpenFlowを使ったたくさん
のアプリケーションが生まれています。

こうした「実践あるのみ」という姿勢を支えるプログラミングフレームワーク
として、Tremaも成長を続けています。

** まとめ
職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。

- レガシーネットワークをOpenFlowに移行するいくつかのパターンを考察。自
  宅など自由にできるネットワークでは「いきなり接続パターン」で十分だが、
  職場ネットワークでは「逆流防止パターン」が最適
- 逆流防止フィルタを実現するOpenFlowコントローラを実装。2つのフローエ
  ントリを設定するだけで、簡単に逆流を防止できる
