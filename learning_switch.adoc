= すべての基本、ラーニングスイッチ
:sourcedir: vendor/learning_switch
:imagesdir: images/learning_switch

データセンターのような複雑に入り組んだネットワークも、もしケーブルを抜いてバラバラにできたなら、スイッチやサーバなどの意外とシンプルな部品に分解できます。

== ラーニングスイッチとは何か?

OpenFlowの世界では、コントローラとしてソフトウェア実装したスイッチをよくラーニングスイッチと呼びます。なぜ、ラーニング（学習）スイッチと呼ぶのでしょうか？それは、スイッチが次のように動くからです。

- 学習：ホストから出たパケットに含まれる、ネットワーク上でのホストの位置情報を学習する
- 転送：今まで学習してきた位置情報を使って、パケットを宛先のホストまで転送する
 
この「学習し、転送する」というラーニングスイッチの仕組みは応用が広く効きます。たとえば第??章で紹介するいくつかのデータセンターネットワークも、基本はラーニングスイッチと同じく「学習し、転送する」という動作をします。このように、自宅ネットワークであろうが最新鋭のデータセンターであろうが、その基本的な考え方は同じなのです。

このおかげで、ラーニングスイッチを作れるようになれば、それを改造することでいろいろなアプリケーションを作れるようになります。

- 複数スイッチ対応ラーニングスイッチ（第?章で紹介）
- トラフィックモニタ（第?章で紹介）
- ルーティングスイッチ（第?章で紹介）
- スライス機能つきルーティングスイッチ（第?章で紹介）

ではさっそく、ネットワークの基本部品であるラーニングスイッチをTremaで実装してみましょう。まずは一般的なハードウェアスイッチの動作原理を理解し、次にOpenFlowでの実現方法を見ていきます。

== スイッチの仕組み

簡単なネットワークを例にしてスイッチの動作を説明します(図○)。スイッチのポート1番と4番に、ホスト1と2をそれぞれ接続しています。また、それぞれのホストのネットワークカードは図に示したMACアドレスを持つとします。

スイッチはホストから届いたパケットを宛先のホストまで転送するために、スイッチにつながる各ホストの位置情報をためておくデータベースを持っています。これをフォワーディングデータベース(FDB)と呼び、FDBは「ホストのMACアドレス」+「ポート番号」の組を保持します。

// TODO 図「スイッチ1台とホスト2台からなるネットワークとFDBの内容」

ここでホスト2がホスト1へパケットを送信すると、スイッチは図○のようにパケットをホスト1まで転送します。

1. 届いたパケットの宛先MACアドレス(00:11:11:11:11:11)を見て、このMACアドレスを持つホストがつながるポート番号をFDBから探す
2. FDBには「MACアドレス00:11:11:11:11:11=ポート1」と学習しているので、ポート1にパケットを出力する

// TODO 図「FDBの情報からパケットをホスト1に届ける」

ここまでの仕組みがわかれば、スイッチの機能を実現するコントローラ (ラーニングスイッチ)をOpenFlowで実現するのは簡単です。

== OpenFlow版スイッチ(ラーニングスイッチ)の仕組み

OpenFlowによるスイッチの構成は図○のようになります。一般的なハードウェアスイッチとの違いは次の2つです。

- FDBをソフトウェアとして実装し、コントローラがこれを管理する
- パケットの転送は、コントローラがフローテーブルにフローエントリを書き込むことで制御する

なお、初期状態でのFDBとフローテーブルの中身はどちらも空です。

=== Packet Inからホストの位置情報を学習

この状態でホスト1がホスト2へパケットを送信すると、コントローラは次のようにホスト1のネットワーク上での位置情報を学習します(図○)。

1. フローテーブルはまだ空なので、パケットはPacket Inとしてコントローラまで上がる
2. コントローラはPacket Inメッセージからパケットの送信元MACアドレスとパケットの入ってきたポートの番号を調べ、「ポート1番にはMACアドレスが00:11:11:11:11:11のホストがつながってい」とFDBに保存する

// TODO 図「OpenFlowによるスイッチ(ラーニングスイッチ)の構成
// TODO 図「Packet Inの送信元MACアドレスとスイッチのポート番号をFDBに学習する」

=== Packet Outでパケットを転送(フラッディング)

学習が終わると次はパケットの転送です。もちろん、パケットの宛先はまだ学習していないので、コントローラは次のようにパケットをばらまくことで宛先まで届けます。このばらまく処理をフラッディングと呼びます(図○)。

1. コントローラはPacket Inメッセージの宛先MACアドレスを調べ、FDBから送出先のポート番号を探す。しかし、ホスト2のMACアドレスとポート番号はまだFDBに入っていないのでわからない
2. コントローラはPacket Outメッセージ(出力ポート=フラッディング)でパケットをばらまくようにスイッチに指示する。その結果、ポート4につながるホスト2にパケットが届く

// TODO 図「パケットの宛先MACアドレスからスイッチのポート番号がFDBに見つからないため、Packet Outメッセージ(出力ポート=フラッディング)でパケットをばらまく

=== ふたたび学習と転送(Flow ModとPacket Out)

この状態でホスト2がホスト1へパケットを送信すると次のようになります(図○)。

1. フローテーブルが空なためコントローラまでふたたびPacket Inメッセージが上がる
2. コントローラはこのPacket Inメッセージら「ポート4番にはMACアドレスが00:22:22:22:22:22のホストがつながっている」とFDBに保存する
3. Packet Inの宛先MACアドレスとFDBを照らし合わせ、出力先のポート番号を探す。ここですでに「ポート1=MACアドレス00:11:11:11:11:11」と学習しているので、出力ポートは1と決定できる
4. 「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエントリをFlow Modメッセージでフローテーブルに書き込む。加えて、Packet Outメッセージ(出力ポート = 1)でPacket Inを起こしたパケットをポート1へ出力する

// TODO 図「同様にホスト2のMACアドレスとポート番号をFDBに学習し、フローエントリを書き込むとともにパケットをホスト1に届ける

さて、ここまでの段階でフローテーブルには「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエントリが入りました。もし、ホスト2がホスト1へふたたびパケットを送信すると、今度はPacket Inがコントローラまで上がることはなく、スイッチ側だけでパケットを転送します。

残りのホスト1からホスト2へのフローエントリはどうでしょう。すでにFDBはすべてのホストのMACアドレスとポート番号を学習してあります。もし、ふたたびホスト1からホスト2へパケットを送信すると、図○と同様にコントローラが「ホスト1からホスト2へのパケットはポート4へ出力せよ」というフローエントリを書き込みます。もちろん、それ以降の通信ではPacket Inはまったく上がらずにすべてスイッチ側だけでパケットを処理します。
