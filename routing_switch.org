#+TITLE: いくつものスイッチをルーティングスイッチで制御する
#+AUTHOR: Yasuhito Takamiya
#+LANGUAGE: ja
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="book.css" />
#+OPTIONS: toc:nil

* いくつものスイッチをルーティングスイッチで制御する
#+BEGIN_VERSE
いよいよOpenFlowで大規模なネットワークを作ります。まずは基礎固めとして、
トポロジ情報の扱いに慣れておきましょう。
#+END_VERSE

** 美しい大規模ネットワーク
筆者はネットワーク研究者という仕事柄、よく大小さまざまなネットワークを
目にします。その中でもいつも「すごい！」とうならされるのが、すべてのネッ
トワークエンジニアの憧れ、ShowNetです。これはネットワーク系最大の展示
会Interopの期間中だけ構築・運用されるネットワークで、最新ネットワーク
技術のいわばショーケースとも言えるものです。普段は絶対に触ることのでき
ない、ネットワーク界のF1マシンとも言える最新機器を集めたライブデモンス
トレーションは圧巻の一言です。

ShowNetの魅力をもっともよく伝えてくれるのが、Interopで毎年公開される
ShowNetのトポロジ図（▼図14-1）です。この図の素晴らしいところは、
ShowNetを構成するネットワーク機器同士の複雑な接続関係をたった1枚に収め
ているところです。「この部分は、いったいどんなプロトコルで動いているん
だろう？」「実際の詳しいトポロジはどうなっているのかな？」ネットワーク
が好きな人であれば、気がつくと何時間でも眺めてしまうほどの魅力を持つト
ポロジ図なのです。

○図14-1：2012年InteropのShowNetトポロジ図

▼編集メモ：枠下に次のテキストを配置してください。▼(C)は丸C
Copyright ▼(C)2012 Interop Tokyo ShowNet NOC Team. All Rights Reserved.

ShowNetのようにいくつものスイッチやルータがつながるネットワークの動作
では、トポロジ情報の把握が1つの鍵です。パケットが迷子になったりループ
したりせずに正しく目的地まで届くためには、スイッチやルータ同士がどのよ
うな接続関係にあるかをお互いに把握しなければなりません。

OpenFlowでは、コントローラがこのトポロジ情報を管理します。ネットワーク
全体を集中管理するコントローラがトポロジを把握することで、パケットを思
いのままに転送できます。たとえば、パケットの転送に最短パスを使うだけで
はなく、回り道をさせたり、複数のパス（マルチパス）を使うことも自由自在
です。

ここではいくつものスイッチを制御するコントローラの一例として、ルーティ
ングスイッチを紹介します。ルーティングスイッチがどのようにしてトポロジ
を把握し、パケットを目的地まで転送するかを見ていきましょう。

** 複数のスイッチを制御する
ルーティングスイッチは、複数台のOpenFlowスイッチを連動させ1つの大きな
スイッチとして動作させるためのコントローラです（▼図14-2）。同じスイッ
チ機能を提供するコントローラとしては第8章で紹介したラーニングスイッチ
がありましたが、これとの大きな違いは制御できるスイッチの台数です。ラー
ニングスイッチは1台のOpenFlowスイッチしか扱えない一方で、ルーティング
スイッチは複数台のOpenFlowスイッチを制御できます。

○図14-2：いくつものOpenFlowスイッチを1つの大きなスイッチとして動作させる

複数台のOpenFlowスイッチを使い、まさにルーティングするようにパケットを
転送することから、ルーティングスイッチと名付けられました。ただし、ルー
ティングスイッチは、ルータではなく、ラーニングスイッチと同じく、スイッ
チ機能を実現するコントローラであることに注意が必要です。

*** ルーティングスイッチの動作
ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転
送が複雑になります。多くの場合、宛先のホストまでいくつものスイッチを経
由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指
示してやる必要があるのです。

たとえば▼図14-3において、ホスト1からホスト4へとパケットを送信する場合
を考えてみます。もしパケットを最短のパスで届けたい場合、スイッチ1 →
スイッチ5 → スイッチ6 → ホスト4の順にパケットを転送します。ルーティ
ングスイッチはこの転送をするフローエントリを最短パス上のスイッチ1、5、
6へ書き込む必要があります。

○図14-3：最短パスでパケットを転送するためにフローエントリを書き込む

ルーティングスイッチの詳しい動作は次のようになります：

1. パケットの道順を指定するため、スイッチ同士の接続情報であるトポロジ
   情報を収集する。トポロジ情報の中身は、スイッチ同士がどのポートでつ
   ながっているかを集めたもの（詳しい収集方法は後述）
2. ホスト1からホスト4宛てのパケットをスイッチ1からPacket Inとして受け
   取る
3. FDBを検索し、宛先のホスト4が接続するスイッチとポート番号を検索する。
   その結果、スイッチ6とホスト4が接続するポート番号を得る
4. Packet Inを出したスイッチ1から出口となるスイッチ6までの最短パスをス
   テップ1で収集したトポロジ情報を使って計算する。その結果、スイッチ1
   → スイッチ5 → スイッチ6というパスを得る
5. この最短パスに沿ってパケットが転送されるようにパス上のスイッチそれ
   ぞれにFlow Modを送りフローエントリを書き込む
6. 最初のPacket Inを起こしたパケットも宛先に送るために、スイッチ6に
   Packet Outを送る

ここでキーとなるのは、ステップ4で使うトポロジ情報の収集方法と最短パス
の計算方法です。まずは最短パスを説明します。

*** 最短パスを計算する
最短パスの計算でよく使われるのがダイクストラ法というアルゴリズムです。
これは、出発点から目的地までの最短路を求めるための汎用アルゴリズムの1
つで、カーナビの経路探索や鉄道の乗換案内などにも使われています。

ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のよう
になります。まず、出発点から1ホップで到達できるスイッチをすべて探しま
す。次に、見つかったスイッチから出発して1ホップで行けるスイッチ、つま
り最初の出発点から2ホップで到達できるスイッチをすべて探します。これを
繰り返して、出発点から3ホップ、4ホップ……というように距離を広げながら
次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索
完了で、そこまでのパスを最短パスとして返します▼注1。

○注1：ダイクストラ法はリンクに重み（距離）がある場合の最短路を求める
ことができるので、実際にはもう少し複雑な手順になります。ネットワーク上
の最短パスではそれぞれのリンクは“重み1”として考えるので、このように
単純化できます。

実際に図14-2のネットワークでスイッチ1からスイッチ6までの最短パスをダイ
クストラ法で探索する手順は次のようになります（▼図14-4）。

1. 始点となるスイッチ1に着目し、ここを0ホップとする
2. 始点のスイッチ1から1ホップで行けるすべてのスイッチを見つける。これ
   はスイッチ1から出るリンクの先に繋がっているスイッチで、スイッチ2と
   スイッチ5が見つかる
3. ステップ2で見つかったスイッチから1ホップで行けるすべてのスイッチを
   見つける。これはつまり、始点からのホップ数が2のすべてのスイッチとい
   うことになる。今度はスイッチ3、4、6が見つかる
4. ゴールであるスイッチ6が見つかったので探索を終わる。最短パスは最終的
   にスイッチ1 → スイッチ5 → スイッチ6であることがわかる

○図14-4：最短パスをダイクストラ法で計算する

*** トポロジを検出する
ダイクストラ法には、“リンクの先に繋がっているスイッチを調べる”という
ステップがありました。これを実行するためには、コントローラはトポロジ情
報を知っている必要があります。トポロジを検出するには、スイッチ間のリン
クをすべて発見する必要があります。

**** リンクの発見
OpenFlowでリンクを発見する方法として代表的なのは、次のLink Layer
Discovery Protocol（LLDP）パケットを使った方法です（▼図14-5）。コント
ローラはどこにリンクがあるかあたりをつけるために、適当なスイッチAに
LLDPパケットを試しに送ります。もし、スイッチAに別のスイッチBがリンクで
つながっていれば、LLDPパケットはそこのリンクを通りスイッチBを経由して
ブーメランのようにコントローラへと戻ってきます。このようにLLDPパケット
が無事に戻ってくれば、スイッチAとBはリンクでつながっているとわかります。
また、LLDPパケットには通過したリンクの詳しい情報が書き込まれるので、ス
イッチAとBがどのポート番号で接続しているかということまでわかります。こ
れを繰り返していけば、最終的にはすべてのリンクを発見できるわけです。

○図14-5：LLDPを使ってリンクを発見する

「なぜ、LLDPパケットはきちんとリンクを通ってコントローラまで戻ってくる
んだろう？ スイッチにLLDP固有のしかけが必要なのかな？」こう思った方も
いるかもしれません。実は、LLDPによるリンク発見は今まで学んできた
OpenFlowの仕組みだけを使って実現できます。つまり、OpenFlowに対応したス
イッチであればLLDPでリンクを発見できるのです。

LLDPによるリンク発見をOpenFlowで実現する方法を見ていきましょう。▼図
14-6のように、スイッチ0x1のポート4とスイッチ0x2のポート1が接続されてい
たとします。このリンクを発見するために、コントローラは次の動作をします。

1. コントローラは、接続関係を調べたいスイッチのDatapath ID 0x1とポート
   番号4を埋め込んだLink Layer Discovery Protocol（LLDP）パケットを作る
2. ポート4から出力するというアクションを含むPacket Outメッセージを作り、
   先ほど作ったLLDPパケットをスイッチ0x1へと送る
3. Packet Outを受け取ったスイッチはアクションに従い、LLDPパケットを指
   定されたポート4から出力する。その結果、LLDPパケットは、ポート4の先
   につながるスイッチ0x2へと到着する
4. LLDPパケットを受け取ったスイッチ0x2は、自身のフローテーブルを参照し、
   パケットの処理方法を調べる。このときLLDPに対するフローエントリはあ
   えて設定していないため、今回受信したLLDPパケットは、Packet Inとして
   コントローラまで戻される
5. コントローラは、受け取ったPacket Inメッセージを解析することで、リン
   クの発見を行う。スイッチ0x2からは▼図14-7のPacket Inメッセージが送
   られてくる。この中身を見ることで、スイッチ0x1のポート4と、スイッチ
   0x2のポート1の間にリンクを発見できる

○図14-6：LLDPパケットとOpenFlowの仕組みを使ってリンクを発見する

○図14-7：スイッチ0x2から送られてくるPacket Inメッセージ

このように、Packet Outで送られたLLDPパケットは、リンクを通過し、隣のス
イッチからPacket Inでコントローラへと戻ってきます。この一連の動作によ
りコントローラはリンクを発見できます。この方法自体は、OpenFlow仕様でと
くに規定されているわけではありません。それぞれのスイッチはOpenFlow仕様
で定められた動作を行なっているだけです。つまり、Packet OutとPacket In
をうまく使った“OpenFlowならでは”のリンク発見方法だと言えます。

**** トポロジの検出
このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに
順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロ
ジを知ることができます。たとえば▼図14-8のような3台のOpenFlowスイッチ
からなるネットワークにおいて、どのようにトポロジを検出するかを見ていき
ましょう。各OpenFlowスイッチがコントローラに接続した直後の状態では、コ
ントローラはスイッチ同士がどのように接続されているかを知りません。

○図14-8：トポロジ検出前のコントローラ

まずスイッチ0x1から調べていきます。はじめにFeatures Requestメッセージ
を送ることで、スイッチ0x1が持つポート一覧を取得します。そして、それぞ
れのポートに対して、前述のリンク発見手順を行います（▼図14-9）。その結
果、スイッチ0x1からスイッチ0x2およびスイッチ0x3へと至るリンクがそれぞ
れ発見できます。

○図14-9：スイッチ0x1から出るリンクを発見

あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていく
だけです。スイッチ0x2、0x3に接続するリンクを順に調べていくことで、ネッ
トワークの完全なトポロジ情報を知ることができます。

** 実行してみよう
ではルーティングスイッチを使って実際のトポロジ検出や最短路計算の動作を
見ていきましょう。ルーティングスイッチはTrema Appsの一部としてGitHubで
公開されています。次のようにソースコードを取得してください。

#+BEGIN_SRC
% git clone https://github.com/trema/apps.git ▼<Enter>
#+END_SRC

ルーティングスイッチは次の3つのアプリケーションが連携して動作します。

- topology：検出したトポロジ情報を管理する
- topology_discovery：トポロジ情報を検出する
- routing_switch：ルーティングスイッチ本体

この3つをセットアップするには、ダウンロードしたTrema Appsの
★topology★と★routing_switch★を次のようにコンパイルしてください。

#+BEGIN_SRC
% (cd apps/topology; make) ▼<Enter>
% (cd apps/routing_switch; make) ▼<Enter>
#+END_SRC

これで準備は完了です。

*** ルーティングスイッチを動かす
それでは、ルーティングスイッチを動かしてみましょう。Tremaのネットワー
クエミュレータ機能を用いて、▼図14-10のネットワークを作ります。

○図14-10：スイッチ4台からなるネットワーク

図14-10の構成を実現する設定ファイル（★routing_switch_fullmesh.conf★）
は、先ほどGitHubから取得したソースコードの中に含まれています。この設定
ファイルを用いて、次のようにルーティングスイッチを起動します。

#+BEGIN_SRC
% trema run -c ./apps/routing_switch/routing_switch_fullmesh.conf -d ▼<Enter>
#+END_SRC

それでは起動したルーティングスイッチがどのようにトポロジを検出するかを
見てみましょう。

*** トポロジを表示する
Trema Appsの★topology★ディレクトリには、検出したトポロジを表示するコ
マンド★show_topology★が用意されています。次のように実行すると、検出
したトポロジを仮想ネットワーク設定ファイルと同じフォーマットで出力しま
す。

#+BEGIN_SRC
% trema run ./apps/topology/show_topology ▼<Enter>
vswitch {
  datapath_id "0x1"
}

vswitch {
  datapath_id "0x3"
}

vswitch {
  datapath_id "0x4"
}

vswitch {
  datapath_id "0x2"
}

link "0x4", "0x3"
link "0x2", "0x1"
link "0x4", "0x1"
link "0x3", "0x2"
link "0x3", "0x1"
link "0x4", "0x2"
#+END_SRC

図14-10と比較すると、スイッチ間のリンクがうまく検出できていることがわ
かります。しかし、仮想ホストとスイッチ間のリンクは検出できていません。
LLDPとOpenFlowによるトポロジ検出は、あくまでスイッチ間のリンクを検出す
る仕組みだからです。

*** 最短パスを通すフローエントリを確認する
次にhost1とhost2の間でパケットを送受信し、最短パスを通すフローエントリ
がうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、
まだMACアドレスの学習を行なっていないので、host1からhost2へとパケット
を送っただけではフローエントリは設定されません。次のように両方向でパケッ
トを送った段階でフローエントリが設定されます。

#+BEGIN_SRC
% trema send_packets --source host1 --dest host2 ▼<Enter>
% trema send_packets --source host2 --dest host1 ▼<Enter>
#+END_SRC

それでは、どのようなフローエントリが設定されたかを見てみます。設定され
ているフローエントリの確認は、★trema dump_flows ［表示したいスイッチ
のDatapath ID］★でできます。まずはhost1からhost2への最短パスであるス
イッチ★0x1, 0x2★のフローテーブルを見てみましょう。

#+BEGIN_SRC
% trema dump_flows 0x1 ▼<Enter>
NXST_FLOW reply (xid=0x4):
  cookie=0x3, duration=41s, table=0, n_packets=0, n_bytes=0, \
  ...                                                        \
  dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,         \
  nw_src=192.168.0.2,nw_dst=192.168.0.1,nw_tos=0,tp_src=1,   \
  tp_dst=1 actions=output:3

% ./trema dump_flows 0x2 ▼<Enter>
NXST_FLOW reply (xid=0x4):
  cookie=0x3, duration=42s, table=0, n_packets=0, n_bytes=0, \
  ...                                                        \
  dl_src=00:00:00:01:00:02,dl_dst=00:00:00:01:00:01,         \
  nw_src=192.168.0.2,nw_dst=192.168.0.1,nw_tos=0,tp_src=1,   \
  tp_dst=1 actions=output:3
#+END_SRC

出力より、★0x1★と★0x2★のスイッチそれぞれにhost2 → host1のフローエ
ントリが設定されていることがわかります。

一方で、最短パス上にないスイッチ★0x3★、★0x4★はパケットが通らないた
め、次のようにフローエントリがありません。

#+BEGIN_SRC
% ./trema dump_flows 0x3 ▼<Enter>
NXST_FLOW reply (xid=0x4):
% ./trema dump_flows 0x4 ▼<Enter>
NXST_FLOW reply (xid=0x4):
#+END_SRC

以上でルーティングスイッチにおけるトポロジ検出と最短パス計算の動作を見
てきました。これらはOpenFlowで大規模なネットワークを扱う際の基本的なテ
クニックですので、ぜひ習得してください。

** OpenFlowを使う利点
本章のはじめで説明したように、ルーティングスイッチはOpenFlowネットワー
クを1台の仮想的なスイッチとして動作させるコントローラアプリケーション
です。普通のスイッチを真似るだけならば、わざわざOpenFlowを使わなくても
よいのでは？ と思うかもしれません。ここでは、OpenFlowを使った場合の利
点について考えてみたいと思います。

*** リンク帯域を有効活用できる
通常のスイッチで構成されたネットワークでは、パケットのループを防ぐため
にスパニングツリープロトコルでリンクの一部を遮断します。たとえば、▼図
14-11のようなループを含むネットワークでスパニングツリープロトコルを使
うと、スイッチ2とスイッチ3間のリンクが遮断されループが解消します。この
とき、たとえばホスト2からホスト3へのパケットは、この遮断されたリンクを
通過できないため、スイッチ1を経由して転送します。これは明かに無駄な回
り道で、せっかくのリンク帯域が無駄になっています。

○図14-11：スパニングツリーではループを避けるために一部のリンクを遮断する

一方、ルーティングスイッチではコントローラがトポロジ全体を把握している
ため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路
を各スイッチにフローエントリとして明示的に指示するため、ループを含むト
ポロジであっても問題なく動作します。このためスパニングツリーを使う場合
と比べて、ネットワーク中のリンクを有効に使えます（▼図14-12）。

○図14-12：ルーティングスイッチではネットワーク中のリンクを有効に使える

*** いろいろなパス選択アルゴリズムを使える
パスの決定はコントローラで一括して行なうため、パス決定アルゴリズムを入
れ替えるだけで、さまざまなパス選択を実現できます。今回、ルーティングス
イッチではダイクストラ法による最短パスを使いましたが、たとえば▼図
14-13のようにフロー毎に異なるパスを設定することで、帯域確保のためのマ
ルチパスを作ることも簡単にできます。

○図14-13：OpenFlowでは最短でないパスを含んだマルチパスを自由に作れる

このようなマルチパスは従来の自律分散型でも実現できますが、厳しい制限が
あります。IETFが標準化を行うTRILL（Transparent Interconnect of Lots of
Links）やIEEEが標準化を行うSPB（Shortest Path Bridges）は、マルチパス
転送に対応しています。しかし、マルチパス転送を使えるのは、最短パスが複
数ある場合▼注2だけです。最短ではないパスは、ループを起こす可能性があ
るため、使用することができません。また最短パスが1本だけの場合にもマル
チパスにできません。

○注2：このようなパスを、イコールコストマルチパス（Equal Cost Multipath）と呼びます。

** まとめ
いくつものスイッチからなるネットワークを扱うことができる、ルーティング
スイッチの動作を見てきました。この章で学んだことを簡単にまとめておきま
しょう。

- ネットワーク上の最短パスを計算する方法
- LLDPでトポロジを検出する仕組みと、ルーティングスイッチのtopologyモジュールの動作
- OpenFlowを使う場合の利点

次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例とし
て、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていき
ます。

*** 参考文献
- 『最短経路の本——レナのふしぎな数学の旅』（Peter Gritzmann、Rene Brandenberg 著／シュプリンガー・ジャパン） ::
     最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章で
     はネットワーク上での最短パスを求める場合のダイクストラ法を紹介し
     ましたが、リンクに重みがある場合の一般的なダイクストラ法について
     はこの本がおすすめです。
- 『マスタリングTCP/IP 応用編』（Philip Miller 著／オーム社） ::
     とくにレイヤ3の経路制御プロトコルについて詳しく説明した本です。ダ
     イクストラ法を用いた経路制御プロトコルの1つであるOSPFについても説
     明しているので、ルーティングスイッチとの違いを比べてみるのもおも
     しろいでしょう。
