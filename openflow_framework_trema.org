* OpenFlowフレームワークTrema

#+BEGIN_QUOTE
Tremaを使うと楽しくOpenFlowプログラミングの世界が味わえます。これでいよいよあなたもSDNプログラマの仲間入りです!
#+END_QUOTE

# //indepimage[izakaya][][width=10cm]

** 作って分かるOpenFlow

第II部では、いよいよ実際にOpenFlowでネットワークをプログラムする方法を
紹介します。職場や自宅のような中小規模ネットワークでもすぐに試せる実用
的なコードを通じて、「OpenFlowって具体的に何に使えるの？」「OpenFlowコ
ントローラってどう作るの？」というよくある疑問に答えていきます。題材は
なるべく実用例を取り上げるようにし、またOpenFlowやネットワークの基礎か
ら説明していくようにしました。このためネットワークの専門家はもちろん、
普通のプログラマにもすんなり理解できる内容となっているはずです。

まずは、この第II部で使うOpenFlowプログラミングのためのフレームワーク、

@<ruby>{Trema,トレマ}をあらためて紹介します。

** Tremaとは

TremaはOpenFlowコントローラを開発するためのRuby向けプログラミングフレー
ムワークです。GitHub上でオープンに開発しており、GPL2ライセンスのフリー
ソフトウェアです。公開は2011年の4月と比較的新しいソフトウェアですが、そ
の使いやすさから国内外の企業や大学、および研究機関などですでに数多く採
用されています。

Tremaの情報は主に次の URL から入手できます。

- Tremaホームページ： http://trema.github.com/trema/
- GitHubのプロジェクトページ：http://github.com/trema/
- メーリングリスト： http://groups.google.com/group/trema-dev
- Twitterアカウント：http://twitter.com/trema_news

Tremaの特長をひとことで言うと、「Ruby on RailsやSinatraなどのWebフレー
ムワークに影響を受けた、アジャイルなOpenFlowプログラミングフレームワー
クである」ということです。たとえば最近のアジャイル開発環境ではもはや当
たり前ですが、Tremaは開発を効率化する便利なツールを数多く提供しています。
このように開発サイクル全体の面倒を見てくれるところが Tremaの「フレーム
ワーク」たるゆえんで、他のOpenFlow開発ツールとはまったく違うところです。

ここからは実際にこのTremaを使ってOpenFlowコントローラを作っていきます。
まずはTremaをセットアップしましょう。

*** コラム @<ruby>{友太郎,ゆうたろう}の質問: Tremaの由来ってなに？

よく「Tremaの由来って何ですか？」と聞かれるのですが、これは筆者の1人が
大好きな大阪の「とれまレコード(http://www.fumiyatanaka.com/)」というレ
コードレーベルの名前から取りました。テクノミュージックを中心にリリース
する小さなレーベルですが、DJの間では世界的に知られています。

さてそもそもこの"とれま"とはいったい何でしょう。これは日本がバブルの頃、
道路の「とまれ」という標示がよく「とれま」と間違えて描かれていたという
事実が元になっています。このありえない誤植の原因は、バブル景気時代に急
増した外国人労働者が日本語もままならないまま道路工事現場で働いていたと
いうことにあるそうです。由来を探ってみると意外と面白い事実に行き着くこ
とってありますね。

ちなみに、Tremaの公式ロゴマークは@<img>{trema_logo}です。これはTwitter
のTrema公式アカウント(=@trema_news=)のアイコンとしても使われています。

//image[trema_logo][Trema の公式ロゴマーク][width=5cm]

もちろん、こんなに大胆な道路標識は日本中どこを探してもありません。この
本の編集者が画像編集ソフトで試しに作ったところ評判が良かったので、その
まま公式ロゴになりました。

** Tremaのセットアップ

TremaはLinux上で動作します。次のディストリビューションとバージョンでの
動作を保証しています。

- Ubuntu 10.04 以降 (i386/amd64, デスクトップ版)
- Debian GNU/Linux 6.0 (i386/amd64)

なお保証はしていませんが、RedHatなどその他のLinuxディストリビューション
でも動作するはずです。

Tremaの提供するtremaコマンドの実行にはroot権限が必要です。まずは、
=sudo= を使ってroot権限でコマンドを実行できるかどうか、 =sudo= の設定ファ
イルを確認してください。

=sudo= が正しく設定できていることを確認したら、Tremaのインストールや実
行に必要ないくつかのソフトウェアをインストールしましょう。

- Rubyインタプリタ: Trema は RubyとCで作成されていて、アプリケーション
  の記述にもRubyを使います。TremaではRuby のバージョン 1.8.7 が必要です。
  1.8.6 以前のバージョンやバージョン 1.9 以降では今のところ動作しません。
- Rubyのパッケージ管理システムRubyGems(https://rubygems.org/)
- Trema本体。本書は、Tremaバージョン0.3.0を使用して執筆しています。
- Tremaのコンパイルに必要な =gcc= や@ =make= およびいくつかのライブラリ。

開発に必要なのはこれだけです。それでは、Ubuntuのパッケージ管理システム
=apt-get= を使って必要なパッケージを次のようにインストールしてください。
もし他のディストリビューションを使いたい場合は、コマンド名とパッケージ
名を適宜読み替えください@<fn>{ubuntu12.10}。

//footnote[ubuntu12.10][Ubuntu 12.10以降ではRubyのデフォルトバージョン
がRuby1.9になっているので、@<tt>{ruby}, @<tt>{rubygems},
@<tt>{ruby-dev}をそれぞれTremaがサポートする@<tt>{ruby1.8},
@<tt>{rubygems1.8}, @<tt>{ruby-dev1.8}と読み替えてください。]

#+BEGIN_SRC shell
% sudo apt-get install gcc make ruby rubygems ruby-dev irb libpcap-dev libsqlite3-dev
#+END_SRC

以上でTremaをインストールするための準備が整いました。続いてTremaをイン
ストールするには、RubyGemsのパッケージで手軽にインストールする方法と、
最新のソースコードを取得して自分でビルドする方法があります。それぞれ説
明していきましょう。

*** パッケージで手軽にインストールする場合

TremaはRubyGemsを使って次のようにコマンド一発で簡単にインストールできま
す。

#+BEGIN_SRC shell
% gem install trema
#+END_SRC

RubyGemsでインストールした場合、自動的にTremaのコマンド =trema= にパス
が通っているはずです。次のコマンドでバージョンが表示されればインストー
ルは成功です。

#+BEGIN_SRC shell
% trema --version
trema version 0.3.0
#+END_SRC

*** ソースコードから最新版をインストールする場合

最新版をインストールしたい人は、GitHubから自分でソースコードをダウンロー
ドしてビルドすることもできます。まず、次のように =git= を使って最新のソー
スコードを取得してください。

#+BEGIN_SRC shell
% git clone git://github.com/trema/trema.git
#+END_SRC

次のコマンドを実行すると、Tremaが依存するRubyGemsのパッケージが自動的に
インストールされます。

#+BEGIN_SRC shell
% cd trema
% gem install bundler
% bundle install
#+END_SRC

次のコマンドでTremaをダウンロードしたディレクトリ以下にTremaがインストー
ルされます。 =make install= のようなシステム全体へのインストール手順は
不要ですので注意してください。

#+BEGIN_SRC shell
% ./build.rb
#+END_SRC

次のコマンドで =trema= コマンドが正しくインストールされたか確認してくだ
さい。

#+BEGIN_SRC shell
% ./trema --version
trema version 0.3.0
#+END_SRC

もし必要あればこのディレクトリにパスを通し、 =trema= コマンドが簡単に起
動できるようにしておいてください。

さあ、これでTremaによるOpenFlow開発環境が整いました。それでは早速、入門
の定番Hello, WorldをTremaで書いてみましょう。

** Hello, Trema!

今から書くアプリケーションは最も簡単なOpenFlowコントローラの一種で、画
面に"Hello, Trema!"と表示するだけのものです。スイッチとはまったくやりと
りしないスタンドアロンのアプリケーションですが、Tremaで作れるすべてのコ
ントローラのテンプレートとなっています。

では、適当なディレクトリにエディタで =hello-trema.rb= というファイルを
開き、次のコードを入力してください。"=.rb=" はRubyプログラムの標準的な
拡張子です。なおRubyの文法は必要に応じておいおい説明しますので、もし分
からなくても今のところは気にせずそのまま入力してください。

#+BEGIN_SRC ruby
  class HelloTrema < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

意味はまだわからないかもしれませんが、とてもシンプルに書けることはわか
ると思います。それでは細かい文法は後で見るとして「習うより慣れろ」でさっ
そく実行してみましょう。

*** 実行してみよう(=trema run=)

作成したコントローラは =trema run= コマンドですぐに実行できます。Rubyは
インタプリタ言語なので、コンパイルの必要はありません。ターミナルで次の
ように入力すると、この世界一短いOpenFlowコントローラはフォアグラウンド
プロセスとして起動し、画面に "=Hello, Trema!=" と出力します。起動したコ
ントローラは Ctrl + C で停止できます。

#+BEGIN_SRC shell
% trema run ./hello-trema.rb
Hello, Trema!  # Ctrl+c で終了
%
#+END_SRC

いかがでしょうか？ =trema= コマンドを使うと、とても簡単にコントロー
ラを実行できることがわかると思います。 =trema= コマンドには他にもい
くつかの機能がありますのでここで簡単に紹介しておきましょう。

** =trema= コマンド

=trema= コマンドはTrema唯一のコマンドラインツールであり、コントローラの
起動やテストなど様々な用途に使います。たとえば先ほどの"Hello Trema!"で
見たように、 =trema run= はコントローラを起動するためのコマンドです。起
動したコントローラはOpenFlowスイッチと接続しメッセージをやりとりします。
また、次の章以降で触れますが =trema run= コマンドはオプションで仮想ネッ
トワークを作ることもでき、作ったコントローラをこの仮想ネットワークの中
でテストできます。このように、 =trema= コマンドはTremaフレームワークに
おける中心的なツールで、あらゆるコントローラ開発の出発点と言えます
(@<img>{trema_overview})。

//image[trema_overview][@<tt>{trema}コマンドでコントローラを実ネットワークや仮想ネットワークで実行][width=12cm]

=trema= コマンドは =git= や =svn= コマンドと似たコマンド体系を持ってお
り、 =trema= に続けて =run= などのサブコマンドを指定することで様々な機
能を呼び出します。こうしたコマンド体系を一般に「コマンドスイート」と呼
びます。

一般的なコマンドスイートと同じく、サブコマンドの一覧は =trema help= で
表示できます。また、サブコマンド自体のヘルプは =trema help [サブコマン
ド]= で表示できます。以下に =trema help= で表示されるサブコマンド一覧を
ざっと紹介しておきましょう。いくつかのサブコマンドはまだ使い方を紹介し
ていませんが、続く章で説明しますので今は目を通すだけでかまいません。

- =trema run=
  コントローラをフォアグラウンドで実行する。 =--daemonize (-d)= オプショ
  ンを付けるとコントローラをバックグラウンド(デーモンモード)として実行
  できる
- =trema killall=
  バックグラウンドで起動しているTremaプロセス全体を停止する
- =trema version=
  Tremaのバージョンを表示する。 =trema --version= と同じ
- =trema ruby=
  TremaのRuby APIをブラウザで表示する
- =trema kill [仮想スイッチ]=
  仮想ネットワーク内の指定したスイッチを停止する
  (@<chap>{switch_monitoring_tool}を参照)
- =trema up [仮想スイッチ]=
  仮想ネットワークの指定したスイッチを再起動する
  (@<chap>{switch_monitoring_tool}を参照)
- =trema send_packets [送信オプション]=
  仮想ネットワーク内でテストパケットを送信する
  (@<chap>{learning_switch}を参照)
- =trema show_stats [仮想ホスト名]=
  仮想ネットワーク内の仮想ホストで送受信したパケットの統計情報を表示す
  る(@<chap>{learning_switch}を参照)
- =trema reset_stats=
  仮想ネットワーク内の仮想ホストで送受信したパケットの統計情報をリセッ
  トする(@<chap>{learning_switch}を参照)
- =trema dump_flows [仮想スイッチ名]=
  仮想ネットワーク内の仮想スイッチのフローテーブルを表示する
  (@<chap>{learning_switch}を参照)

この章ではさきほど使った =trema run= に加えて、Ruby APIを表示する
=trema ruby= コマンドを覚えておいてください。 =trema ruby= を実行すると
デフォルトブラウザでTrema Ruby APIリファレンスのページが開きます
(@<img>{trema_ruby})。プログラミング中いつでもコマンド一発でリファレン
スを開けるので大変便利です。

#@warn(API のページが YARD のせいで壊れているので、直してからスクリーンショット撮り直し)
//image[trema_ruby][@<tt>{trema ruby} コマンドで Trema Ruby API リファレンスを表示したところ][width=12cm]

では、気になっていたRubyの文法にそろそろ進みましょう。第II部では今後も
たくさんRubyを使いますが、その都度必要な文法を説明しますので心配はいり
ません。しっかりついてきてください。

** 即席 Ruby 入門

外国語の習得にも言えることですが、Rubyを習得する一番の近道は登場する品
詞の種類を押さえておくことです。Rubyに出てくる名前(構成要素)には、その
品詞を見分けるための手がかりとなる視覚的なヒントがかならずあります。名
前に記号が使われていたり、最初の文字が大文字になっていたりするので、断
片的なコードを見てもすぐにどんな品詞かわかります。品詞がわかれば、その
Rubyコードがどんな構造かわかります。

これからそれぞれの品詞について簡単に説明しますが、最初からすべてが理解
できなくとも構いません。しばらくすればHello, Trema!プログラムのあらゆる
部分が識別できるようになっているはずです。

*** キーワード

Ruby にはたくさんの組み込みの語があり、それぞれに意味が与えられています。
これらの語を変数として使ったり、自分の目的に合わせて意味を変えたりはで
きません。

#+BEGIN_SRC
alias   and     BEGIN   begin   break   case    class   def     defined
do      else    elsif   END     end     ensure  false   for     if
in      module  next    nil     not     or      redo    rescue  retry
return  self    super   then    true    undef   unless  until   when
while   yield
#+END_SRC

このうち、「Hello Trema!」では =class= と =def= 、そして =end= キーワー
ドを使いました。

#+BEGIN_SRC ruby
  class HelloTrema < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

=class= キーワードは続く名前 (=HelloTrema=) のクラスを定義します。この
クラス定義は最後の5行目の =end= までです。 =def= キーワードは続く名前
(=start=)のメソッドを定義します。このメソッド定義は4行目の =end= までで
す。この =def= や =class= で始まって =end= で終わる領域のことをブロック
と呼びます。すべての Ruby プログラムはこのブロックがいくつか組み合わさっ
たものです。

*** 定数

=Time= や =Array= や =PORT_NUMBER= など、大文字で始まる名前が定数です。
定数はRubyの世界では英語や日本語などの自然言語における固有名詞に当たり
ます。

英語でも固有名詞は大文字で始めることになっています。たとえばTokyo
Tower(東京タワー)もそうです。東京タワーは動かすことができませんし、何か
別なものに勝手に変えることもできません。このように、固有名詞は時間とと
もに変化しないものを指します。そして固有名詞と同様、Rubyの定数は一度セッ
トすると変更できません。

#+BEGIN_SRC ruby
TokyoTower = "東京都港区芝公園4丁目2-8"
#+END_SRC

「Hello Trema!」の例では =class= キーワードに続く =HelloTrema= と、
=Controller= がそれぞれ大文字で始まるので定数です。つまり、クラス名は定
数なので実行中にその名前を変えることはできません。

#+BEGIN_SRC ruby
  class HelloTrema < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

これで「Hello Trema!」の説明に必要な品詞の説明はおしまいです。それでは
「Hello Trema!」の中身を読み解いていきましょう。

*** コントローラクラスの定義

キーワードの節で説明したように、 =class= キーワードに続く定数から=end=
までで定義されるブロックがクラス定義です。Tremaではすべてのコントローラ
はクラスとして定義され、かならずTremaの =Controller= クラスを継承します。
クラスを継承するには、

#+BEGIN_SRC ruby
class クラス名 < 親クラス名
#+END_SRC

と書きます。

#+BEGIN_SRC ruby
  class HelloTrema < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

=Controller= クラスを継承することで、コントローラに必要な基本機能が
=HelloTrema= クラスにこっそりと追加されます。雑多な初期化などの裏仕事を
=Controller= クラスが代わりにやってくれるわけです。

*** ハンドラメソッドの定義

さて、こうして定義した =HelloTrema= はどこから実行が始まるのでしょうか？
Cで言う =main()= 関数に当たるものがどこにも見あたらない気がします。

その答はTremaの動作モデルであるイベントドリブンモデルにあります。Trema
のコントローラは、様々なOpenFlowイベントに反応するイベントハンドラをま
とめたクラスとして定義できます。それぞれのイベントハンドラは、対応する
OpenFlowイベントが発生したときに自動的に呼び出されます。たとえば何か
OpenFlowメッセージが到着したとき、もしそのメッセージに対応するハンドラ
メソッドがコントローラクラスに定義されていれば、Tremaがそのメソッドを発
見して呼んでくれます。

Tremaでよく使われるイベントをここにリストアップします。

#@warn(第 II 部で使うハンドラをここですべて説明)

- =start=
  コントローラの起動時に呼ばれる
- =switch_ready=, =switch_disconnected=
  スイッチがコントローラに接続または切断したときに呼ばれる
  (@<chap>{switch_monitoring_tool}にて詳説)
- =packet_in=
  未知のパケットが到着したというPacket Inメッセージ到着時に呼ばれる
  (@<chap>{learning_switch}にて詳説)
- =flow_removed=
  フローが消された時のFlow Removedメッセージ到着時に呼ばれる
  (@<chap>{traffic_monitor}にて詳説)

ハンドラメソッドの定義は、 =def= キーワードに続く名前から =end= までで
定義されるブロックです。たとえば =HelloTrema= の例では =start= ハンドラ
メソッドを定義しており、これがコントローラの起動イベント発生時、つまり
=trema run= でコントローラを起動したときに自動的に呼ばれます。 =start=
ハンドラメソッド中の =puts= はRuby組込みのメソッドで、Cの =puts()= 関数
と同じく文字列を標準出力へ改行付きで出力します。

#+BEGIN_SRC ruby
  class HelloTrema < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

**** コラム @<ruby>{取間,とれま}先生いわく: ハンドラメソッドの自動呼び出し

プログラミング経験の長い読者の中には、「ハンドラメソッドを定義しただけ
なのに、なぜTremaはこのメソッドを自動的にみつけられるんだろう？」と不思
議に思った人がいるかもしれません。プログラム中にどういう関数があるか(=
コンパイル時情報)をプログラム自身が知る(=実行時)ことはむずかしいからで
す。特にCではコンパイル時と実行時の間にはぶ厚いカーテンが引かれているの
で普通は無理です。

実は、Rubyにはイントロスペクション(リフレクションや自己反映計算とも呼
ぶ)と呼ばれる機能があり、オブジェクトが自らの持つメソッドを実行時に調べ
ることができます。たとえばPacket Inメッセージが到着したとき、コントロー
ラはイントロスペクションして自分が =packet_in= というメソッドを持ってい
るかどうかを実行時に調べます。そしてもしみつかればそのメソッドを呼んで
あげるというわけです。この機能は =Controller= クラスを継承したときに自
動的にコントローラへと導入されます。

(コラム終わり)

これで「Hello Trema!」の説明はおしまいです。Tremaで作るコントローラは基
本的にこの「Hello, Trema!」と同じ構成をしています。つまり、これをベース
にいくつか必要なハンドラメソッドを追加していけば、より複雑で実践的なコ
ントローラを作ることができます。

** Tremaのファイル構成

最後にTremaのファイル構成を見ておきましょう。Tremaをダウンロードすると、
いくつかのファイルとディレクトリがあることがわかります。次に主要なもの
を挙げましょう。

- =bin/=: 各種コマンドの本体が置かれるディレクトリ
- =build.rb=: ビルドスクリプト
- =cruise.rb=: すべてのテストコードを実行するテストスイート(Trema開発者向け)
- =features/= 受け入れテスト一式(Trema開発者向け。)
- =ruby/= Rubyライブラリのソースコード
- =spec/= Rubyのユニットテスト一式(Trema開発者向け)
- =src/examples/= サンプルアプリ
- =src/lib/= Cライブラリのソースコード
- =tmp= ログファイルやPIDファイルといった一時ファイルの置き場
- =trema= =trema= コマンド
- =unittests/= Cのユニットテスト一式(Trema開発者向け)

この中でもTremaでコントローラを作りたい人が読むべきは、サンプルアプリ
(=[trema]/src/examples=)です。

*** コラム @<ruby>{取間,とれま}先生いわく: Trema のテスト

Tremaにはずいぶんたくさんのテストコードが付いていて、Trema 開発者がテス
トをとても重視していることがわかると思います。テストの実行頻度も徹底し
ていて、開発者が新しいコードをコミットする度にすべてのテスト
(=cruise.rb= スクリプト)を自動的に実行することで、「いつダウンロードし
ても正しく動く」ことを保証しているのです。この手法をよく「継続的インテ
グレーション」と呼びます。

#@warn(テストランプと天井の蛍光灯がかぶって見づらいので、写真を撮り直し)
//image[ccrb][テストの実行結果を示すランプ][width=5cm]

Tremaを壊さないために、1つおもしろい工夫があります。@<img>{ccrb}は
Trema開発者の机に置いてあるランプで、テストの実行結果をランプの色で視覚
的にフィードバックします。テストがすべて通るとランプが緑色に光り、もし
エラーが起こった場合には、ランプが赤く光り開発メンバー全員にメールが飛
びます。これによって、万が一壊してしまっても必ず誰かが気付けるようにし
ています。

このしくみには、環境構築が手軽な
CruiseControl.rb(http://cruisecontrolrb.thoughtworks.com/)と自作プラグ
インを使っています。

** サンプルアプリ

サンプルアプリ(=[trema]/src/examples/=)は簡単なOpenFlowアプリケーション
をたくさん含んでおり、実際のAPIの使い方を調べるのに便利です。以下におも
なサンプルアプリをまとめます(括弧内は =[trema]/src/examples/= 内のディ
レクトリ名)。このうちいくつかは続く章で詳しく説明していきます。

- こんにちはTrema(=hello_trema=)
  この章で説明した「Hello Trema!」と表示するだけのサンプル。これを
  =trema run= コマンドで実行すれば、手っ取り早くTremaを試すことがで
  きる(Tremaを始めたばかりの初心者向け)
- Packet In(=packet_in=)
  OpenFlowメッセージの中でも重要なPacket Inメッセージをハンドルするサン
  プル。OpenFlowメッセージハンドラの定義方法や、Packet Inメッセージの取
  り扱いの基本が学べる
- スイッチの監視(=switch_monitor=)
  スイッチがコントローラへ接続したり逆に切断したときのイベントを捕捉す
  るサンプル。複数のハンドラを使った少し複雑なコントローラの実装が学べ
  る(@<chap>{switch_monitoring_tool}にて詳説)
- OpenFlowメッセージのダンプ(=dumper=)
  コントローラが受け取るすべてのOpenFlowメッセージを文字列としてダンプ
  するサンプル。さまざまなハンドラの書き方リファレンスとして役に立つ
- スイッチ情報(=switch_info=)
  スイッチの詳細情報を要求するFeatures Requestメッセージをコントローラ
  に送信し、スイッチから受信したスイッチ情報を出力するサンプル。コント
  ローラからスイッチへOpenFlowメッセージを送る方法が学べる
- リピータハブ(=repeater_hub=)
  いわゆるバカハブ(ダムハブ)の実装。重要なOpenFlowメッセージであるFlow
  ModとPacket Outの基本が学べる。@<chap>{tdd}では少し進んだ話題として、
  これを題材にコントローラのテスト駆動開発手法を学ぶ
- ラーニングスイッチ(=learning_switch=)
  普通のスイッチをエミュレートするサンプル。FDBなどスイッチの基本構成を
  学ぶことができる(@<chap>{learning_switch}で詳説)
- トラフィックモニタ(=traffic_monitor=)
  ラーニングスイッチを拡張し、ユーザごとのトラフィックを測れるようにし
  たもの。フローに含まれる統計情報の利用例として役に立つ
  (@<chap>{traffic_monitor}にて詳説)
- 複数スイッチ対応ラーニングスイッチ(=multi_learning_switch=)
  ラーニングスイッチの複数スイッチ版です。ラーニングスイッチとの違い、
  とくにスイッチごとに FDB を管理する部分に注目してください。
- シンプルルータ(=simple_router=)
  ルータの基本機能を実装したサンプル。ルータでのパケットの書き換えと転
  送、およびルーティングテーブルの実装などルータの基本が学べる
  (@<chap>{router_part1}および@<chap>{router_part2}で詳説)

Trema にはたくさんのAPIがあり、上述したサンプルではまだまだすべてを紹介
しきれていません。新しいサンプルアプリを作った人は、ぜひGitHubでpullリ
クエストを送ってください。あなたの名前がTremaプロジェクトの貢献者リスト
(https://github.com/trema/trema/graphs/contributors)に載るかもしれませ
ん!

** まとめ

さて、これでTremaの基本はおしまいです。この章ではTremaをセットアップし、
すべてのコントローラのテンプレートとなる「Hello, Trema!」コントローラを
書きました。この章で学んだことを簡単にまとめてから、実践的なコントロー
ラの開発に入っていくことにしましょう。

- TremaはRubyGemsまたはソースコードからビルドしてインストールできる
- コントローラは =trema run= コマンドでコンパイル無しにすぐ実行できる
- コントローラはRubyのクラスとして定義し、 =Controller= クラスを継承す
  ることで必要なメソッドや機能が取り込まれる
- コントローラクラスに各種イベントに対応するハンドラを定義することで
  OpenFlowコントローラを実装できる。たとえば、起動イベントに対応するハ
  ンドラは =start=
- Tremaのファイル構成と主なサンプル一覧

これで基礎は十分にできました。次の章では、いよいよ実用的なOpenFlowコン
トローラを書き実際にスイッチをつないでみます。

** 参考文献

Rubyプログラミングが初めてという人達のために、この章では入門に役立つサ
イトや本をいくつか紹介します。

- Why's (Poignant) Guide to Ruby(http://mislav.uniqpath.com/poignant-guide/)
  私は大学や職場でいろいろなプログラミング言語を勉強してきましたが、こ
  れほど読んでいて楽しい本に出会ったことはありません。この本はRuby界の
  謎の人物_why氏による風変りなRuby入門で、プログラミング言語の解説書に
  もかかわらずまるで小説やマンガのようにリラックスして読めます。この章
  のRubyの品詞の説明は、この本を参考にしました。(日本語版はこちら
  http://www.aoky.net/articles/why_poignant_guide_to_ruby/)。
- TryRuby(http://tryruby.org/)
  同じく_why氏によるブラウザで動くRuby環境です。Rubyを試してみたいけど
  インストールするのが面倒という人は、まずはここでRubyを試してみましょ
  う。 =help= と打つと15分の短いRubyチュートリアルが始まります。
- プログラミングRuby第2版(Dave Thomas、Chad Fowler、Andrew Hunt著、田和勝、まつもとゆきひろ訳／オーム社)
  Rubyの完全なリファレンスです。本気でRubyを勉強したい人は持っていて損
  はしません。この本だけあれば十分です。
