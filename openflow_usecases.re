= OpenFlow のユースケース

OpenFlow スイッチには「コントローラさえ書けば、どんなネットワーク機器にも化けられる」という特長があります。乱暴に言うと、スイッチはもちろんルータやロードバランサ、ファイアウォールや NAT など複雑な機器もがんばれば作れてしまいます。もちろん、機能の一部をソフトウェアとして実装することになるので性能は落ちます。しかし、ソフトウェア次第で何でもできる事に変わりはありません。

この何でもできるという特長は、元々は大学や研究所などアカデミアからのニーズによって生まれたものでした。今までのスイッチやルータにとらわれない、まったく新しいネットワークを研究したい。でもすでにあるスイッチやルータのファームウェアを改造するのは大変、かと言って一からハードウェアは作りたくないし…大規模な仮想ネットワーク上で実験してもいいけど、それだと実際の環境とあまりにも違いすぎる。このジレンマを解消するために考え出されたのが OpenFlow だったわけです。

では、アカデミア出身の OpenFlow が現在のように産業界でも注目されるようになったのはなぜでしょうか？@<chap>{whats_openflow}でも触れましたが、主な理由は次の 3 つです。

 1. OpenFlow で作ったネットワークは、既存のシステムとの連携がしやすくなります。たとえばデータセンターのジョブ管理やスケジューラ、または職場の業務システム等とコントローラをつなげば、既存システムと連携した高度なネットワーク制御のできあがりです。
 2. OpenFlow でしかできないこともあります。今までの分散型ネットワークでは苦手だった全体最適化が、OpenFlow の集中管理でできるようになるからです。ネットワーク全体を制御する神様であるコントローラが集中管理するおかげで、分散での局所最適化的な管理が全体最適化ができます。
 3. OpenFlow はスイッチの価格破壊をもたらします。コントローラに命令されるだけの単純な OpenFlow スイッチは新興スイッチベンダにも簡単に作れますし、大量生産に乗せやすいので安く作れます。このおかげで、たとえばデータセンターのようなスイッチを大量につないだ設備を従来よりもずっと安く構築できます。

これらをふまえ「OpenFlow でうまく行く」具体的なユースケースを見ていくことで、OpenFlow 活用のイメージをふくらませましょう。

== フローでできること

具体的なユースケースに入る前に、まずは手持ちのカードをじっくり眺めてみます。フローでできることは何でしょう? これも@<chap>{whats_openflow}で触れましたが、基本的には次の 4 つです。

 1. パケットを曲げる
 2. 書き換える
 3. 分岐させる
 4. 流量を調べる

昔懐かしい水道管ゲームを思い出してください。水道局から目的地まで、さまざまな形の水道管のカードをならべて水を届けるゲームです。

フローでできることはこれと同じです。パケットを目的のホストとは違うホストに曲げる。パケットの中身を途中で書き換える。パケットを複製していくつかの宛先に向けて分岐させる。それぞれのフローの流量を調べる。これが OpenFlow スイッチでできることのすべてです。これを自由に組み合わせて、様々なネットワークを作ることができます。

== サーバの負荷を分散する

「パケットを曲げる」と「流量を調べる」を組み合わせると、いわゆるロードバランサを OpenFlow で実現できます (@<img>{load_balancer})。ロードバランサとは、Web サーバなど負荷が集中しやすいサーバを複数台のバックエンドサーバに分け、クライアントからのリクエストを振り分ける部品です。OpenFlow ではクライアントごとにパケットを曲げて本来とは違う宛先に届けることができるのでした。これを使うと、クライアントごとに異なるバックエンドサーバに分けることができます。また、OpenFlow ではそれぞれのフローの流量を調べることができるのでした。これを使うと、空いているバックエンドを優先して振り分けることができます。

//image[load_balancer][OpenFlow でロードバランサを実現する][scale=0.5]

バックエンドへの振り分けをどうバランスするかという部分は、システムとの連携でより高度なことができます (@<img>{advanced_load_balancer})。たとえば、アクセスが減る夜中になればバックエンドサーバ数を減らしてリクエストを振り分け先も減らす。逆にアクセスが増えてくれば、バックエンドサーバを増やして振り分け先も増やす。既存システムとしてバックエンドサーバのリソースマネジメント機能があれば、コントローラをこれと連携させることでこのような高度な自動化も簡単です。

//image[advanced_load_balancer][リソースマネージャと連携したロードバランサの例][scale=0.5]

== ネットワーク障害から復旧する

「分岐させる」の機能で複数の経路を作ると、ネットワークに障害が起こった場合でもパケットをロスせずに復旧できます。@<img>{fail_over} のようにクライアントとサーバが通信する状況で、障害が起こってもパケットをひとつも落とさずに通信を継続したい場合を考えてください。左のスイッチはパケットを複製し、2 つの経路に分けて分岐します。受け取る側は、正常時はどちらか一方を受け取るようにしておきます。

//image[fail_over][冗長なパスでフェイルオーバー][scale=0.5]

ここでもし下の経路に障害が起こった場合、パケットを一つも落とさずに上の経路に切り替えることができます。もしもともとの 2 重冗長構成にしたい場合には、下のスイッチに「パケットを曲げる」フローを打ち込むことで迂回路を作れます。

//image[advanced_fail_over][冗長なパスを作りなおして 2 重冗長を確保][scale=0.5]

ここで重要なのは、コントローラは全体の状況を見て自由自在に経路を決めることができるということです。従来のネットワークでは、各スイッチが個別に最適となるような経路を決めるため最短路などの特定の経路しか取れませんでした。逆に OpenFlow では、コントローラが全体の道路と交通状況を逐一判断しています。たとえばどこの道路が通れないといった情報をすべて把握していて、車をどこに回すかも自由自在ということです。

== ネットワークを有効に使う

「パケットを曲げる」を使うと、VM イメージなどの大きなデータを効率的に転送するために、複数のパスを使うことができます。転送元から転送先へ複数のコネクションを張り、空いているパスをめいっぱい使ってデータを転送できます。

//image[maximize_bandwidth][複数パスを使ってバンド幅を最大化][scale=0.5]

この方法はネットワークを複数のアプリで使う場合にも役立ちます。図のようにデータ転送をするアプリケーションが 3 組いる状況を考えてください。ここでもし 3 つすべてが上のリンクを使ってしまうと混んでしまいます。しかし上下のリンクを使うようにすればより速く転送できます。

//image[sharing_bandwidth][バンド幅を 3 つのアプリでシェア][scale=0.5]

== VM を移動する

OpenFlow ではパケットの中身を見て転送先を自由に決められるので、従来の IP アドレスによらない自由な転送方式を実装できます。これを使えば、たとえばデータセンター内での VM 移動など IP アドレスが変わると困るものを、IP アドレスを変えずに自由に転送できます。

//image[vm_migration][IP アドレスを変えずに VM を移動][scale=0.5]

== セキュアなネットワークを作る

//image[secure_network][端末を認識し、認証と検疫をするネットワーク][scale=0.5]

== まとめ

OpenFlow がうまく行く具体的なユースケースを見てきました。OpenFlow はプログラミング次第で何にでもなれるオールマイティな存在ですが、とくに既存システムとの連携、全体最適化が得意分野です。新しいユースケース

次章では OpenFlow の仕様を少し詳しく紹介します。
