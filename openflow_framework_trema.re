= OpenFlow フレームワーク Trema

#@warn(気の利いたリード文をここに)

== 作って分かる OpenFlow

第 II 部では、いよいよ実際に OpenFlow でネットワークをプログラムする方法を紹介します。職場や自宅のような中小規模ネットワークでもすぐに試せる実用的なコードを通じて、「OpenFlow って具体的に何に使えるの？」「OpenFlow コントローラってどう作るの？」というよくある疑問に答えていきます。題材はなるべく実用例を取り上げるようにし、また OpenFlow やネットワークの基礎から説明していくようにしました。このためネットワークの専門家はもちろん、普通のプログラマにもすんなり理解できる内容となっているはずです。

まずは、この第 II 部で使う OpenFlow プログラミングのためのフレームワーク、@<ruby>{Trema,トレマ} をあらためて紹介します。

== Trema とは

Trema は OpenFlow コントローラを開発するための Ruby 用のプログラミングフレームワークです。github 上でオープンに開発しており、GPL2 ライセンスのフリーソフトウェアです。公開は 2011 年の 4 月と比較的新しいソフトウェアですが、その使いやすさから国内外の大学や企業および研究機関などですでに数多く採用されています。

Trema の情報は主に次の URL から入手できます。

 * Trema ホームページ: @<href>{http://trema.github.com/trema/}
 * github のプロジェクトページ: @<href>{http://github.com/trema/}
 * メーリングリスト: @<href>{http://groups.google.com/group/trema-dev}
 * Twitter アカウント: @<href>{http://twitter.com/trema_news}

Trema の特長をひとことで言うと、Rails や Sinatra などの Web フレームワークに影響を受けたアジャイルなプログラミングフレームワークであるということです。たとえば最近のアジャイル開発環境ではもはや当たり前ですが、Trema は開発を効率化するツールを数多く提供しています。このように開発サイクル全体の面倒を見てくれるところが Trema の「フレームワーク」たるゆえんで、他の OpenFlow 開発ツールとはまったく違うところです。

ここからは実際にこの Trema フレームワークを使って OpenFlow コントローラを作っていきます。まずは Trema をセットアップしましょう。

===[column] @<ruby>{友太郎,ゆうたろう}の質問: Trema の由来ってなに？

#@warn(友太郎のアイコン)

Q. 「Trema ってなんとなくおもしろい名前だけど、何か由来はあるんですか？」
     
A. 筆者の一人が大好きな、大阪の「とれまレコード (@<href>{http://www.fumiyatanaka.com/})」というレコードレーベルの名前から取りました。テクノミュージックを中心にリリースする小さなレーベルですが、DJ の間では世界的に知られています。

さてそもそもこの "とれま" とはいったい何でしょう。これは日本がバブルの頃、道路の「とまれ」という標示がよく「とれま」と間違えて描かれていたという事実が元になっています。このありえない誤植の原因は、バブル景気時代に急増した外国人労働者が日本語もままならないまま道路工事現場で働いていたということにあるそうです。由来を探ってみると意外と面白い事実に行き着くことってありますね。
   
ちなみに、Trema の公式ロゴマークはこんな画像です (@<img>{trema_logo})。これは Twitter の Trema 公式アカウント (@<tt>{@trema_news}) のアイコンとしても使われています。

//image[trema_logo][Trema の公式ロゴマーク][scale=0.7]

もちろん、こんなに大胆な道路標識は日本中どこを探してもありません。この本の編集者が画像編集ソフトで試しに作ったところ評判が良かったので、そのまま公式ロゴになりました。

===[/column]

== Trema のセットアップ

Trema は Linux 上で動作し、次のディストリビューションとバージョンでの動作を保証しています。

#@warn(サポートするバージョンは後で最新版に更新)

 * Ubuntu 12.04, 11.10, 11.04, 10.10, 10.04 (i386/amd64, デスクトップ版)
 * Debian GNU/Linux 6.0 (i386/amd64)

なお保証はしていませんが、RedHat などその他の Linux ディストリビューションでも動作するはずです。

Trema の提供する trema コマンドの実行には root 権限が必要です。まずは、@<tt>{sudo} を使って root 権限でコマンドを実行できるかどうか、@<tt>{sudo} の設定ファイルを確認してください。

//cmd{
% sudo visudo
//}

@<tt>{sudo} が正しく設定されていることを確認したら、Trema のインストールや実行に必要ないくつかのソフトウェアをインストールしましょう。

#@warn(Trema のバージョンは後で最新版に更新)

 * Ruby インタプリタ。Trema は Ruby と C で作成されていて、アプリケーションの記述にも Ruby を使います。Trema では Ruby のバージョン 1.8.7 が必要です。1.8.6 以前のバージョンやバージョン 1.9 以降では今のところ動作しません。
 * Ruby のパッケージ管理システム RubyGems (@<href>{https://rubygems.org/})。本書では、RubyGems のバージョン 1.8.11 を使っています。
 * Trema 本体。本書は、Trema バージョン 0.2.2.1 を使用して執筆しています。
 * Trema のコンパイルに必要な @<tt>{gcc} や @<tt>{make}、およびいくかのライブラリ。

開発に必要なのはこれだけです。それでは、Ubuntu のパッケージ管理システム @<tt>{apt-get} を使って次のようにインストールしてください。もし他のディストリビューションを使いたい場合は、コマンド名とパッケージ名を適宜読み替えください。

//cmd{
% sudo apt-get install gcc make ruby rubygems ruby-dev irb libpcap-dev libsqlite3-dev
//}

以上で Trema をインストールするための準備が整いました。Trema をインストールするには、RubyGems のパッケージで手軽にインストールする方法と、最新のソースコードを取得して自分でビルドする方法があります。それぞれ説明していきましょう。

=== パッケージで手軽にインストールする場合

Trema は RubyGems を使って次のようにコマンド一発で簡単にインストールできます。

//cmd{
% gem install trema
//}

RubyGems でインストールした場合、自動的に Trema のコマンド @<tt>{trema} にパスが通っているはずです。次のコマンドでバージョンが表示されればインストールは成功です。

//cmd{
% trema --version
trema version 0.2.2.1
//}

=== ソースコードから最新版をインストールする場合

最新版をインストールしたい人は、github から自分でソースコードをダウンロードしてビルドすることもできます。まず、次のように @<tt>{git} を使って最新のソースコードを取得してください。

//cmd{
% git clone git://github.com/trema/trema.git
//}

次のコマンドを実行すると、Trema が依存する RubyGems のパッケージが自動的にインストールされます。

//cmd{
% cd trema
% bundle install
//}


次のコマンドで Trema をダウンロードしたディレクトリ以下に Trema がインストールされます。@<tt>{make install} のようなシステム全体へのインストール手順は不要であることに注意してください。

//cmd{
% ./build.rb
//}

次のコマンドで @<tt>{trema} コマンドが正しくインストールされたか確認してください。

//cmd{
% ./trema --version
trema version 0.2.2.1
//}

もし必要あればこのディレクトリにパスを通し、@<tt>{trema} コマンドが簡単に起動できるようにしておいてください。

さあ、これで Trema による OpenFlow 開発環境が整いました。それでは早速、入門の定番 Hello, World を Trema で書いてみましょう。

== Hello, Trema!

今から書くアプリケーションは最も簡単な OpenFlow コントローラの一種で、画面に "Hello, Trema!" と表示するだけのものです。スイッチとはまったくやりとりしないスタンドアロンのアプリケーションですが、Trema で作れるすべてのコントローラのテンプレートとなっています。

では、適当なディレクトリにエディタで @<tt>{hello-trema.rb} というファイルを開き、次のコードを入力してください。"@<tt>{.rb}" は Ruby プログラムの標準的な拡張子です。なお Ruby の文法は必要に応じておいおい説明しますので、今のところは気にせずそのまま入力してください。

//emlist{
  class HelloTrema < Controller
    def start
      puts "Hello, Trema!"
    end
  end
//}

意味はまだわからないかもしれませんが、とてもシンプルに書けることはわかると思います。それでは細かい文法は後で見るとして「習うより慣れろ」でさっそく実行してみましょう。

=== 実行してみよう (@<tt>{trema run})

作成したコントローラは @<tt>{trema run} コマンドですぐに実行できます。Ruby はインタプリタ言語なので、コンパイルの必要はありません。ターミナルで次のように入力すると、この世界一短い OpenFlow コントローラはフォアグラウンドプロセスとして起動し、画面に@<tt>{Hello, Trema!} と出力します。起動したコントローラは Ctrl + C で停止できます。

//cmd{
% trema run ./hello-trema.rb
Hello, Trema!  # Ctrl+c で終了
%
//}

いかがでしょうか？ @<tt>{trema} コマンドを使うと、とても簡単にコントローラを実行できることがわかると思います。@<tt>{trema} コマンドには他にもいくつかの機能がありますのでここで簡単に紹介しておきましょう。

== @<tt>{trema コマンド}

@<tt>{trema} コマンドは Trema 唯一のコマンドラインツールであり、コントローラの起動やテストなど様々な用途に使います。たとえば先ほどの "Hello Trema!" で見たように、@<tt>{trema run} はコントローラを起動するためのコマンドです。起動したコントローラは OpenFlow スイッチと接続しメッセージをやりとりします。また、次の章以降で触れますが @<tt>{trema run} コマンドはオプションで仮想ネットワークを作ることもでき、作ったコントローラをこの仮想ネットワークの中でテストできます。このように、@<tt>{trema} コマンドは Trema フレームワークにおける中心的なツールで、あらゆるコントローラ開発の出発点と言えます (@<img>{trema_overview})。

//image[trema_overview][@<tt>{trema} コマンドでコントローラを実ネットワークや仮想ネットワークで実行]

@<tt>{trema} コマンドは @<tt>{git} や @<tt>{svn} コマンドと似たコマンド体系を持っており、@<tt>{trema} に続けて @<tt>{run} などのサブコマンドを指定することで様々な機能を呼び出します。こうしたコマンド体系を一般に "コマンドスイート" と呼びます。

一般的なコマンドスイートと同じく、サブコマンドの一覧は @<tt>{trema help} で表示できます。また、サブコマンド自体のヘルプは @<tt>{trema help [サブコマンド]} で表示できます。以下に @<tt>{trema help} で表示されるサブコマンド一覧をざっと紹介しておきましょう。いくつかのサブコマンドはまだ使い方を紹介していませんが、続く章で説明しますので今は目を通すだけでかまいません。

: @<tt>{trema run}
  コントローラをフォアグラウンドで実行します。@<tt>{--daemonize (-d)} オプションを付けるとコントローラをバックグラウンド (デーモンモード) として実行できます。

: @<tt>{trema killall}
  バックグラウンドで起動している Trema プロセス全体を停止します。
  
: @<tt>{trema version}
  Trema のバージョンを表示します。@<tt>{trema --version} と同じです。

: @<tt>{trema ruby}
  Trema の Ruby API を表示します。

: @<tt>{trema kill [仮想スイッチまたはリンク]}
  仮想ネットワーク内の指定したスイッチやリンクを停止します。 @<chap>{switch_monitoring_tool} で紹介します。

: @<tt>{trema up [仮想スイッチまたはリンク]}
  仮想ネットワークの指定したスイッチやリンクを再起動します。@<chap>{switch_monitoring_tool} で紹介します。

: @<tt>{trema send_packets [送信オプション]}
  仮想ネットワーク内でテストパケットを送信します。 @<chap>{learning_switch} で紹介します。
  
: @<tt>{trema show_stats [仮想ホスト名]}
  仮想ネットワーク内の仮想ホストで送受信したパケットの統計情報を表示します。@<chap>{learning_switch} で紹介します。

: @<tt>{trema reset_stats}
  仮想ネットワーク内の仮想ホストで送受信したパケットの統計情報をリセットします。@<chap>{learning_switch} で紹介します。

: @<tt>{trema dump_flows [仮想スイッチ名]}
  仮想ネットワーク内の仮想スイッチのフローテーブルを表示します。@<chap>{learning_switch} で紹介。

この章ではさきほど使った @<tt>{trema run} に加えて、Ruby API を表示する @<tt>{trema ruby} コマンドを覚えておいてください。@<tt>{trema ruby} を実行するとデフォルトブラウザで Trema Ruby API リファレンスのページが開きます (@<img>{trema_ruby})。プログラミング中いつでもコマンド一発でリファレンスを開けるので大変便利です。

#@warn(API のページが YARD のせいで壊れているので、直してからスクリーンショット撮り直し)
//image[trema_ruby][@<tt>{trema ruby} コマンドで Trema Ruby API リファレンスを表示したところ]

では、気になっていた Ruby の文法にそろそろ進みましょう。第 II 部では今後もたくさん Ruby を使いますが、その都度必要な文法を説明しますので心配はいりません。しっかりついてきてください。

== 即席 Ruby 入門

外国語の習得にも言えることですが、Ruby を習得する一番の近道は登場する品詞の種類を押さえておくことです。Ruby に出てくる名前 (構成要素) には、その品詞を見分けるための手がかりとなる視覚的なヒントがかならずあります。名前に記号が使われていたり、最初の文字が大文字になっていたりするので、断片的なコードを見てもすぐにどんな品詞かわかります。品詞がわかれば、その Ruby コードがどんな構造かわかります。

これからそれぞれの品詞について簡単に説明しますが、最初からすべてが理解できなくとも構いません。しばらくすれば "Hello, Trema!" プログラムのあらゆる部分が識別できるようになっているはずです。

=== キーワード

Ruby にはたくさんの組み込みの語があり、それぞれに意味が与えられています。これらの語を変数として使ったり、自分の目的に合わせて意味を変えたりはできません。

//quote{
@<tt>{alias   and     BEGIN   begin   break   case    class   def     defined }
@<tt>{do      else    elsif   END     end     ensure  false   for     if }
@<tt>{in      module  next    nil     not     or      redo    rescue  retry }
@<tt>{return  self    super   then    true    undef   unless  until   when }
@<tt>{while   yield}
//}

このうち、"Hello Trema!" では @<tt>{class} と @<tt>{def}, @<tt>{end} キーワードを使いました。

//emlist{
@<ami>{class} HelloTrema < Controller
   @<ami>{def} start
     puts "Hello, Trema!"
   @<ami>{end}
@<ami>{end}
//}

@<tt>{class} キーワードは続く名前 (@<tt>{HelloTrema}) のクラスを定義します。このクラス定義は最後の 5 行目の @<tt>{end} までです。@<tt>{def} キーワードは続く名前 (@<tt>{start}) のメソッドを定義します。このメソッド定義は 4 行目 の @<tt>{end} までです。この @<tt>{def} や @<tt>{class} で始まって @<tt>{end} で終わる領域のことをブロックと呼びます。すべての Ruby プログラムはこのブロックがいくつか組み合わさったものです。

=== 定数

@<tt>{Time} や @<tt>{Array} や @<tt>{PORT_NUMBER} など、大文字で始まる名前が定数です。定数は Ruby の世界では固有名詞に当たります。

英語でも固有名詞は大文字で始めることになっています。たとえば Tokyo Tower (東京タワー) もそうです。東京タワーは動かすことができません。東京タワーを何か別なもののことだと勝手に決めることもできません。固有名詞というのはそういうものです。固有名詞はある特定の、通常は時間とともに変化しないものを指しています。そして固有名詞と同様、Ruby の定数は一度セットすると変更できません。

//quote{
TokyoTower = "東京都港区芝公園 4 丁目 2-8"
//}

"Hello Trema!" の例では @<tt>{class} キーワードに続く @<tt>{HelloTrema} と、@<tt>{Controller} がそれぞれ大文字で始まるので定数です。つまり、クラス名は定数なので実行中にその名前を変えることはできません。

//emlist{
class @<ami>{HelloTrema} < @<ami>{Controller}
  def start
    puts "Hello, Trema!"
  end
end
//}

これで "Hello Trema!" の説明に必要な品詞の説明はおしまいです。それでは "Hello Trema!" の中身を読み解いていきましょう。

=== コントローラクラスの定義

キーワードの節で説明したように、@<tt>{class} キーワードに続く定数から @<tt>{end} までで定義されるブロックがクラス定義です。Trema ではすべてのコントローラはクラスとして定義され、かならず Trema の @<tt>{Controller} クラスを継承します。クラスを継承するには、@<tt>{class クラス名 < 親クラス名} と書きます。

//emlist{
@<ami>{class HelloTrema < Controller}
  def start
    puts "Hello, Trema!"
  end
@<ami>{end}
//}

@<tt>{Controller} クラスを継承することで、コントローラに必要な基本機能が @<tt>{HelloTrema} クラスにこっそりと追加されます。雑多な初期化などの裏仕事を @<tt>{Controller} クラスが代わりにやってくれるわけです。

=== ハンドラメソッドの定義

さて、こうして定義された @<tt>{HelloTrema} はどこから実行が始まるのでしょうか？ C 言語で言う @<tt>{main()} 関数に当たるものがどこにも見あたらない気がします。

その答は Trema の動作モデルであるイベントドリブンモデルにあります。Trema のコントローラは、様々な OpenFlow イベントに反応するイベントハンドラをまとめたクラスとして定義できます。それぞれのイベントハンドラは、対応する OpenFlow イベントが発生したときに自動的に呼び出されます。たとえば OpenFlow メッセージの到着イベントが発生したとき、もしそのメッセージに対応するハンドラメソッドがコントローラクラスに定義されていれば、Trema がそのメソッドを発見して呼んでくれます。

Trema でよく使われるイベントをここでリストアップしておきましょう。

#@warn(第 II 部で使うハンドラをここですべて説明)

: @<tt>{start}
  コントローラの起動時に呼ばれる。

: @<tt>{switch_ready}, @<tt>{switch_disconnected}
  スイッチがコントローラに接続または切断したときに呼ばれる。@<chap>{switch_monitoring_tool} で詳しく紹介。

: @<tt>{packet_in}
  未知のパケットが到着したという Packet In メッセージ到着時に呼ばれる。@<chap>{learning_switch} で詳しく紹介。

: @<tt>{flow_removed}
  フローが消された時の Flow Removed メッセージ到着時に呼ばれる。@<chap>{traffic_monitor} で詳しく紹介。

ハンドラメソッドの定義は、@<tt>{def} キーワードに続く名前から @<tt>{end} までで定義されるブロックです。たとえば @<tt>{HelloTrema} の例では @<tt>{start} ハンドラメソッドを定義しており、これがコントローラの起動イベント発生時、つまり @<tt>{trema run} でコントローラを起動したときに自動的に呼ばれます。@<tt>{start} ハンドラメソッド中の @<tt>{puts} は Ruby 組込みのメソッドで、C 言語の @<tt>{puts()} 関数と同じく文字列を標準出力へ改行付きで出力します。

//emlist{
class HelloTrema < Controller
  @<ami>{def start}
    puts "Hello, Trema!"
  @<ami>{end}
end
//}

===[column] @<ruby>{取間,とれま}先生曰く: ハンドラメソッドの自動呼び出し

プログラミング経験の長い読者の中には、「ハンドラメソッドを定義しただけなのに、なぜ Trema はこのメソッドを自動的にみつけられるんだろう」と不思議に思った人がおるかもしれん。プログラム中にどういう関数があるか (= コンパイル時情報) をプログラム自身が知る (= 実行時) ことはむずかしいからじゃ。特に C などの古い言語ではコンパイル時と実行時の間にはぶ厚いカーテンが引かれているので普通は無理じゃ。

いっぽう、Ruby にはイントロスペクション (リフレクションや自己反映計算とも呼ぶ) と呼ばれる機能があって、クラスが自らの持つメソッドを実行時に調べることができる。たとえば Packet In メッセージが到着したとき、コントローラクラスはイントロスペクションして自分が @<tt>{packet_in} というメソッドを持っているかどうかを実行時に調べる。そしてもしみつかればそのメソッドを呼んであげるというわけじゃ。ちなみにこの機能は @<tt>{Controller} クラスを継承したときに自動的に導入される。

イントロスペクションは Ruby の他にも Python や Java といった最近の言語ではサポートされておるが、Trema 以外の OpenFlow フレームワークでは明示的にハンドラメソッドとイベントを結びつけなければならないようじゃ。たとえば NOX (Python 版) の場合はこう書く必要がある。

//emlist{
#
# 次のハンドラの登録 
#  * Packet In が来たら packet_in_callback メソッドを呼ぶ
#  * スイッチが接続したら datapath_join_callback メソッドを呼ぶ
#  * スイッチが切断したら datapath_leave_callback メソッドを呼ぶ
#
inst.register_for_packet_in(packet_in_callback)
inst.register_for_datapath_leave(datapath_leave_callback)
inst.register_for_datapath_join(datapath_join_callback)
//}

この方式の大きな問題点は、ハンドラメソッド名の変更が面倒臭いことじゃ。たとえば @<tt>{packet_in_callback} メソッドの名前を変更した場合 @<tt>{register_for_packet_in} の引数も忘れずに変更する必要がある。こうした変更は忙しいとポカしてしまうことが多く、すぐにバグの元になる。

一方で Trema はハンドラメソッドを自動呼び出しにしているので、こうした手間は発生しない。また @<tt>{register_for_xxx} のような明示的なハンドラの登録を書かなくていいので、大幅にコード量を削減することができる。短いコードは書きやすく、読みやすく、またメンテしやすいものじゃ。

===[/column]

これで "Hello Trema!" の説明はおしまいです。Trema で作るコントローラは基本的にこの "Hello, Trema!" と同じ構成をしています。つまり、これをベースにいくつか必要なハンドラメソッドを追加していけば、より複雑で実践的なコントローラも作ることができます。

== Trema のファイル構成

最後に Trema のファイル構成を見ておきましょう。Trema をダウンロードする
と、いくつかのファイルとディレクトリがあることがわかります。次に主要な
ものを挙げましょう。

 * @<tt>{bin/}: 各種コマンドの本体が置かれるディレクトリ。
 * @<tt>{build.rb}: ビルドスクリプト。
 * @<tt>{cruise.rb}: すべてのテストコードを実行するテストスイート。Trema 開発者向け。
 * @<tt>{features/}: 受け入れテスト一式。Trema 開発者向け。
 * @<tt>{ruby/}: Ruby ライブラリのソースコード。
 * @<tt>{spec/}: Ruby のユニットテスト一式。Trema 開発者向け。
 * @<tt>{src/examples/}: サンプルアプリ。
 * @<tt>{src/lib/}: C ライブラリのソースコード。
 * @<tt>{tmp}: ログファイルや PID ファイルといった一時ファイルの置き場。
 * @<tt>{trema}: trema コマンド。
 * @<tt>{unittests/}: C のユニットテスト一式。Trema 開発者向け。
 
この中でも Trema でコントローラを作りたい人が読むべきは、サンプルアプリ (@<tt>{[trema]/src/examples}) です。

===[column] @<ruby>{取間,とれま}先生曰く: Trema のテスト

Trema にはずいぶんたくさんのテストコードが付いていて、Trema 開発者がテストをとても重視していることがわかるじゃろう。テストの実行頻度も徹底していて、開発者が新しいコードをコミットする度にすべてのテスト (@<tt>{cruise.rb} スクリプト) を自動的に実行し、「いつダウンロードしても正しく動く」ことを保証しているのじゃ。これを難しい言葉で "継続的インテグレーション" と呼ぶ。

#@warn(テストランプと天井の蛍光灯がかぶって見づらいので、写真を撮り直し)
//image[ccrb][テストの実行結果を示すランプ][scale=0.7]

Trema を壊さないために、ひとつおもしろい工夫があるのじゃ。@<img>{ccrb} はTrema 開発者の机に置いてあるランプで、テストの実行結果をランプの色で視覚的にフィードバックする。テストがすべて通るとランプが緑色に光る。もしエラーが起こった場合には、ランプが赤く光り開発メンバー全員にメールが飛ぶ。これによって、万が一壊してしまっても必ず誰かが気付けるようにしているのじゃ。

このしくみには、環境構築が手軽な CruiseControl.rb (@<href>{http://cruisecontrolrb.thoughtworks.com/}) と自作プラグインを使っているぞ。

===[/column]

== サンプルアプリ

サンプルアプリ (@<tt>{[trema]/src/examples/}) は簡単な OpenFlow アプリケーションをたくさん含んでおり、実際の API の使い方を調べるのに便利です。以下におもなサンプルアプリをまとめます (括弧内は @<tt>{[trema]/src/examples/} 内のディレクトリ名)。このうちいくつかは続く章で詳しく説明していきます。

: こんにちは Trema (@<tt>{hello_trema})
  この章で説明した "Hello Trema!" と表示するだけのサンプルです。これを @<tt>{trema run} コマンドで実行すれば、手っ取り早く Trema を試すことができます。Trema を始めたばかりの初心者向け。

: Packet In (@<tt>{packet_in})
  OpenFlow メッセージの中でも重要な Packet In メッセージをハンドルするサンプルです。OpenFlow メッセージハンドラの定義方法や、Packet In メッセージの取り扱いの基本が学べます。

: スイッチの監視 (@<tt>{switch_monitor})
  スイッチがコントローラへ接続したり逆に切断したときのイベントを捕捉するサンプルです。複数のハンドラを使った少し複雑なコントローラの実装が学べます。@<chap>{switch_monitoring_tool}で詳しく説明します。

: OpenFlow メッセージのダンプ (@<tt>{dumper})
  コントローラが受け取るすべての OpenFlow メッセージを文字列としてダンプするサンプルです。さまざまな OpenFlow メッセージのハンドラの書き方のリファレンスとして役に立ちます。

: スイッチ情報 (@<tt>{switch_info})
  スイッチの詳細情報を要求する Features Request メッセージをコントローラに送信し、スイッチから受信したスイッチ情報を出力するサンプルです。コントローラからスイッチへ OpenFlow メッセージを送る方法が学べます。

: リピータハブ (@<tt>{repeater_hub})
  いわゆるバカハブ (ダムハブ) の実装です。重要な OpenFlow メッセージである Flow Mod と Packet Out の基本が学べます。@<chap>{tdd}では少し進んだ話題として、これを題材にコントローラのテスト駆動開発手法を学びます。

: ラーニングスイッチ (@<tt>{learning_switch})
  普通のスイッチ (レイヤ 2 スイッチ) をエミュレートするサンプルです。FDB などスイッチの基本構成を学ぶことができます。詳しくは@<chap>{learning_switch}で説明します。

: トラフィックモニタ (@<tt>{traffic_monitor})
  ラーニングスイッチを拡張し、ユーザごとのトラフィックを測れるようにしたものです。フローに含まれる統計情報の利用例として役に立ちます。詳しくは@<chap>{traffic_monitor}で説明します。

: 複数スイッチ対応ラーニングスイッチ (@<tt>{multi_learning_switch})
  ラーニングスイッチの複数スイッチ版です。ラーニングスイッチとの違い、とくにスイッチごとに FDB を管理する部分に注目してください。

: シンプルルータ (@<tt>{simple_router})
  ルータの基本機能を実装したサンプルです。ルータでのパケットの書き換えと転送、およびルーティングテーブルの実装などルータの基本が学べます。詳しくは@<chap>{router_part1}および@<chap>{router_part2}で説明します。

Trema にはたくさんの API があり、この表に掲載したサンプルではまだまだすべてを紹介しきれていません。新しいサンプルアプリを作った人は、ぜひ github で pull リクエストを送ってください。あなたの名前が Trema プロジェクトの貢献者リスト (@<href>{https://github.com/trema/trema/graphs/contributors}) に載るかもしれません!

== まとめ

さて、これで Trema の基本はおしまいです。この章では Trema をセットアップし、すべてのコントローラのテンプレートとなる Hello, Trema! コントローラを書きました。この章で学んだことを簡単にまとめてから、実践的なコントローラの開発に入っていくことにしましょう。

 * Trema は RubyGems またはソースコードからビルドしてインストールできます。
 * コントローラは @<tt>{trema run} コマンドでコンパイル無しにすぐ実行できます。
 * コントローラは Ruby のクラスとして定義し、@<tt>{Controller} クラスを継承することで必要なメソッドや機能が取り込まれます。
 * コントローラクラスに各種イベントに対応するハンドラを定義することで OpenFlow コントローラを実装できます。たとえば、起動イベントに対応するハンドラは @<tt>{start} です。
 * Trema のファイル構成をおおざっぱに見ました。続く章では Trema のサンプルアプリ (@<tt>{[trema]/src/examples}) のいくつかを題材に、OpenFlow プログラミングを学んでいきます。

これで基礎は十分にできました。次の章では、いよいよ実用的な OpenFlow コントローラを書き実際にスイッチをつないでみます。

== 参考文献

Ruby プログラミングが初めてという人達のために、この章では入門に役立つサイトや本をいくつか紹介します。

: Why's (Poignant) Guide to Ruby (@<href>{http://mislav.uniqpath.com/poignant-guide/})
  私は大学や職場でいろいろなプログラミング言語を勉強してきましたが、これほど読んでいて楽しい本に出会ったことはありません。この本は Ruby 界の謎の人物 _why 氏による風変りな Ruby 入門で、プログラミング言語の解説書にもかかわらずまるで小説やマンガのようにリラックスして読めます。この章の Ruby の品詞の説明は、この本を参考にしました。(日本語版はこちら @<href>{http://www.aoky.net/articles/why_poignant_guide_to_ruby/})。

: TryRuby (@<href>{http://tryruby.org/})
  同じく _why 氏によるブラウザで動く Ruby 環境です。Ruby を試してみたいけどインストールするのが面倒という人は、まずはここで Ruby を試してみましょう。@<tt>{help} と打つと 15 分の短い Ruby チュートリアルが始まります。

: プログラミング Ruby (Dave Thomas ら著、オーム社)
  Ruby の完全なリファレンスです。本気で Ruby を勉強したい人は持っていて損はしません。この本だけあれば十分です。
