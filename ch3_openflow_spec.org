#+TITLE: OpenFlowの仕組み
#+AUTHOR: Yasuhito Takamiya
#+LANGUAGE: ja
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="book.css" />
#+OPTIONS: toc:nil

* OpenFlowの仕組み
#+BEGIN_VERSE
OpenFlowの概念がわかったところでもう少し細かい仕様に進みましょう。本章
では実用重視でOpenFlow仕様のポイントとよく使う用語を押さえます。
#+END_VERSE

OpenFlow標準仕様が主に定義するのは次の2つです。

1. nコントローラとスイッチの間の通信プロトコル
2. 設定されたフローエントリに対するスイッチの振る舞い

本章ではこの2つの中でも特によく使う機能のみを重点的に説明します。

執筆時のOpenFlow仕様の最新バージョンは1.3ですが、以降の説明では対応す
る商用スイッチも出そろっているバージョン1.0を説明します。なお、1.0とそ
れ以降では考え方やモデルに大きな変更はありませんので、1.0を理解してい
れば新しいバージョンも理解しやすいでしょう。

** スイッチとコントローラ間のやりとり
OpenFlowスイッチとコントローラはOpenFlow仕様で規定されたメッセージをや
りとりしながら動作します。ここでは具体的にどのようなメッセージを送受信
するか順を追って説明します。第1章で見たカスタマーサービスセンターでの
やりとりを思い出しながら読んでください。

*** スイッチとコントローラ間の接続を確立する
最初にコントローラとスイッチは接続を確立します。これをセキュアチャンネ
ルと呼びます。OpenFlowにはセキュアチャンネルをスイッチとコントローラの
どちらが始めるかの規定はありませんが、現状では▼図3-1のようにスイッチ
からコントローラへと接続する実装が多いようです。

○図3-1：スイッチがコントローラに接続しセキュアチャンネルを確立

セキュアチャンネルは普通のTCP接続です。コントローラとスイッチの両方が
対応している場合には、性能は落ちますが、よりセキュアなTLS（Transport
Layer Security）を使うこともできます。

*** バージョンのネゴシエーション
次に使用するOpenFlowプロトコルのバージョンを確認するステップ、いわゆる
バージョンネゴシエーションが始まります。セキュアチャンネルを確立すると、
スイッチとコントローラはお互いに自分のしゃべれるバージョン番号を乗せた
Helloメッセージを出し合います（▼図3-2）。

図3-2：Helloメッセージを出し合うことで相手のOpenFlowプロトコルバージョンを確認

相手と同じバージョンを話せるようであればネゴシエーションに成功で、本格
的におしゃべりを始められるようになります。

*** スイッチのスペックの確認
次にコントローラは接続したスイッチがどんなスイッチかを確認します。ネゴ
シエーション直後はまだバージョンしか確認できていないので、コントローラ
はスイッチにFeatures Requestメッセージを送って次の各情報をリクエストし
ます（▼図3-3）。

- スイッチのユニークID（Datapath IDと呼ぶ）
- スイッチポートの一覧情報
- サポートする機能の一覧

スイッチはFeatures Replyメッセージでこの情報を返信します。

○図3-3：Features Requestメッセージでスイッチのスペックを確認

*** 未知のパケットの受信
スイッチはフローテーブル中に登録されていない通信を検知すると、コントロー
ラにそのパケットを通知します。これをPacket Inメッセージと呼びます（▼
図3-4）。

○図3-4：未知のパケットとその情報がPacket Inメッセージとしてコントローラに上がる

*** フローテーブルの更新とパケットの転送
パケットを転送する場合には、Flow Modメッセージによってパケットを転送す
るためのフローエントリをスイッチのフローテーブルに書き込みます。そして、
Packet OutメッセージによってPacket Inを起こしたパケット自体を正しい宛
先に流してやります。これをやらないとPacket Inを起こしたパケットのデー
タはコントローラに残ったままで、宛先には届きません（▼図3-5）。

○図3-5：Flow Modによってフローテーブルを更新し、Packet Inを起こしたパケットをPacket Outで転送

**** コラム：【取間先生曰く】Flow ModとPacket Outを同時にやる方法？
:PROPERTIES:
:EXPORT_OPTIONS: num:nil
:END:
実はOpenFlowの仕様には、一発のFlow ModでPacket Outもまとめてやってしま
う方法が載っています。しかしこれは危険なプログラミングスタイルです。

スイッチにPacket Inが上がると、スイッチのバッファ領域にPacket Inを起こ
したパケットの中身がバッファされます。そしてコントローラに上がるPacket
Inメッセージには、このバッファ領域のID（Buffer IDと呼ばれる）が通知さ
れます。これをFlow Modのときに指定すると、スイッチがコントローラの代わ
りにPacket Outしてくれます（▼図3-a）。

○図3-a：Flow ModのときにBuffer IDを指定することで同時にPacket Outする

しかし、この方法は禁じ手です。これは次の理由によります：

- スイッチのバッファにパケットが残っているかどうかはスイッチの外から観
  測できないので、指定したBuffer IDのパケットがバッファに残っているか
  は一か八かである
- 確実にスイッチのバッファに残っているとわかっていても、Flow Modを打っ
  た瞬間に消えているかもしれない
- 格安のスイッチには、そもそもバッファがないかもしれない

というわけで、本文中で説明したようにPacket OutはFlow Modと独立して打つ
のが良い方法です。

ちなみに、Flow ModとPacket Outを同時にする場合、バッファに残っていても
いなくても正しく動く疑似コードは次のようになります。

#+BEGIN_SRC
begin
  flow_mod( Buffer-ID = packet_in.buffer_id ) # Buffer ID指定あり
rescue
  packet_out( packet_in ) # Flow Modが失敗した場合、明示的にPacket Out
end
#+END_SRC

見ればわかるように、万が一バッファに残っていなかったときの例外処理に
Packet Outを書かなければなりません。そのせいでコードが長くなってしまい
ます。

正しい方法を見てみましょう：

#+BEGIN_SRC
flow_mod # Buffer ID指定なし
packet_out( packet_in )
#+END_SRC

こちらのほうが、ずっと短いですし、正しく動きます。

*** フローエントリの寿命と統計情報
Flow Modで打ち込むフローエントリには「寿命」を設定できます。寿命の指定
には次の2種類があります。

- アイドルタイムアウト：参照されない時間がこの寿命に逹すると、そのフロー
  エントリを消す。パケットが到着し、フローエントリが参照された時点で0
  秒にリセットされる
- ハードタイムアウト: 参照の有無を問わず、フローエントリが書き込まれて
  からの時間がこの寿命に逹すると、そのフローエントリを消す

どちらのタイムアウトも0にしてフローエントリを打ち込むと、そのフローエ
ントリは明示的に消さない限りフローテーブルに残ります。

フローテーブルからフローエントリが消されるとき、消されたフローエントリ
の情報とフローエントリにしたがって処理されたパケットの統計情報がコント
ローラに通知されます（▼図3-6）。これをFlow Removedメッセージと呼びま
す。このメッセージはネットワークのトラフィック量の集計に使えます。

図3-6：フローエントリが寿命で削除されると、転送されたパケットの統計情報がFlow Removedとしてコントローラに上がる

** フローエントリの中身
第1章で見たように、フローエントリは次の3要素から成ります。

- マッチングルール
- アクション
- 統計情報

以下ではそれぞれの中身を少し細かく見ていきます。なお、これらを最初から
すべて頭に入れる必要はありません。以降の章を読んでいてわからなくなった
らレファレンスとして活用してください。

*** マッチングルール
マッチングルールとは、OpenFlowスイッチがパケットを受け取ったときにアク
ションを起こすかどうかを決める条件です。たとえば「パケットの宛先がhttp
サーバだったら」とか「パケットの宛先がブロードキャストアドレスだったら」
などという条件に適合したパケットにだけ、スイッチがアクションを起こすと
いうわけです。

OpenFlow 1.0では、▼表3-1の12種類の条件が使えます。これらの条件はいず
れもイーサネットやTCP/UDPでよく使われる値です。

#+CAPTION: マッチングルールで指定できる12 種類の条件
| 名前             | 説明                      |
|------------------+---------------------------|
| Ingress Port     | スイッチの物理ポート番号  |
| Ether src        | 送信元MACアドレス         |
| Ether dst        | 宛先MACアドレス           |
| Ether type       | イーサネットの種別        |
| IP src           | 送信元IPアドレス          |
| IP dst           | 宛先IPアドレス            |
| IP proto         | IPのプロトコル種別        |
| IP ToS bits      | IPのToS情報               |
| TCP/UDP src port | TCP/UDPの送信元ポート番号 |
| TCP/UDP dst port | TCP/UDPの宛先ポート番号   |
| VLAN id          | VLAN ID                   |
| VLAN priority    | VLAN PCPの値（CoS）       |

OpenFlowの世界では、このマッチングルールで指定できる条件を自由に組み合
わせて通信を制御します。たとえば、

- スイッチの物理ポート1番から届く、宛先がTCP 80番（＝HTTP）のパケット
  を書き換える
- MACアドレスが02:27:e4:fd:a3:5dで宛先のIPアドレスが192.168.0.0/24のパ
  ケットは遮断する

などといった具合です。

もちろん、12種類の条件すべてを指定したマッチングルールを作ることもでき
ます。これをExact Matchと呼びます。対して上の例のように一部の条件だけ
を指定したものをWildcard Matchと呼びます。特定のパケットだけをピンポイ
ントでフローエントリにひっかける場合はExact Matchを使い、幅広い種類の
パケットを1つのフローエントリでひっかける場合にはWildcard Matchを使う
と覚えてください。

*** コラム：【取間先生曰く】マッチングルールの別名
:PROPERTIES:
:EXPORT_OPTIONS: num:nil
:END:
フローエントリの3要素の1つ、マッチングルールには実は“OpenFlow 12タプ
ル”、“ヘッダフィールド”という別の呼び方もあって、よく混乱します。そ
こでこの本では“マッチングルール”で統一することにしました。パケットが
来たときにルールに従ってマッチする、という役割をすなおに表現していて、
いちばんわかりやすい名前だからです。

“OpenFlow 12タプル”はOpenFlow 1.1では15タプルになるし、この先どこま
で増えるかわかりません。つまりいつまで使えるかわからない名前です。また
“ヘッダフィールド”では、何をするものか名前からはわかりづらいし、変に
難しそうですよね。


*** コラム：【取間先生曰く】OSIネットワークモデルが壊れる？
:PROPERTIES:
:EXPORT_OPTIONS: num:nil
:END:
あるネットワークの経験豊富な若者がこんなことを言っていました。

「OpenFlowのようにレイヤをまたがって自由に何でもできるようになると、
OSIネットワークモデル（よく「レイヤ2」とか「レイヤ3」とか呼ばれるアレ
のこと。正確にはISOによって制定された、異機種間のデータ通信を実現する
ためのネットワーク構造の設計方針）が壊れるんじゃないか？」

その心配は無用です。OSIネットワークモデルは正確に言うと「OSI参照モデル」
と言って、通信プロトコルを分類して見通しを良くするために定義した“参照
用”の階層モデルです。たとえば自分がxyzプロトコルというのを作ったけど
人に説明したいというときに、どう説明するか考えてみましょう。「これはレ
イヤ3のプロトコルで、……」というふうに階層を指して（参照して）説明を
始めれば相手に通りがよいでしょう。つまり、OSIネットワークモデルはネッ
トワーク屋同士で通じる「語彙」として使える、まことに便利なものなのです。

でも、これはあくまで「参照」であって「規約」ではないので、すべてのネッ
トワークプロトコルや、ネットワーク機器がこれに従わなければいけない、と
いうものではありません。さっき言ったように「この○○は、仮にOSIで言う
とレイヤ4にあたる」のように使うのが正しいのです。

そして、OpenFlowはたまたまいくつものレイヤの情報が使える、ただそれだけ
のことです。

*** アクション
アクションとは、スイッチに入ってきたパケットをどう料理するか、という動
詞にあたる部分です。よく「OpenFlowでパケットを書き換えて曲げる」などと
言いますが、こうした書き換えなどはすべてアクションで実現できます。それ
では、OpenFlow 1.0ではどんなアクションが定義されているか見てみましょう。

アクションは大きく分けて次の4種類があります。

- Forward：パケットを指定したポートから出す
- Modify-Field：パケットの中身を書き換える
- Drop：パケットを捨てる
- Enqueue：ポートごとに指定されたスイッチのキューに入れる。QoS用

アクションは動詞と同じく指定した順番に実行されます。「おにぎりを作って、
食べて、片付ける」といったふうに。たとえば、パケットを書き換えて指定し
たポートから出したいときには、

#+BEGIN_SRC
[Modify-Field, Forward]
#+END_SRC

というアクションのリストを指定します。

ここで、アクションは指定された順番に実行されることに注意してください。
アクションの順番を変えてしまうと、違う結果が起こります。たとえば「おに
ぎりを食べてから、おにぎりを作る」と最後におにぎりが残ってしまいます。
同様に先ほどの例を逆にしてしまうと、まず先にパケットがフォワードされて
しまいます。その後Modify-Fieldが実行されても、書き換えられた後、そのパ
ケットは破棄されるだけです。

#+BEGIN_SRC
# パケットを書き換える前にフォワードされてしまう。
[Forward, Modify-Field]
#+END_SRC

同じ動詞を複数指定することもできます。

#+BEGIN_SRC
[Modify-Field A, Modify-Field B, Forward A, Forward B]
#+END_SRC

この場合は、フィールドAとBを書き換えて、ポートAとBへフォワードする、と
読めます。このように、複数のフィールドを書き換えたり、複数のポートにパ
ケットを出したりする場合には、アクションを複数連ねて指定します▼注1。

○注1：指定できるアクション数の上限はOpenFlowスイッチとコントローラの
実装に依存します。普通に使う分にはまず問題は起こりません。

Dropは特殊なアクションで、実際にDropアクションというものが具体的に定義
されているわけではありません。アクションのリストにForwardアクションを1
つも入れなかった場合、そのパケットはどこにもフォワードされずに捨てられ
ます。これを便宜的にDropアクションと呼んでいるわけです。

それでは、最もよく使われるForwardアクションとModify-Fieldアクションで
具体的に何が指定できるか見ていきましょう。

**** Forwardアクション
Forwardアクションでは指定したポートからパケットを出力します。出力先に
はスイッチのポート番号を指定しますが、特殊用途のために定義されている論
理ポートを使うこともできます。

- ポート番号：パケットを指定した番号のポートに出す
- IN_PORT：パケットを入ってきたポートに出す
- ALL：パケットを入ってきたポート以外のすべてのポートに出す
- FLOOD：パケットをスイッチが作るスパニングツリーに沿って出す
- CONTROLLER：パケットをコントローラに明示的に送り、Packet Inを起こす
- NORMAL：パケットをスイッチの機能を使って転送する
- LOCAL：パケットをスイッチのローカルスタックに上げる。ローカルスタッ
  ク上で動作するアプリケーションにパケットを渡したい場合に使う。あまり
  使われない

この中でもFLOODやNORMALはOpenFlowスイッチ機能と既存のスイッチ機能を組
み合わせて使うための論理ポートです。

**** Modify-Fieldアクション
Modify-Fieldアクションではパケットのさまざまな部分を書き換えできます。

- 送信元MACアドレスの書き換え
- 宛先MACアドレスの書き換え
- 送信元IPアドレスの書き換え
- 宛先IPアドレスの書き換え
- ToSフィールドの書き換え
- TCP/UDP送信元ポートの書き換え
- TCP/UDP宛先ポートの書き換え
- VLANヘッダの除去
- VLAN IDの書き換え（VLANヘッダがなければ、新たに付与する)
- VLANプライオリティの書き換え（VLANヘッダがなければ、新たに付与する)

それぞれのアクションでできることと、代表的な使い道を順番に見ていきましょう。

***** MACアドレスの書き換え
MACアドレス書き換えの典型的な例がルータです。OpenFlowはルータの実装に
必要な、送信元と宛先MACアドレスの書き換えアクションをサポートしていま
す。

ルータは2つのネットワークの間で動作し、ネットワーク間で行き交うパケッ
トの交通整理を行います（▼図3-7）。ホストAが異なるネットワークに属する
ホストBにパケットを送ると、ルータはそのパケットを受け取りその宛先IPア
ドレスから転送先のネットワークを決定します。そして、パケットに記述され
た宛先MACアドレスを次に送るべきホストのMACアドレスに、送信元を自分の
MACアドレスに書き換えてデータを転送します。

○図3-7：ルータでの送信元と宛先MACアドレスの書き換え

***** IPアドレスの書き換え
IPアドレス書き換えの典型的な例がNAT（Network Address Transition）です。
OpenFlowはNATの実装に必要な、送信元と宛先IPアドレスの書き換えアクショ
ンをサポートしています。

インターネットと接続するルータでは、プライベート／グローバルネットワー
ク間での通信を通すためにIPアドレスを▼図3-8のように変換します。

○図3-8：NATでの送信元と宛先IPアドレスの書き換え

プライベートネットワーク内のクライアントからインターネット上のサーバに
通信をする場合、ゲートウェイはプライベートネットワークから届いたパケッ
トの送信元IPアドレスを自分のグローバルなIPアドレスに変換して送信します。
逆にサーバからの返信は逆の書き換えを行うことによりプライベートネットワー
ク内のクライアントに届けます。

***** ToSフィールドの書き換え
ToSフィールドは通信のサービス品質（QoS）を制御する目的でパケットを受け
取ったルータに対して処理の優先度を指定するために使われます。OpenFlowは
このToSフィールドの書き換えアクションをサポートしています。

***** TCP/UDPポート番号の書き換え
TCP/UDPポート番号書き換えの典型的な例がIPマスカレードです。OpenFlowは
IPマスカレードの実装に必要な、送信元と宛先のTCP/UDPポート番号の書き換
えアクションをサポートしています。

ブロードバンドルータなど1つのグローバルアドレスで複数のホストが同時に
通信を行う環境では、NATだけだとTCP/UDPのポート番号が重複する可能性があ
ります。そこで、IPマスカレードではプライベートネットワーク側のポート番
号をホストごとに適当に割り当て、通信の都度ポート番号を変換することで解
決します（▼図3-9）。

○図3-9：IPマスカレードでの送信元と宛先TCP/UDPポート番号の書き換え

***** VLANヘッダの書き換え
既存のタグ付きVLANで構築したネットワークとOpenFlowで構築したネットワー
クを接続するという特別な用途のために、VLANヘッダの書き換えアクションが
あります。VLANを一口に説明すると、既存のスイッチで構成されるネットワー
ク（ブロードキャストが届く範囲のネットワーク）を複数のネットワークに分
割して使用するための仕組みです▼注2。どのVLANに所属するかを区別するの
がVLANのタグ（VLAN ID）で、パケットに付与されるVLANヘッダがこのタグ情
報を含みます。Modify-FieldアクションはVLANヘッダの操作に必要なアクショ
ンを3種類用意しています（▼図3-10）。

○注2：この分割したネットワーク自体をVLANと呼ぶ場合もあります。

○図3-10：VLANヘッダを書き換えるアクションの使い道

***** VLANヘッダの除去
VLANを流れるVLANヘッダ付きパケットからVLANヘッダを除去し、普通のパケッ
トに戻すアクションです。

***** VLAN IDの書き換え
VLANパケットが属するVLANのIDを書き換えます。たとえばVLAN IDを1から3に
書き換えるといったアクションを指定できます。また、VLANヘッダがついてい
ないパケットに 指定したVLAN IDを持つVLANヘッダを付与することもできます。

***** VLANプライオリティの書き換え
VLAN上でのパケットを転送する優先度（プライオリティ）を変更します。この
プライオリティはトラフィックの種類（データ、音声、動画など）を区別する
場合などに使います。指定できる値は0（最低）から7（最高）までです。

**** 統計情報
OpenFlow 1.0ではフローエントリごとに次の統計情報を取得できます。

- 受信パケット数
- 受信バイト数
- フローエントリが作られてからの経過時間（秒）
- フローエントリが作られてからの経過時間（ナノ秒）

** まとめ
OpenFlow仕様の中でもとくにポイントとなる部分を見てきました。ここまでの
章で学んできた内容だけで、すでにOpenFlow専門家と言ってもよいほどの知識
が身に付いたはずです。次の章ではOpenFlowコントローラを開発するための代
表的なプログラミングフレームワークを紹介します。
