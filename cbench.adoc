[[cbench]]
= マイクロベンチマークcbench
:imagesdir: images/cbench

本格的なOpenFlowプログラミングの第一歩として、スイッチのフローテーブルを書き換えてみましょう。マイクロベンチマークツールcbenchを題材に、Packet InとFlow Modメッセージの使い方を学びます。

== Cbenchベンチマークとは

CbenchはOpenFlow1.0コントローラのためのベンチマークです。Cbenchは「1秒あたりにコントローラが出せるFlow Modの数」を計測します。これはOpenFlowプロトコル全体のうちの局所的な部分だけを対象にしているので、ベンチマークの中でもマイクロベンチマークに分類できます。

Cbenchは<<cbench_overview,図3-1>>のように動作します。まずcbenchプロセスはOpenFlowスイッチのふりをしてコントローラに接続し、コントローラにPacket Inを連続して送ります。コントローラはPacketInを受け取るとcbenchプロセスにFlowModを返します。cbenchは決められた時間の間に受け取ったFlow Modの数をカウントし、ベンチマークのスコアとします。そしてこのスコアが大きいコントローラほど「速い」とみなします。

[[cbench_overview]]
image::cbench_overview.png[caption="図3-1",title="cbenchとコントローラの動作"]

=== Cbenchの動作モード

Cbenchはレイテンシモードとスループットモードという2種類のモードをサポートします。

- レイテンシモードでは、cbenchプロセスはコントローラと同期的に動作します。PacketInを送ったcbenchはコントローラからFlow Modが返ってくるのを待ち、FlowModが届くとカウントします。そして次のPacketInをコントローラに送ります。
- スループットモードでは、cbenchプロセスとコントローラは非同期的に動作します。cbenchはFlowModの到着を待たずにとにかくPacketInを送信し続け、FlowModが到着したタイミングでカウントします。

一般に、スループットモードの方がベンチマーク結果は良くなります。たとえばコントローラのイベントハンドラがスレッド化されている場合、コントローラはFlowModの送信完了を待たなくても新しく届いたPacketInに対してどんどんFlowModを返せるからです。

しかしコントローラ側で特に高速化の工夫をしていない場合、レイテンシモードとスループットモードでは性能の差はほとんどありません。たとえばTremaのハンドラはシングルスレッドで動くので、cbenchプロセスと同期的に動きます。このため、スループットモードでも性能はほとんど上がりません。

Tremaがこうなっているのは、スレッドに伴うプログラマの負担を避けるためです。性能は犠牲になりますが、スレッドに伴う特別なコーディングやバグを回避できます。もちろん、もしどうしても性能を上げたい場合には、そのためのオプションも残しています。このあたりのことは後ほど詳しく見るとして、まずはCbenchをインストールして動かしてみましょう。

== Cbenchのインストール

cbenchの実行にはopenflow.org footnote:[http://archive.openflow.org/] の配布するベンチマークスイートOflopsが必要です。Tremaが公開するtrema/cbenchにはOflops一式とcbenchコントローラのソースコードが含まれています。次のコマンドでダウンロードしてください。

----
$ git clone https://github.com/trema/cbench.git
----

ダウンロードしたソースツリー上で `bundle install --binstubs` を実行すると、Tremaの `./bin/trema` コマンドとライブラリ一式を自動的にインストールできます。

----
$ cd cbench
bundle install --binstubs
----

以上でcbenchとTremaのセットアップは完了です。

== Cbenchを実行する

Cbenchをレイテンシモードで実行してみましょう。まず、スイッチとして動作するcbenchプロセスと接続するコントローラを次のように起動します。

----
$ ./bin/trema run ./lib/cbench.rb
----

そして別ターミナルを開き、次のコマンドでcbenchプロセスを実行しベンチマークを開始します。

----
$ ./bin/cbench --port 6633 --switches 1 --loops 10 --ms-per-test 10000 --delay 1000
cbench: controller benchmarking tool
   running in mode 'latency'
   connecting to controller at localhost:6633
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  332   total = 0.033193 per ms
1   switches: fmods/sec:  329   total = 0.032900 per ms
1   switches: fmods/sec:  314   total = 0.031400 per ms
1   switches: fmods/sec:  336   total = 0.033600 per ms
1   switches: fmods/sec:  364   total = 0.036388 per ms
1   switches: fmods/sec:  352   total = 0.035188 per ms
1   switches: fmods/sec:  352   total = 0.035187 per ms
1   switches: fmods/sec:  352   total = 0.035200 per ms
1   switches: fmods/sec:  352   total = 0.035195 per ms
1   switches: fmods/sec:  352   total = 0.035200 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 31.40/36.39/34.47/1.45 responses/s
----

この例では、10秒間のベンチマークを10回実行しその結果を表示しています。実行環境によって値は変わりますが、Tremaは秒間約300回のFlowModを打てることがわかります。

[WARNING]
.Cbenchの注意点
====
Cbench のスコアを盲信しないようにしてください。現在、OpenFlow コントローラ多くがその性能指標として Cbench のスコアを使っているのをよく見掛けます。たとえば Floodlight (http://www.projectfloodlight.org/) は 1 秒間に 100 万発の Flow Mod を打てると宣伝しています。実際にこれはなかなかすごい数字です。きちんと計算したわけではないですが、スレッドを駆使してめいっぱい I/O を使い切るようにしなければなかなかこの数字は出ません。とにかくすごい。でも、この数字にはまったく意味がありません。

Flow Mod を一秒間に 100 万発打たなければならない状況を考えてみてください。それは、Packet In が一秒間に 100 万発起こる状況ということになります。Packet In が一秒間に 100 万発起こるとはどういうことでしょうか? スイッチに何らかのフローが設定されているが入ってきたパケットがまったくそれにマッチせず、どうしたらいいかわからないパケットがすべてコントローラへやってくる、これが一秒間に 100 万回起こるということです。明らかに何かがまちがっています。

コントローラが Packet In を何発さばけるかという性能は、極端に遅くない限りは重要ではありません。データセンターのように、どこにどんなマシンが ありどういう通信をするか把握できている場合は、フローをちゃんと設計していれば Packet In はそんなに起こらないからです。力技で Packet In をさば くよりも、いかに Packet In が起こらないネットワーク設計やフロー設計をするかの方がずっと大事です。

Cbench のようなマイクロベンチマークでは、測定対象が何でその結果にはどんな意味があるか？を理解しないと針小棒大な結論を招きます。Cbench のスコアは参考程度にとどめましょう。
====

== Cbenchのソースコード

cbenchが正しく実行できたところで、CbenchのソースコードからPacket InとFlow Modメッセージの処理方法を見ていきましょう。ファイルは lib/cbench.rb です。

[source,ruby,subs="verbatim,attributes"]
.lib/cbench.rb
----
# A simple openflow controller for benchmarking.
class Cbench < Trema::Controller
  def start(_args)
    logger.info 'Cbench started.'
  end

  def packet_in(datapath_id, message)
    send_flow_mod_add(
      datapath_id,
      match: ExactMatch.new(message),
      buffer_id: message.buffer_id,
      actions: SendOutPort.new(message.in_port + 1)
    )
  end
end
----

// TODO Ruby 入門でハッシュとキーワード引数、.newメソッドを説明する

=== startハンドラ

前章と同じく、`start` ハンドラでコントローラの起動をログに書き込みます。ユーザ引数は今回も使っていないので、仮引数の名前は `_args` のようにアンダースコアで始めます。

// TODO: 2 章で _args の説明をしておく
// TODO: ここは、`packet_in`をスレッド化する/しないのスイッチをユーザ引数でコントロールできるようにしておく? そうしたら、パッチパネル章でユーザ引数の処理の説明を省ける。

=== packet_inハンドラ

コントローラに上がってくる未知のパケットを拾うには、Packet Inハンドラをコントローラクラスに実装します。典型的なPacket Inハンドラは次のようになります.

[source,ruby,subs="verbatim,attributes"]
.lib/cbench.rb
----
class Cbench < Trema::Controller

  # ...

  def packet_in(datapath_id, message)
    send_flow_mod_add(
      datapath_id,
      match: ExactMatch.new(message),
      buffer_id: message.buffer_id,
      actions: SendOutPort.new(message.in_port + 1)
    )
  end
end
----

`packet_in` ハンドラではPacket Inを起こしたスイッチ(cbenchプロセス)のDatapathIDとPacket Inメッセージそのものを引数として受け取ります。2番目の引数messageはPacketInクラスのインスタンスで、Packet Inメッセージをオブジェクトとしてラップしたものです。このPacketInクラスには主に次の3種類のメソッドが定義されています。

- Packet Inを起こしたパケットのデータやその長さ、およびパケットが入ってきたスイッチのポート番号などOpenFlowメッセージ固有の情報を返すメソッド
- Packet Inを起こしたパケットの種別 (TCPかUDPか? またVLANタグの有無など)を判定するための”?”で終わるメソッド
- 送信元や宛先のMACアドレスやIPアドレスなど、パケットの各フィールドを調べるためのアクセサメソッド

PacketInクラスは非常に多くのメソッドを持っており、またTremaのバージョンアップごとにその数も増え続けているためすべては紹介しきれません。そのかわり、代表的でよく使うものを以下に紹介します。

// TODO メソッド名を更新
// TODO それぞれのメソッドの受け入れテスト

- `:raw_data` パケットのデータ全体をバイナリ文字列で返す
- `:in_port` パケットが入ってきたスイッチのポート番号を返す
- `:total_length` パケットのデータ長を返す
- `:buffered?` Packet Inを起こしたパケットがスイッチにバッファされているかどうかを返す
- `:source_mac` パケットの送信元MACアドレスを返す
- `:destination_mac` パケットの宛先MACアドレスを返す
- `:ipv4?` パケットがIPv4である場合 `true` を返す
- `:ipv4_protocol` IPのプロトコル番号を返す
- `:ipv4_source_address` パケットの送信元IPアドレスを返す
- `:ipv4_destination_address` パケットの宛先IPアドレスを返す
- `:ipv4_tos` IPのToSフィールドを返す
- `:tcp?` パケットがTCPである場合 `true` を返す
- `:tcp_source_port` パケットのTCPの送信元ポート番号を返す
- `:tcp_destination_port` パケットのTCP宛先ポート番号を返す
- `:udp?` パケットがUDPである場合 `true` を返す
- `:udp_source_port` パケットのUDPの送信元ポート番号を返す
- `:udp_destination_port` パケットのUDPの宛先ポート番号を返す
- `:vlan?` パケットにVLANヘッダが付いている場合 `true` を返す
- `:vlan_vid` VLANのVIDを返す
- `:vlan_priority` VLANの優先度を返す
- `:ether_type` イーサタイプを返す

このようなメソッドは他にもたくさんあります。完全なメソッドのリストや詳しい情報を知りたい場合には、<<hello_trema,第2章>>で紹介した最新のTrema APIドキュメントを参照してください。

// TODO 2章で Trema APIドキュメントを紹介したか確認

=== Flow Modの送りかた

コントローラからcbenchへと送るFlowModメッセージは、次の内容にセットする必要があります。

- マッチングルール: PacketInしたメッセージのExactMatch
- バッファID: PacketInしたメッセージのバッファID
- アクション: PacketInしたメッセージのin_portに+1したポートへ転送

`send_flow_mod_add` メソッドにこれらのオプションを渡すことで、実際にスイッチへFlow Modを送ることができます。それぞれの指定方法を順に見ていきましょう。

=== マッチングルール (OpenFlow 1.0)

マッチングルールには、`:in_port` 以外にも次の12種類の条件を指定できます。

// TODO Pioのopen\_flow10/match.featureを書く
// TODO OpenFlow1.3 でのMatchの説明へのポインタを付ける

- `:in_port` スイッチの物理ポート番号
- `:ether_source_address` 送信元MACアドレス
- `:ether_destination_address` 宛先MACアドレス
- `:ether_type` イーサネットの種別
- `:ip_source_address` 送信元IPアドレス
- `:ip_destination_address` 宛先IPアドレス
- `:ip_protocol` IPのプロトコル種別
- `:ip_tos` IPのToSフィールド
- `:transport_source_port` TCP/UDPの送信元ポート番号
- `:transport_destination_port` TCP/UDPの宛先ポート番号
- `:vlan_vid` VLAN IDの値
- `:vlan_priority` VLANのプライオリティ

=== Exact Matchの作り方 (OpenFlow 1.0)

マッチングルールの中でもすべての条件を指定したものをExact Matchと呼びます。たとえばPacket Inとしてコントローラに入ってきたパケットと、

- パケットが入ってきたスイッチのポート番号
- 送信元MACアドレス
- 宛先MACアドレス
- …

などなどマッチングルールが定義する12個の条件がすべてまったく同じ、というのがExact Matchです。

マッチングルールを作る構文 `Match.new` にこの12種類の条件すべてを渡せば、次のようにExact Matchを作れます。

[source,ruby,subs="verbatim,attributes"]
----
def packet_in(dpid, message)
  # ...

  send_flow_mod_add(
    dpid,
    match: Match.new(
      in_port: message.in_port,
      ether_source_address: message.ether_source_address,
      ether_destination_address: message.ether_destination_address,
   ...
----

しかし、マッチングルールを1つ作るだけで12行も書いていたら大変です。そこで、TremaではPacketInメッセージからExact Matchを楽に書ける次のショートカットを用意しています。

[source,ruby,subs="verbatim,attributes"]
----
def packet_out(dpid, message)
  send_flow_mod_add(
    dpid,
    match: ExactMatch.new(message),
    ...
----

たった1行で書けました! Tremaにはこのようにコードを短く書ける工夫がたくさんあります。

=== アクション (OpenFlow1.0)

アクションには、`SendOutPort` をはじめとして、次の13種類のアクションを指定できます。

// TODO マッチの名前をアクションの名前に合わせる
// TODO OpenFlow1.3 のそれぞれのアクションの .feature を pio に入れる
// TODO `SendOutPort`の説明で触れている、論理ポートの説明を書く

- `SendOutPort`  指定したスイッチのポートにパケットを出力する。ポートにはポート番号または論理ポート(第○章参照)を指定できる
- `SetEtherSourceAddress` 送信元MACアドレスを指定した値に書き換える
- `SetEtherDestinationAddress`  宛先MACアドレスを指定した値に書き換える
- `SetIpSourceAddress` 送信元のIPアドレスを指定した値に書き換える
- `SetIpDstinationAddress` 宛先のIPアドレスを指定した値に書き換える
- `SetIpTos` IPのToSフィールドを書き換える
- `SetTransportSourcePort`  TCP/UDPの送信元ポート番号を書き換える
- `SetTransportDestinationPort` TCP/UDPの宛先ポート番号を書き換える
- `StripVlanHeader` VLANのヘッダを除去する
- `SetVlanVid`  指定したVLAN IDをセットする、または既存のものがあれば書き換える
- `SetVlanPriority`  指定したVLANプライオリティをセットする、または既存のものがあれば書き換える
- `Enqueue` 指定したスイッチポートのキューにパケットを入れる
- `VendorAction`  ベンダ定義のアクションを実行する

まだ使っていないアクションについては、続く章で具体的な使い方を見ていきます。

=== send_flow_mod_addのオプション一覧

最後に補足として、`send_flow_mod_add` で指定できるすべてのオプションを紹介しておきます。Flow Modには次にようにたくさんのパラメータがあります。

// TODO それぞれのオプションの受け入れテストを書く
// TODO ここ、Ruby2.0 のキーワード引数が使えるところだ。あとでリファクタリングしておく。

- `:match`  フローエントリのマッチングルールを指定する。本章で紹介した `Match` オブジェクトまたは `ExactMatch` オブジェクトを指定する
- `:actions`  フローエントリのアクションを指定する。アクションはアクションの配列または単体で指定できる
- `:idle_timeout`  フローエントリが一定時間参照されなかった場合に破棄されるまでの秒数を指定する。デフォルトは0秒で、この場合フローエントリは破棄されない
- `:hard_timeout`  フローエントリの寿命を秒数で指定する。デフォルトは0秒で、この場合フローエントリは破棄されない
- `:priority`  フローエントリの優先度(符号なし16ビット、大きいほど優先度高)。Packet Inメッセージはこの優先度淳にフローエントリのマッチングルールと照し合わされる。デフォルトは `0xffff` (最高優先度)
- `:send_flow_removed`  タイムアウトでフローエントリが消えるときに、Flow Removedメッセージをコントローラに送るかどうかを指定する。デフォルトは `true`
- `:check_overlap` `true` にセットすると、フローテーブルの中に同じ優先度で競合するものがあった場合、フローエントリを追加せずにエラーを起こす。デフォルトは `false`
- `:emerg` `true` にセットすると、フローエントリを緊急エントリとして追加する。緊急エントリはスイッチが何らかの障害でコントローラと切断したときにのみ有効となる。デフォルトは `false`
- `:cookie`  任意の用途に使える64ビットの整数。使い道としては、同じクッキー値を持つフローエントリ同士をまとめて管理するなどといった用途がある

こうしたオプションも、続くいくつかの章で具体的な使い方を紹介します。

== Cbenchを高速化する

Tremaのハンドラはシングルスレッドなので、cbenchはあまり速くありません。デフォルトでシングルスレッドとなっている理由は、最初に説明したとおり、スレッドに伴うさまざまな問題を避けるためです。

もしハンドラがそれぞれ独立したスレッドで動く場合、スレッド間の同期をプログラマが正しく処理しなければなりません。たとえば以下のように `packet_in` ハンドラの中でインスタンス変数の内容を変更したい場合、インスタンス変数はすべてのスレッドで共有しているので、読み書きの間だけスレッド間で同期してやる必要があります。もしプログラマがこれを忘れると、タイミングや環境に起因するやっかいなバグが発生してしまいます。

[source,ruby,subs="verbatim,attributes"]
----
class Foo < Trema::Controller
  def start(_args)
    @db = DB.new  # インスタンス変数
  end

  def packet_in(dpid, message)
    # packet_in ハンドラがマルチスレッドで動く場合、
    # ここで@dbの読み書きをするのは危険!!!
  end
end
----

スレッド間同期の代表的な手法がMutexです。たとえば上の例をMutexを使って正しく書くとこうなります。

[source,ruby,subs="verbatim,attributes"]
----
class Foo < Trema::Controller
  def start(_args)
    @db = DB.new  # インスタンス変数
    @mutex = Mutex.new  # スレッド間の同期用 Mutex
  end

  def packet_in(dpid, message)
    @mutex.synchronize do
      # この中で@dbを読み書きすれば安全
    end
  end
end
----

このように、もしデフォルトでハンドラが別スレッドで動くと、同期のためのコードをすべてのハンドラに入れてやる必要があります。Tremaはこれを避けるため、あえてシングルスレッドにしています。

もし高速化したい場合には、そのためのオプションが残されています。次のように高速化したいハンドラメソッドの中身を別スレッドで起動し、インスタンス変数へのアクセスを同期すれば高速化できます。

[source,ruby,subs="verbatim,attributes"]
----
class Foo < Trema::Controller
  def initialize(_args)
    @mutex = Mutex.new
  end

  def packet_in(dpid, message)
    Thread.start do
      @mutex.synchronize do
        (インスタンス変数への読み書き)
      end
    end
  end
end
----

たとえばCbenchクラスをマルチスレッド化すると次のようになります。ここでは、スレッドを新しく起動するオーバーヘッドを避けるために、スレッドプールとしてあらかじめ100個のスレッドを作っておき、`packet_in` ハンドラが呼ばれるたびにスレッドプール内のスレッドに `packet_in` の処理をまかせます。

[source,ruby,subs="verbatim,attributes"]
----
class Cbench < Trema::Controller
  def start(_args)
    @thread_pool = ThreadPool.new(100)
    logger.info 'Cbench started.'
  end

  def packet_in(datapath_id, message)
    @thread_pool.start do
      send_flow_mod_add(
        datapath_id,
        match: ExactMatch.new(message),
        buffer_id: message.buffer_id,
        actions: SendOutPort.new(message.in_port + 1)
      )
    end
  end
end
----

Cbenchクラスではインスタンス変数を使っていないため、Mutexによる同期なしに簡単にスレッド化できます。実際にスループットモードで性能を計測してみましょう。

// TODO trema/cbench のREADMEで bundle install —binstubs していないのを直す。コマンド実行も bundle exec となってるところは直す。

----
$ ./bin/trema run lib/cbench.rb
----

別ターミナルで、

----
$ ./bin/cbench --port 6653 --switches 1 --loops 10 --ms-per-test 10000 --delay 1000 --throughput
----

----
cbench: controller benchmarking tool
  running in mode 'throughput'
  connecting to controller at localhost:6633
  faking 1 switches :: 10 tests each; 1000 ms per test
  with 100000 unique source MACs per switch
  starting test with 1000 ms delay after features_reply
  ignoring first 1 "warmup" and last 0 "cooldown" loops
  debugging info is off
1   switches: fmods/sec:  36883   total = 36.761283 per ms
1   switches: fmods/sec:  36421   total = 36.398433 per ms
1   switches: fmods/sec:  37286   total = 37.174106 per ms
1   switches: fmods/sec:  36559   total = 36.526637 per ms
1   switches: fmods/sec:  36072   total = 36.007331 per ms
1   switches: fmods/sec:  34130   total = 33.993855 per ms
1   switches: fmods/sec:  32119   total = 32.086016 per ms
1   switches: fmods/sec:  33733   total = 33.533876 per ms
1   switches: fmods/sec:  33270   total = 33.262582 per ms
1   switches: fmods/sec:  32119   total = 32.107056 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 32086.02/37174.11/34565.54/1866.96 responses/s
----

// TODO 実行結果をアップデート

たしかに元の値に比べて○%高速化できました。

== まとめ

PacketInとFlowModの最初の一歩として、ベンチマークツールcbenchと接続できるコントローラを書きました。

- フローエントリを追加するための `send_flow_mod_add` を使って、スイッチのフローテーブルを書き換えた
- マッチングルールの作り方と、指定できるルールを学んだ
- Forwardアクションによるパケットの転送と、その他のアクションを学んだ
- コントローラをスレッドで高速化する方法を学んだ

PacketInとFlowModはOpenFlowの重要なメッセージなので、続く章ではさらに使いかたに慣れていきます。コントローラにOpenFlowスイッチをつなぎ、フローエントリの書き換えとパケットの転送を実験してみます。
